{
  "type": "CMD_EXEC",
  "description": "1.5.2 Ensure ptrace_scope is restricted",
  "info": "The ptrace() system call provides a means by which one process (the \\\"tracer\\\") may observe and control the execution of another process (the \\\"tracee\\\"), and examine and change the tracee's memory and registers.\n\nThe sysctl settings (writable only with CAP_SYS_PTRACE) are:\n\n - 0 - classic ptrace permissions: a process can PTRACE_ATTACH to any other process running under the same uid, as long as it is dumpable (i.e. did not transition uids, start privileged, or have called prctl(PR_SET_DUMPABLE...) already). Similarly, PTRACE_TRACEME is unchanged.\n - 1 - restricted ptrace: a process must have a predefined relationship with the inferior it wants to call PTRACE_ATTACH on. By default, this relationship is that of only its descendants when the above classic criteria is also met. To change the relationship, an inferior can call prctl(PR_SET_PTRACER, debugger, ...) to declare an allowed debugger PID to call PTRACE_ATTACH on the inferior. Using PTRACE_TRACEME is unchanged.\n - 2 - admin-only attach: only processes with CAP_SYS_PTRACE may use ptrace with PTRACE_ATTACH, or through children calling PTRACE_TRACEME.\n - 3 - no attach: no processes may use ptrace with PTRACE_ATTACH nor via PTRACE_TRACEME. Once set, this sysctl value cannot be changed.\n\nIf one application is compromised, it would be possible for an attacker to attach to other running processes (e.g. Bash, Firefox, SSH sessions, GPG agent, etc) to extract additional credentials and continue to expand the scope of their attack.\n\nEnabling restricted mode will limit the ability of a compromised process to PTRACE_ATTACH on other processes running under the same user. With restricted mode, ptrace will continue to work with root user.",
  "solution": "\"Set the kernel.yama.ptrace_scope parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending inconf to a value of 1 2 or 3 :\n\nkernel.yama.ptrace_scope = 1\n    - OR -\nkernel.yama.ptrace_scope = 2\n    - OR -\nkernel.yama.ptrace_scope = 3",
  "Example": "# printf \\\"%s\\n\\\" \\\"kernel.yama.ptrace_scope = 1\\\" >> /etc/sysctl.d/60-kernel_sysctl.conf\n\nRun the following command to set the active kernel parameter:\n\n# sysctl -w kernel.yama.ptrace_scope=1",
  "Note": "- If a value of 2 or 3 is preferred, or required by local site policy, replace the 1 with the desired value of 2 or 3 in the example above\n - If this setting appears in a canonically later file, or later in the same file, the setting will be overwritten\"",
  "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171r3|03.04.02,800-171r3|03.04.06,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO-27001-2022|A.8.9,ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
  "see_also": "https://workbench.cisecurity.org/benchmarks/18959",
  "cmd": "#!/bin/bash\n\n{\n   a_output=(); a_output2=(); a_parlist=(\\\"kernel.yama.ptrace_scope=(1|2|3)\\\")\n   l_ufwscf=\\\"$([ -f /etc/default/ufw ] && awk -F= '/^\\\\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw)\\\"\n   f_kernel_parameter_chk()\n   {\n      l_running_parameter_value=\\\"$(sysctl \\\"$l_parameter_name\\\" | awk -F= '{print $2}' | xargs)\\\" # Check running configuration\n      if grep -Pq -- '\\\\b'\\\"$l_parameter_value\\\"'\\\\b' <<< \\\"$l_running_parameter_value\\\"; then\n         a_output+=(\\\" - \\\\\\\"$l_parameter_name\\\\\\\" is correctly set to \\\\\\\"$l_running_parameter_value\\\\\\\"\\\"\n         \\\"    in the running configuration\\\")\n      else\n         a_output2+=(\\\" - \\\\\\\"$l_parameter_name\\\\\\\" is incorrectly set to \\\\\\\"$l_running_parameter_value\\\\\\\"\\\" \\\\\n         \\\"    in the running configuration\\\" \\\\\n         \\\"    and should have a value of: \\\\\\\"$l_value_out\\\\\\\"\\\")\n      fi\n      unset A_out; declare -A A_out # Check durable setting (files)\n      while read -r l_out; do\n         if [ -n \\\"$l_out\\\" ]; then\n            if [[ $l_out =~ ^\\\\s*# ]]; then\n               l_file=\\\"${l_out//# /}\\\"\n            else\n               l_kpar=\\\"$(awk -F= '{print $1}' <<< \\\"$l_out\\\" | xargs)\\\"\n               [ \\\"$l_kpar\\\" = \\\"$l_parameter_name\\\" ] && A_out+=([\\\"$l_kpar\\\"]=\\\"$l_file\\\")\n            fi\n         fi\n      done < <(\\\"$l_systemdsysctl\\\" --cat-config | grep -Po '^\\\\h*([^#\\\\n\\\\r]+|#\\\\h*\\\\/[^#\\\\n\\\\r\\\\h]+\\\\.conf\\\\b)')\n      if [ -n \\\"$l_ufwscf\\\" ]; then # Account for systems with UFW (Not covered by systemd-sysctl --cat-config)\n         l_kpar=\\\"$(grep -Po \\\"^\\\\h*$l_parameter_name\\\\b\\\" \\\"$l_ufwscf\\\" | xargs)\\\"\n         l_kpar=\\\"${l_kpar//\\\\//.}\\\"\n         [ \\\"$l_kpar\\\" = \\\"$l_parameter_name\\\" ] && A_out+=([\\\"$l_kpar\\\"]=\\\"$l_ufwscf\\\")\n      fi\n      if (( ${#A_out[@]} > 0 )); then # Assess output from files and generate output\n         while IFS=\\\"=\\\" read -r l_fkpname l_file_parameter_value; do\n            l_fkpname=\\\"${l_fkpname// /}\\\"; l_file_parameter_value=\\\"${l_file_parameter_value// /}\\\"\n            if grep -Pq -- '\\\\b'\\\"$l_parameter_value\\\"'\\\\b' <<< \\\"$l_file_parameter_value\\\"; then\n               a_output+=(\\\" - \\\\\\\"$l_parameter_name\\\\\\\" is correctly set to \\\\\\\"$l_file_parameter_value\\\\\\\"\\\" \\\\\n               \\\"    in \\\\\\\"$(printf '%s' \\\"${A_out[@]}\\\")\\\\\\\"\\\")\n            else\n               a_output2+=(\\\" - \\\\\\\"$l_parameter_name\\\\\\\" is incorrectly set to \\\\\\\"$l_file_parameter_value\\\\\\\"\\\"\n               \\\"    in \\\\\\\"$(printf '%s' \\\"${A_out[@]}\\\")\\\\\\\"\\\" \\\\\n               \\\"    and should have a value of: \\\\\\\"$l_value_out\\\\\\\"\\\")\n            fi\n         done < <(grep -Po -- \\\"^\\\\h*$l_parameter_name\\\\h*=\\\\h*\\\\H+\\\" \\\"${A_out[@]}\\\")\n      else\n         a_output2+=(\\\" - \\\\\\\"$l_parameter_name\\\\\\\" is not set in an included file\\\" \\\\\n         \\\"    ** Note: \\\\\\\"$l_parameter_name\\\\\\\" May be set in a file that's ignored by load procedure **\\\")\n      fi\n   }\n   l_systemdsysctl=\\\"$(readlink -f /lib/systemd/systemd-sysctl)\\\"\n   while IFS=\\\"=\\\" read -r l_parameter_name l_parameter_value; do # Assess and check parameters\n      l_parameter_name=\\\"${l_parameter_name// /}\\\"; l_parameter_value=\\\"${l_parameter_value// /}\\\"\n      l_value_out=\\\"${l_parameter_value//-/ through }\\\"; l_value_out=\\\"${l_value_out//|/ or }\\\"\n      l_value_out=\\\"$(tr -d '(){}' <<< \\\"$l_value_out\\\")\\\"\n      f_kernel_parameter_chk\n   done < <(printf '%s\\\\n' \\\"${a_parlist[@]}\\\")\n   if [ \\\"${#a_output2[@]}\\\" -le 0 ]; then\n      printf '%s\\\\n' \\\"\\\" \\\"- Audit Result:\\\" \\\"  ** PASS **\\\" \\\"${a_output[@]}\\\" \\\"\\\"\n   else\n      printf '%s\\\\n' \\\"\\\" \\\"- Audit Result:\\\" \\\"  ** FAIL **\\\" \\\" - Reason(s) for audit failure:\\\" \\\"${a_output2[@]}\\\"\n      [ \\\"${#a_output[@]}\\\" -gt 0 ] && printf '%s\\\\n' \\\"\\\" \\\"- Correctly set:\\\" \\\"${a_output[@]}\\\" \\\"\\\"\n   fi\n}",
  "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
}
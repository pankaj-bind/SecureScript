{
  "check_type": "CONDITIONAL",
  "condition": {
    "auto_status": "FAILED",
    "type": "AND",
    "rules": [
      {
        "type": "CMD_EXEC",
        "description": "rules path",
        "cmd": "#!/bin/bash\n\n{\n  UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs)\n  [ -n \\\"${UID_MIN}\\\" ] && awk \\\"/^ *-a *always,exit/ \\\\\n  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\\\n  &&/ -F *auid>=${UID_MIN}/ \\\\\n  &&/ -F *perm=x/ \\\\\n  &&/ -F *path=\\\\/usr\\\\/bin\\\\/kmod/ \\\\\n  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\\\" /etc/audit/rules.d/*.rules \\\\\n  || printf \\\"ERROR: Variable 'UID_MIN' is unset.\\\\n\\\"\n}| /bin/awk '{print} END {if (NR != 0) print \\\"pass\\\" ; else print \\\"fail\\\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
      },
      {
        "type": "CMD_EXEC",
        "description": "rules arch",
        "cmd": "#!/bin/bash\n\n{\n  awk '/^ *-a *always,exit/ \\\\\n  &&/ -F *arch=b(32|64)/ \\\\\n  &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\\\\n  &&/ -S/ \\\\\n  &&(/init_module/ \\\\\n  ||/finit_module/ \\\\\n  ||/delete_module/ \\\\\n  ||/create_module/ \\\\\n  ||/query_module/) \\\\\n  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n}| /bin/awk '{print} END {if (NR != 0) print \\\"pass\\\" ; else print \\\"fail\\\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
      },
      {
        "type": "CMD_EXEC",
        "description": "auditctl path",
        "cmd": "#!/bin/bash\n\n{\n  UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs)\n  [ -n \\\"${UID_MIN}\\\" ] && auditctl -l | awk \\\"/^ *-a *always,exit/ \\\\\n  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\\\n  &&/ -F *auid>=${UID_MIN}/ \\\\\n  &&/ -F *perm=x/ \\\\\n  &&/ -F *path=\\\\/usr\\\\/bin\\\\/kmod/ \\\\\n  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\\\" \\\\\n  || printf \\\"ERROR: Variable 'UID_MIN' is unset.\\\\n\\\"\n}| /bin/awk '{print} END {if (NR != 0) print \\\"pass\\\" ; else print \\\"fail\\\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
      },
      {
        "type": "CMD_EXEC",
        "description": "auditctl arch",
        "cmd": "#!/bin/bash\n\n{\n  auditctl -l | awk '/^ *-a *always,exit/ \\\\\n  &&/ -F *arch=b(32|64)/ \\\\\n  &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\\\\n  &&/ -S/ \\\\\n  &&(/init_module/ \\\\\n  ||/finit_module/ \\\\\n  ||/delete_module/ \\\\\n  ||/create_module/ \\\\\n  ||/query_module/) \\\\\n  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n}| /bin/awk '{print} END {if (NR != 0) print \\\"pass\\\" ; else print \\\"fail\\\"}'",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
      },
      {
        "type": "CMD_EXEC",
        "description": "symlinks",
        "cmd": "#!/bin/bash\n\n{\n  fail=0\n  a_files=(\\\"/usr/sbin/lsmod\\\" \\\"/usr/sbin/rmmod\\\" \\\"/usr/sbin/insmod\\\" \\\"/usr/sbin/modinfo\\\" \\\"/usr/sbin/modprobe\\\" \\\"/usr/sbin/depmod\\\")\n  for l_file in \\\"${a_files[@]}\\\"; do\n    if [ \\\"$(readlink -f \\\"$l_file\\\")\\\" = \\\"$(readlink -f /bin/kmod)\\\" ]; then\n      printf \\\"OK: \\\\\\\"$l_file\\\\\\\"\\\\n\\\"\n    else\n      printf \\\"Issue with symlink for file: \\\\\\\"$l_file\\\\\\\"\\\\n\\\"\n      fail=1\n    fi\n  done\n  if [ $fail -eq 0 ]; then\n    printf \\\"pass\\\"\n  else\n    printf \\\"fail\\\"\n  fi\n}",
        "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
      }
    ]
  },
  "then": {
    "report": {
      "description": "6.2.3.19 Ensure kernel module loading unloading and modification is collected",
      "info": "Monitor the loading and unloading of kernel modules. All the loading / listing / dependency checking of modules is done by kmod via symbolic links.\n\nThe following system calls control loading and unloading of modules:\n\n - init_module - load a module\n - finit_module - load a module (used when the overhead of using cryptographically signed modules to determine the authenticity of a module can be avoided)\n - delete_module - delete a module\n - create_module - create a loadable module entry\n - query_module - query the kernel for various bits pertaining to modules\n\nAny execution of the loading and unloading module programs and system calls will trigger an audit record with an identifier of modules\n\nMonitoring the use of all the various ways to manipulate kernel modules could provide system administrators with evidence that an unauthorized change was made to a kernel module, possibly compromising the security of the system.",
      "solution": "\"Create audit rules\n\nEdit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor kernel module modification.",
      "Example": "#!/usr/bin/env bash\n\n{\n  UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n  [ -n \\\"${UID_MIN}\\\" ] && printf \\\"\n  -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules\n  -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules\n  \\\" >> /etc/audit/rules.d/50-kernel_modules.rules || printf \\\"ERROR: Variable 'UID_MIN' is unset.\\n\\\"\n}\n\nLoad audit rules\n\nMerge and load the rules into active configuration:\n\n# augenrules --load\n\nCheck if reboot is required.\n\n# if [[ $(auditctl -s | grep \\\"enabled\\\") =~ \\\"2\\\" ]]; then printf \\\"Reboot required to load rules\\n\\\"; fi\"",
      "reference": "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4",
      "see_also": "https://workbench.cisecurity.org/benchmarks/18959",
      "show_output": true,
      "type": "PASSED"
    }
  }
}
{
  "type": "CMD_EXEC",
  "description": "1.1.1.4 Ensure hfsplus kernel module is not available",
  "info": "The hfsplus filesystem type is a hierarchical filesystem designed to replace hfs that allows you to mount Mac OS filesystems.\n\nRemoving support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.",
  "solution": "Run the following script to unload and disable the hfsplus module:\n\n- IF - the hfsplus kernel module is available in ANY installed kernel:\n\n - Create a file ending inconf with install hfsplus /bin/false in the /etc/modprobe.d/ directory\n - Create a file ending inconf with blacklist hfsplus in the /etc/modprobe.d/ directory\n - Run modprobe -r hfsplus 2>/dev/null; rmmod hfsplus 2>/dev/null to remove hfsplus from the kernel\n\n- IF - the hfsplus kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n#!/usr/bin/env bash\n\n{\n   a_output2=() a_output3=() l_dl=\\\"\\\" l_mod_name=\\\"hfsplus\\\" l_mod_type=\\\"fs\\\"\n   l_mod_path=\\\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\\\"\n   f_module_fix()\n   {\n      l_dl=\\\"y\\\" a_showconfig=()\n      while IFS= read -r l_showconfig; do\n         a_showconfig+=(\\\"$l_showconfig\\\")\n      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\\\"${l_mod_chk_name//-/_}\\\"'\\b')\n      if lsmod | grep \\\"$l_mod_chk_name\\\" &> /dev/null; then\n         a_output2+=(\\\" - unloading kernel module: \\\\\\\"$l_mod_name\\\\\\\"\\\")\n         modprobe -r \\\"$l_mod_chk_name\\\" 2>/dev/null; rmmod \\\"$l_mod_name\\\" 2>/dev/null\n      fi\n      if ! grep -Pq -- '\\binstall\\h+'\\\"${l_mod_chk_name//-/_}\\\"'\\h+(\\/usr)?\\/bin\\/(true|false)\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output2+=(\\\" - setting kernel module: \\\\\\\"$l_mod_name\\\\\\\" to \\\\\\\"$(readlink -f /bin/false)\\\\\\\"\\\")\n         printf '%s\\n' \\\"install $l_mod_chk_name $(readlink -f /bin/false)\\\" >> /etc/modprobe.d/\\\"$l_mod_name\\\".conf\n      fi\n      if ! grep -Pq -- '\\bblacklist\\h+'\\\"${l_mod_chk_name//-/_}\\\"'\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output2+=(\\\" - denylisting kernel module: \\\\\\\"$l_mod_name\\\\\\\"\\\")\n         printf '%s\\n' \\\"blacklist $l_mod_chk_name\\\" >> /etc/modprobe.d/\\\"$l_mod_name\\\".conf\n      fi\n   }\n   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n      if [ -d \\\"$l_mod_base_directory/${l_mod_name/-/\\/}\\\" ] && [ -n \\\"$(ls -A \\\"$l_mod_base_directory/${l_mod_name/-/\\/}\\\")\\\" ]; then\n         a_output3+=(\\\" - \\\\\\\"$l_mod_base_directory\\\\\\\"\\\")\n         l_mod_chk_name=\\\"$l_mod_name\\\"\n         [[ \\\"$l_mod_name\\\" =~ overlay ]] && l_mod_chk_name=\\\"${l_mod_name::-2}\\\"\n         [ \\\"$l_dl\\\" != \\\"y\\\" ] && f_module_fix\n      else\n         printf '%s\\n' \\\" - kernel module: \\\\\\\"$l_mod_name\\\\\\\" doesn't exist in \\\\\\\"$l_mod_base_directory\\\\\\\"\\\"\n      fi\n   done\n   [ \\\"${#a_output3[@]}\\\" -gt 0 ] && printf '%s\\n' \\\"\\\" \\\" -- INFO --\\\" \\\" - module: \\\\\\\"$l_mod_name\\\\\\\" exists in:\\\" \\\"${a_output3[@]}\\\"\n   [ \\\"${#a_output2[@]}\\\" -gt 0 ] && printf '%s\\n' \\\"\\\" \\\"${a_output2[@]}\\\" || printf '%s\\n' \\\"\\\" \\\" - No changes needed\\\"\n   printf '%s\\n' \\\"\\\" \\\" - remediation of kernel module: \\\\\\\"$l_mod_name\\\\\\\" complete\\\" \\\"\\\"\n}",
  "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171r3|03.04.02,800-171r3|03.04.06,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO-27001-2022|A.8.9,ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
  "see_also": "https://workbench.cisecurity.org/benchmarks/18959",
  "cmd": "#!/bin/bash\n\n{\n   l_output3=\\\"\\\" l_dl=\\\"\\\" # clear variables\n   unset a_output; unset a_output2 # unset arrays\n   l_mod_name=\\\"hfsplus\\\" # set module name\n   l_mod_type=\\\"fs\\\" # set module type\n   l_mod_path=\\\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\\\"\n   f_module_chk()\n   {\n      l_dl=\\\"y\\\" # Set to ignore duplicate checks\n      a_showconfig=() # Create array with modprobe output\n      while IFS= read -r l_showconfig; do\n         a_showconfig+=(\\\"$l_showconfig\\\")\n      done < <(modprobe --showconfig | grep -P -- '\\\\b(install|blacklist)\\\\h+'\\\"${l_mod_name//-/_}\\\"'\\\\b')\n      if ! lsmod | grep \\\"$l_mod_name\\\" &> /dev/null; then # Check if the module is currently loaded\n         a_output+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is not loaded\\\")\n      else\n         a_output2+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is loaded\\\")\n      fi\n      if grep -Pq -- '\\\\binstall\\\\h+'\\\"${l_mod_name//-/_}\\\"'\\\\h+\\\\/bin\\\\/(true|false)\\\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is not loadable\\\")\n      else\n         a_output2+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is loadable\\\")\n      fi\n      if grep -Pq -- '\\\\bblacklist\\\\h+'\\\"${l_mod_name//-/_}\\\"'\\\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is deny listed\\\")\n      else\n         a_output2+=(\\\"  - kernel module: \\\\\\\"$l_mod_name\\\\\\\" is not deny listed\\\")\n      fi\n   }\n   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n      if [ -d \\\"$l_mod_base_directory/${l_mod_name/-/\\\\/}\\\" ] && [ -n \\\"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\\\/})\\\" ]; then\n         l_output3=\\\"$l_output3\\\\n  - \\\\\\\"$l_mod_base_directory\\\\\\\"\\\"\n         [[ \\\"$l_mod_name\\\" =~ overlay ]] && l_mod_name=\\\"${l_mod_name::-2}\\\"\n         [ \\\"$l_dl\\\" != \\\"y\\\" ] && f_module_chk\n      else\n         a_output+=(\\\" - kernel module: \\\\\\\"$l_mod_name\\\\\\\" doesn't exist in \\\\\\\"$l_mod_base_directory\\\\\\\"\\\")\n      fi\n   done\n   [ -n \\\"$l_output3\\\" ] && echo -e \\\"\\\\n\\\\n -- INFO --\\\\n - module: \\\\\\\"$l_mod_name\\\\\\\" exists in:$l_output3\\\"\n   if [ \\\"${#a_output2[@]}\\\" -le 0 ]; then\n      printf '%s\\\\n' \\\"\\\" \\\"- Audit Result:\\\" \\\"  ** PASS **\\\" \\\"${a_output[@]}\\\"\n   else\n      printf '%s\\\\n' \\\"\\\" \\\"- Audit Result:\\\" \\\"  ** FAIL **\\\" \\\" - Reason(s) for audit failure:\\\" \\\"${a_output2[@]}\\\"\n      [ \\\"${#a_output[@]}\\\" -gt 0 ] && printf '%s\\\\n' \\\"- Correctly set:\\\" \\\"${a_output[@]}\\\"\n   fi\n}",
  "expect": "(?i)^[\\\\s]*\\\\**[\\\\s]*pass:?[\\\\s]*\\\\**$"
}
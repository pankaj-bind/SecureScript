{
  "type": "CMD_EXEC",
  "description": "1.1.1.10 Ensure unused filesystems kernel modules are not available",
  "info": "\"Filesystem kernel modules are pieces of code that can be dynamically loaded into the Linux kernel to extend its filesystem capabilities, or so-called base kernel, of an operating system. Filesystem kernel modules are typically used to add support for new hardware (as device drivers), or for adding system calls.\n\nWhile loadable filesystem kernel modules are a convenient method of modifying the running kernel, this can be abused by attackers on a compromised system to prevent detection of their processes or files, allowing them to maintain control over the system. Many rootkits make use of loadable filesystem kernel modules in this way.\n\nRemoving support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it. The following filesystem kernel modules have known CVE's and should be made unavailable if no dependencies exist:\n\n - afs - CVE-2022-37402\n - ceph - CVE-2022-0670\n - cifs - CVE-2022-29869\n - exfat CVE-2022-29973\n - ext CVE-2022-1184\n - fat CVE-2022-22043\n - fscache CVE-2022-3630\n - fuse CVE-2023-0386\n - gfs2 CVE-2023-3212\n - nfs_common CVE-2023-6660\n - nfsd CVE-2022-43945\n - smbfs_common CVE-2022-2585",
  "NOTE": "Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance.\"",
  "solution": "\"- IF - the module is available in the running kernel:\n\n - Unload the filesystem kernel module from the kernel\n - Create a file ending inconf with install filesystem kernel modules /bin/false in the /etc/modprobe.d/ directory\n - Create a file ending inconf with deny list filesystem kernel modules in the /etc/modprobe.d/ directory",
  "WARNING": "unloading, disabling or denylisting filesystem modules that are in use on the system maybe FATAL. It is extremely important to thoroughly review the filesystems returned by the audit before following the remediation procedure.\n\nExample of unloading the gfs2 kernel module:\n\n# modprobe -r gfs2 2>/dev/null\n# rmmod gfs2 2>/dev/null\n\nExample of fully disabling the gfs2 kernel module:\n\n# printf '%s\\n' \\\"blacklist gfs2\\\" \\\"install gfs2 /bin/false\\\" >> /etc/modprobe.d/gfs2.conf",
  "Note": "- Disabling a kernel module by modifying the command above for each unused filesystem kernel module\n - The example gfs2 must be updated with the appropriate module name for the command or example script bellow to run correctly.\n\nBelow is an example Script that can be modified to use on various filesystem kernel modules manual remediation process:\n\nExample Script\n\n#!/usr/bin/env bash\n\n{\n   a_output2=(); a_output3=(); l_dl=\\\"\\\" # Initialize arrays and clear variables\n   l_mod_name=\\\"gfs2\\\" # set module name\n   l_mod_type=\\\"fs\\\" # set module type\n   l_mod_path=\\\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\\\"\n   f_module_fix()\n   {\n      l_dl=\\\"y\\\" # Set to ignore duplicate checks\n      a_showconfig=() # Create array with modprobe output\n      while IFS= read -r l_showconfig; do\n         a_showconfig+=(\\\"$l_showconfig\\\")\n      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\\\"${l_mod_name//-/_}\\\"'\\b')\n      if lsmod | grep \\\"$l_mod_name\\\" &> /dev/null; then # Check if the module is currently loaded\n         a_output2+=(\\\" - unloading kernel module: \\\\\\\"$l_mod_name\\\\\\\"\\\")\n         modprobe -r \\\"$l_mod_name\\\" 2>/dev/null; rmmod \\\"$l_mod_name\\\" 2>/dev/null\n      fi\n      if ! grep -Pq -- '\\binstall\\h+'\\\"${l_mod_name//-/_}\\\"'\\h+(\\/usr)?\\/bin\\/(true|false)\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output2+=(\\\" - setting kernel module: \\\\\\\"$l_mod_name\\\\\\\" to \\\\\\\"$(readlink -f /bin/false)\\\\\\\"\\\")\n         printf '%s\\n' \\\"install $l_mod_name $(readlink -f /bin/false)\\\" >> /etc/modprobe.d/\\\"$l_mod_name\\\".conf\n      fi\n      if ! grep -Pq -- '\\bblacklist\\h+'\\\"${l_mod_name//-/_}\\\"'\\b' <<< \\\"${a_showconfig[*]}\\\"; then\n         a_output2+=(\\\" - denylisting kernel module: \\\\\\\"$l_mod_name\\\\\\\"\\\")\n         printf '%s\\n' \\\"blacklist $l_mod_name\\\" >> /etc/modprobe.d/\\\"$l_mod_name\\\".conf\n      fi\n   }\n   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n      if [ -d \\\"$l_mod_base_directory/${l_mod_name/-/\\/}\\\" ] && [ -n \\\"$(ls -A \\\"$l_mod_base_directory/${l_mod_name/-/\\/}\\\")\\\" ]; then\n         a_output3+=(\\\" - \\\\\\\"$l_mod_base_directory\\\\\\\"\\\")\n         [[ \\\"$l_mod_name\\\" =~ overlay ]] && l_mod_name=\\\"${l_mod_name::-2}\\\"\n         [ \\\"$l_dl\\\" != \\\"y\\\" ] && f_module_fix\n      else\n         echo -e \\\" - kernel module: \\\\\\\"$l_mod_name\\\\\\\" doesn't exist in \\\\\\\"$l_mod_base_directory\\\\\\\"\\\"\n      fi\n   done\n   [ \\\"${#a_output3[@]}\\\" -gt 0 ] && printf '%s\\n' \\\"\\\" \\\" -- INFO --\\\" \\\" - module: \\\\\\\"$l_mod_name\\\\\\\" exists in:\\\" \\\"${a_output3[@]}\\\"\n   [ \\\"${#a_output2[@]}\\\" -gt 0 ] && printf '%s\\n' \\\"\\\" \\\"${a_output2[@]}\\\" || printf '%s\\n' \\\"\\\" \\\" - No changes needed\\\"\n   printf '%s\\n' \\\"\\\" \\\" - remediation of kernel module: \\\\\\\"$l_mod_name\\\\\\\" complete\\\" \\\"\\\"\n}",
  "Impact": "This list may be quite extensive and covering all edges cases is difficult. Therefore, it's crucial to carefully consider the implications and dependencies before making any changes to the filesystem kernel module configurations.\"",
  "reference": "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171r3|03.04.02,800-171r3|03.04.06,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ISO-27001-2022|A.8.9,ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|1M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3",
  "see_also": "https://workbench.cisecurity.org/benchmarks/18959",
  "cmd": "#!/bin/bash\n\n{\n   a_output=(); a_output2=(); a_modprope_config=(); a_excluded=(); a_available_modules=()\n   a_ignore=(\\\"xfs\\\" \\\"vfat\\\" \\\"ext2\\\" \\\"ext3\\\" \\\"ext4\\\")\n   a_cve_exists=(\\\"afs\\\" \\\"ceph\\\" \\\"cifs\\\" \\\"exfat\\\" \\\"ext\\\" \\\"fat\\\" \\\"fscache\\\" \\\"fuse\\\" \\\"gfs2\\\" \\\"nfs_common\\\" \\\"nfsd\\\" \\\"smbfs_common\\\")\n   f_module_chk()\n   {\n      l_out2=\\\"\\\"; grep -Pq -- \\\"\\\\b$l_mod_name\\\\b\\\" <<< \\\"${a_cve_exists[*]}\\\" && l_out2=\\\" <- CVE exists!\\\"\n      if ! grep -Pq -- '\\\\bblacklist\\\\h+'\\\"$l_mod_name\\\"'\\\\b' <<< \\\"${a_modprope_config[*]}\\\"; then\n         a_output2+=(\\\"  - Kernel module: \\\\\\\"$l_mod_name\\\\\\\" is not fully disabled $l_out2\\\")\n      elif ! grep -Pq -- '\\\\binstall\\\\h+'\\\"$l_mod_name\\\"'\\\\h+(\\\\/usr)?\\\\/bin\\\\/(false|true)\\\\b' <<< \\\"${a_modprope_config[*]}\\\"; then\n         a_output2+=(\\\"  - Kernel module: \\\\\\\"$l_mod_name\\\\\\\" is not fully disabled $l_out2\\\")\n      fi\n      if lsmod | grep \\\"$l_mod_name\\\" &> /dev/null; then # Check if the module is currently loaded\n         l_output2+=(\\\"  - Kernel module: \\\\\\\"$l_mod_name\\\\\\\" is loaded\\\" \\\"\\\")\n      fi\n   }\n   while IFS= read -r -d $'\\\\0' l_module_dir; do\n      a_available_modules+=(\\\"$(basename \\\"$l_module_dir\\\")\\\")\n   done < <(find \\\"$(readlink -f /lib/modules/\\\"$(uname -r)\\\"/kernel/fs)\\\" -mindepth 1 -maxdepth 1 -type d ! -empty -print0)\n   while IFS= read -r l_exclude; do\n      if grep -Pq -- \\\"\\\\b$l_exclude\\\\b\\\" <<< \\\"${a_cve_exists[*]}\\\"; then\n         a_output2+=(\\\"  - ** WARNING: kernel module: \\\\\\\"$l_exclude\\\\\\\" has a CVE and is currently mounted! **\\\")\n      elif\n         grep -Pq -- \\\"\\\\b$l_exclude\\\\b\\\" <<< \\\"${a_available_modules[*]}\\\"; then\n         a_output+=(\\\"  - Kernel module: \\\\\\\"$l_exclude\\\\\\\" is currently mounted - do NOT unload or disable\\\")\n      fi\n      ! grep -Pq -- \\\"\\\\b$l_exclude\\\\b\\\" <<< \\\"${a_ignore[*]}\\\" && a_ignore+=(\\\"$l_exclude\\\")\n   done < <(findmnt -knD | awk '{print $2}' | sort -u)\n   while IFS= read -r l_config; do\n      a_modprope_config+=(\\\"$l_config\\\")\n   done < <(modprobe --showconfig | grep -P '^\\\\h*(blacklist|install)')\n   for l_mod_name in \\\"${a_available_modules[@]}\\\"; do # Iterate over all filesystem modules\n      [[ \\\"$l_mod_name\\\" =~ overlay ]] && l_mod_name=\\\"${l_mod_name::-2}\\\"\n      if grep -Pq -- \\\"\\\\b$l_mod_name\\\\b\\\" <<< \\\"${a_ignore[*]}\\\"; then\n         a_excluded+=(\\\" - Kernel module: \\\\\\\"$l_mod_name\\\\\\\"\\\")\n      else\n         f_module_chk\n      fi\n   done\n   [ \\\"${#a_excluded[@]}\\\" -gt 0 ] && printf '%s\\\\n' \\\"\\\" \\\" -- INFO --\\\" \\\\\n   \\\"The following intentionally skipped\\\" \\\\\n    \\\"${a_excluded[@]}\\\"\n   if [ \\\"${#a_output2[@]}\\\" -le 0 ]; then\n      printf '%s\\\\n' \\\"\\\" \\\"  - No unused filesystem kernel modules are enabled\\\" \\\"${a_output[@]}\\\" \\\"\\\"\n   else\n      printf '%s\\\\n' \\\"\\\" \\\"-- Audit Result: --\\\" \\\"  ** REVIEW the following **\\\" \\\"${a_output2[@]}\\\"\n      [ \\\"${#a_output[@]}\\\" -gt 0 ] && printf '%s\\\\n' \\\"\\\" \\\"-- Correctly set: --\\\" \\\"${a_output[@]}\\\" \\\"\\\"\n   fi\n}",
  "expect": "^Manual Review Required$",
  "severity": "MEDIUM"
}
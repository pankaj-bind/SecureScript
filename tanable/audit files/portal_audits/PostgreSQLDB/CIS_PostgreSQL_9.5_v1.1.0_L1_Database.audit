#TRUSTED 282e31657ee0a9f46d9810386cd9baa295a5d81a24a3939fcf3e161e7e21b2d8ad0d622e4f94c263e2a8f40478a3ddd778dace010cdcd71a0d30696eacbb5c3ce03b15575e9afb368e72150304553747efb7addc65227f569ffd7956648565d570a00e6d3bcf5c591cb4b2af63b19ba4512a8b9266e948ac3a7f65f9ece8c0b211b82f686ca69f2fd041ddfbab8b1536603a7cf9631386727e98c9a12cf96442b243f32cffff96d4d9dd5b565a8dada0a328888c13a13bef1fa6d3623f6f38c5113649c37cb0885244d19ab367bd407bc8952adfc576651bca94beecc61c56df01b68b0d1cda2a946a2e0048cf212baaf9c9ecebc7996d3f193e92bf170343a7b6513186db4b7592bea125ecca8c42e593a9b9d0a5380724ee2594dc3c81ec88bac7a850a56fa8ae837799ee6efeda6399bfe72b1ea4857b184a9562cc2688524841ebb674d0377fd555462e01d4055672846b9db6268a91a696099f18799ab3ac0d75cc4212620ad98b9069530c1398bb101cf8a41f430e4901f66541256f7235c354a4e6a631bcb6d942c9487d7839770ecf24db27323ef0a786a94faec7c48f27a782a129679ffeb6532c1f56ec29b711776a992d78beee74efe3176f67938c642403efee9964d9d53ff22e17af50ead403e2bbdd5cd8bcd56ef021f205091fb648e92fda6e054d855b26678f8ed30b1b55ae391aefa57c0c4b3ecd1336a2
#TRUST-RSA-SHA256 01ce012e80209af44091ddcd86b05575c0f4b1cec44192801f2fd68d027f111115d5a5c27875993d8171feaf3a83ab1debb00a6b6d764e7b9c7e9055f9713aaa345e439b2784067abefc9a9984e030a7ea1511242860c38ca7e1012e9068f15eae8732051249dff79dade9ef2ae8f2786d956dc2492107621d36d530ddf5d43b11e32887ba736c1c5747f18cb9263c86049e2524a23ea4cbd6a7dfba5752500c2a4ede6fc1e5900ec34fa3dbbdc749631039b1a87f30947e4c28555913999edec69e3746a640b33d44e0b321e49b6f0ab5fc58fd68bd183c3c884a395e27e84ba13ee4caf37baa5f9afbdaafcf080f862e4eb2c8ddae5f10f6fa74c520c74fe75737c148dc12062dd8f2ef0ef63d7d6298db36e9cbb8daa1194450e3c0a715777cbd740d74756506feb8bc0fbccc5e2d51764e602e489c15d40944a52a7799df0dacf64fa805586c164697582b26be31a34f1f282545b846c6b1a49962f3fef4d41627cc1c0a9d883218c8f9dd14fb76a57746e34d0f10774a32841822d2b2383840478baeafa8c7c25aabca6a64dfdbc7cf81a2203c2ef902dc940fd4fd3cce40c67c2af80dc4b67df12a6e3d98dcbdba369fec7a7d1dfe02920fb0cd1d590b9ce7b0854c10fbc745f9cb3782f736b422839dba7162482ea18f08c55e54628c66c0bd15a41dfab5f197c85240a7f52be8d0d6adf0dacb222ba4e93f19045c34
#
# This script is Copyright (C) 2004-2024 and is owned by Tenable, Inc. or an Affiliate thereof.
#
# See the following licenses for details:
#
# http://static.tenable.com/prod_docs/Nessus_6_SLA_and_Subscription_Agreement.pdf
#
# @PROFESSIONALFEED@
# $Revision: 1.2 $
# $Date: 2024/06/17 $
#
# Description   : This .audit is designed against the CIS Benchmark for PostgreSQL 9.5
#
#<ui_metadata>
#<display_name>CIS PostgreSQL 9.5 DB v1.1.0</display_name>
#<spec>
#  <type>CIS</type>
#  <name>PostgreSQL 9.5</name>
#  <profile>L1 DB</profile>
#  <version>1.1.0</version>
#  <link>https://workbench.cisecurity.org/files/2234</link>
#</spec>
#<labels>cis,postgres,update_20230227</labels>
#<benchmark_refs>CCE,CIS_Recommendation,CSCv6,CSCv7,CSCv8,LEVEL</benchmark_refs>
#<variables>
#  <variable>
#    <name>LOG_DEST</name>
#    <default>stderr</default>
#    <description>3.1.2</description>
#    <info>3.1.2 Log Destination</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_DIR</name>
#    <default>pg_log</default>
#    <description>3.1.4</description>
#    <info>3.1.4 Log Dir</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_FILE_NAMES</name>
#    <default>postgresql-%a.log</default>
#    <description>3.1.5</description>
#    <info>3.1.5 Log File Names</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_FILE_PERMS</name>
#    <default>0600</default>
#    <description>3.1.6</description>
#    <info>3.1.6 Log File Perms</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_TRUNCATE</name>
#    <default>on</default>
#    <description>3.1.7</description>
#    <info>3.1.7 Log Truncate</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_ROT_AGE</name>
#    <default>1d</default>
#    <description>3.1.8</description>
#    <info>3.1.8 Log Rot Age</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_ROT_SIZE</name>
#    <default>0</default>
#    <description>3.1.9</description>
#    <info>3.1.9 Log Rot Size</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>SYSLOG_FACILITY</name>
#    <default>local0</default>
#    <description>3.1.10</description>
#    <info>3.1.10 Syslog Facility</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>SYSLOG_IDENT</name>
#    <default>postgres</default>
#    <description>3.1.11</description>
#    <info>3.1.11 Syslog Ident</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_MIN_DUR_STMT</name>
#    <default>-1</default>
#    <description>3.1.15</description>
#    <info>3.1.15 Log Min Duration statement</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_ERR_VERBOSITY</name>
#    <default>default</default>
#    <description>3.1.24</description>
#    <info>3.1.24 Log Err Verbosity</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_HOSTNAME</name>
#    <default>off</default>
#    <description>3.1.25</description>
#    <info>3.1.25 Log Hostname</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_LINE_PREFIX</name>
#    <default>%m</default>
#    <description>3.1.26</description>
#    <info>3.1.26 Log Line Prefix</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_STMT</name>
#    <default>none</default>
#    <description>3.1.28</description>
#    <info>3.1.28 Log Statement</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>LOG_TIMEZONE</name>
#    <default>US/Eastern</default>
#    <description>3.1.30</description>
#    <info>3.1.30 Log Timezone</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>SSL_KEY_FILE</name>
#    <default>server.cert</default>
#    <description>7.1 server key file</description>
#    <info>7.1 server key file</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>SSL_CERT_FILE</name>
#    <default>server.key</default>
#    <description>7.1 sserver cert file</description>
#    <info>7.1 server cert file</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>REPLICATION_USER</name>
#    <default>postgres</default>
#    <description>7.1 replication_user</description>
#    <info>7.1 replication_user</info>
#    <value_type>STRING</value_type>
#  </variable>
#</variables>
#</ui_metadata>

<check_type:"PostgreSQLDB">

<custom_item>
  type        : SQL_POLICY
  description : "3.1.2 Ensure the log destinations are set correctly"
  info        : "PostgreSQL supports several methods for logging server messages, including stderr, csvlog and syslog. On Windows, eventlog is also supported. One or more of these destinations should be set for server log output.
Rationale:
If log_destination is not set, then any log messages generated by the core PostgreSQL processes will be lost."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, setting the log destination to csvlog):
postgres=# alter system set log_destination = 'csvlog';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Note: If more than one log destination is to be used, set this parameter to a list of desired log destinations separated by commas (e.g. 'csvlog, stderr').
Default Value:
stderr"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6.2,CSCv7|6.2,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_destination"
  sql_types   : STRING
  sql_expect  : "@LOG_DEST@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.3 Ensure the logging collector is enabled"
  info        : "The logging collector is a background process that captures log messages sent to stderr and redirects them into log files. The logging_collector setting must be enabled in order for this process to run. It can only be set at server start.
Rationale:
The logging collector approach is often more useful than logging to syslog, since some types of messages might not appear in syslog output. One common example is dynamic-linker failure message; another may be error messages produced by scripts such as archive_command.
Note: This setting must be enabled when log_destination is either 'stderr' or 'csvlog' and for certain other logging parameters to take effect."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set logging_collector = 'on';
ALTER SYSTEM
Unfortunately, this setting can only be changed at server (re)start. As root, restart the PostgreSQL service for this change to take effect:
$ service postgresql-9.5 restart
Stopping postgresql-9.5 service:                           [  OK  ]
Starting postgresql-9.5 service:                           [  OK  ]
Default Value:
on"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6.2,CSCv7|6.2,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show logging_collector"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.4 Ensure the log file destination directory is set correctly"
  info        : "The log_directory setting specifies the destination directory for log files when log_destination is stderr or csvlog. It can be specified as relative to the cluster data directory ($PGDATA) or as an absolute path. log_directory should be set according to your organization's logging policy.
Rationale:
If log_directory is not set, it is interpreted as the absolute path '/' and PostgreSQL will attempt to write its logs there (and typically fail due to a lack of permissions to that directory). This parameter should be set to direct the logs into the appropriate directory location as defined by your organization's logging policy."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_directory='pg_log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_directory;
 log_directory
---------------
 logs
(1 row)
Note: The use of logs, above, is an example. This should be set to an appropriate path as defined by your organization's logging requirements.
Default Value:
pg_log which is relative to the cluster's data directory (e.g. /var/lib/pgsql/9.5/data/pg_log)"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6.2,CSCv7|6.2,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_directory"
  sql_types   : STRING
  sql_expect  : "@LOG_DIR@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.5 Ensure the filename pattern for log files is set correctly"
  info        : "The log_filename setting specifies the filename pattern for log files. The value for log_filename should match your organization's logging policy.
The value is treated as a strftime pattern, so %-escapes can be used to specify time-varying filenames. The supported %-escapes are similar to those listed in the Open Group's strftime specification. If you specify a filename without escapes, you should plan to use a log rotation utility to avoid eventually filling the partition that contains log_directory. If there are any time-zone-dependent %-escapes, the computation is done in the zone specified by log_timezone. Also, the system's strftime is not used directly, so platform-specific (nonstandard) extensions do not work.
If CSV-format output is enabled in log_destination, .csv will be appended to the log filename. (If log_filename ends in .log, the suffix is replaced instead.)
Rationale:
If log_filename is not set, then the value of log_directory is appended to an empty string and PostgreSQL will fail to start as it will try to write to a directory instead of a file."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_filename='postgresql-%Y%m%d.log';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_filename;
   log_filename
-------------------
 postgresql-%Y%m%d.log
(1 row)
Note: In this example, a new logfile will be created for each day (e.g. postgresql-20180901.log)
Default Value:
The default is postgresql-%a.log, which creates a new logfile for each day of the week (e.g. postgresql-Mon.log, postgresql-Tue.log)."
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6.2,CSCv7|6.2,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_filename"
  sql_types   : STRING
  sql_expect  : "@LOG_FILE_NAMES@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.6 Ensure the log file permissions are set correctly"
  info        : "The log_file_mode setting determines the file permissions for log files when logging_collector is enabled. The parameter value is expected to be a numeric mode specification in the form accepted by the chmod and umask system calls. (To use the customary octal format, the number must start with a 0 (zero).)
The permissions should be set to allow only the necessary access to authorized personnel. In most cases the best setting is 0600, so that only the server owner can read or write the log files. The other commonly useful setting is 0640, allowing members of the owner's group to read the files, although to make use of that, you will need to alter the log_directory setting to store the log files outside the cluster data directory.
Rationale:
Log files often contain sensitive data. Allowing unnecessary access to log files may inadvertently expose sensitive data to unauthorized personnel."
  solution    : "Execute the following SQL statement(s) to remediate this setting (with the example assuming a desired value of 0600):
postgres=# alter system set log_file_mode = '0600';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_file_mode;
 log_file_mode
---------------
 0600
(1 row)
Default Value:
0600"
  reference   : "800-171|3.1.1,800-53|AC-3,800-53r5|AC-3,CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv6|14.4,CSCv7|14.6,CSF|PR.AC-4,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,LEVEL|1S,NESA|T4.2.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM3,NIAv2|SS29,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|13.2,TBA-FIISB|31.1"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_file_mode"
  sql_types   : STRING
  sql_expect  : "@LOG_FILE_PERMS@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.7 Ensure 'log_truncate_on_rotation' is enabled"
  info        : "Enabling the log_truncate_on_rotation setting when logging_collector is enabled causes PostgreSQL to truncate (overwrite) existing log files with the same name during log rotation instead of appending to them. For example, using this setting in combination with a log_filename setting value like postgresql-%H.log would result in generating 24 hourly log files and then cyclically overwriting them:
postgresql-00.log
postgresql-01.log
[...]
postgresql-23.log
Note: Truncation will occur only when a new file is being opened due to time-based rotation, not during server startup or size-based rotation (see later in this benchmark for size-based rotation details).
Rationale:
If this setting is disabled, pre-existing log files will be appended to if log_filename is configured in such a way that static names are generated.
Enabling or disabling the truncation should only be decided when also considering the value of log_filename and log_rotation_age/log_rotation_size. Some examples to illustrate the interaction between these settings:
log_truncate_on_rotation = on
log_filename = 'postgresql-%Y%m%d.log'
log_rotation_age = '1d'
log_rotation_size = 0
log_truncate_on_rotation = on
log_filename = 'postgresql-%Y%m%d.log'
log_rotation_age = '1h'
log_rotation_size = 0
log_truncate_on_rotation = on
log_filename = 'postgresql-%Y%m%d.log'
log_rotation_age = '0'
log_rotation_size = '100M'"
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_truncate_on_rotation = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show log_truncate_on_rotation;
 log_truncate_on_rotation
--------------------------
 off
(1 row)
Default Value:
'on'"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6.3,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1S,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_truncate_on_rotation"
  sql_types   : STRING
  sql_expect  : "@LOG_TRUNCATE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.8 Ensure the maximum log file lifetime is set correctly"
  info        : "When logging_collector is enabled, the log_rotation_age parameter determines the maximum lifetime of an individual log file (depending on the value of log_filename). After that many minutes have elapsed, a new log file will be created via automatic log file rotation. Current best practices advise log rotation at least daily, but your organization's logging policy should dictate your rotation schedule.
Rationale:
Log rotation is a standard best practice for log management."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to one hour):
postgres=# alter system set log_rotation_age='1h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
1d (one day)"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6.3,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1S,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_rotation_age"
  sql_types   : STRING
  sql_expect  : "@LOG_ROT_AGE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.9 Ensure the maximum log file size is set correctly"
  info        : "The log_rotation_size setting determines the maximum size of an individual log file. Once the maximum size is reached, automatic log file rotation will occur.
Rationale:
If this is set to zero, size-triggered creation of new log files is disabled. This will prevent automatic log file rotation when files become too large, which could put log data at increased risk of loss (unless age-based rotation is configured)."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to 1GB):
postgres=# alter system set log_rotation_size = '1GB';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
0"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6.3,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1S,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_rotation_size"
  sql_types   : STRING
  sql_expect  : "@LOG_ROT_SIZE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.10 Ensure the correct syslog facility is selected"
  info        : "The syslog_facility setting specifies the syslog 'facility' to be used when logging to syslog is enabled. You can choose from any of the 'local' facilities:
 LOCAL0
 LOCAL1
 LOCAL2
 LOCAL3
 LOCAL4
 LOCAL5
 LOCAL6
 LOCAL7
Your organization's logging policy should dictate which facility to use based on the syslog daemon in use.
Rationale:
If not set to the appropriate facility, the PostgreSQL log messages may be intermingled with other applications' log messages, incorrectly routed, or potentially dropped (depending on your syslog configuration)."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, setting it to the LOCAL1 facility):
postgres=# alter system set syslog_facility = 'LOCAL1';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
LOCAL0"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6,CSCv7|6.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show syslog_facility"
  sql_types   : STRING
  sql_expect  : "@SYSLOG_FACILITY@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.11 Ensure the program name for PostgreSQL syslog messages is correct"
  info        : "The syslog_ident setting specifies the program name used to identify PostgreSQL messages in syslog logs. An example of a possible program name is 'postgres'.
Rationale:
If this is not set correctly, it may be difficult or impossible to distinguish PostgreSQL messages from other messages in syslog logs."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, assuming a program name of 'pg95'):
postgres=# alter system set syslog_ident = 'pg95';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
postgres=# show syslog_ident;
 syslog_ident
--------------
 pg95
(1 row)```
Default Value:
postgres"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show syslog_ident"
  sql_types   : STRING
  sql_expect  : "@SYSLOG_IDENT@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.12 Ensure the correct messages are sent to the database client"
  info        : "The client_min_messages setting specifies the message levels that are sent to the database client (not the logs). Each level includes all the levels that follow it. The later the level, the fewer messages are sent. notice is generally accepted as the best practice for this setting.
Valid values are:
 DEBUG5
 DEBUG4
 DEBUG3
 DEBUG2
 DEBUG1
 LOG
 NOTICE
 WARNING
 ERROR
 FATAL
 PANIC
Note: LOG has a different rank here than in log_min_messages.
Rationale:
If this is not set correctly, the database client may receive too many messages or too few messages."
  solution    : "Execute the following SQL statement(s) to remediate the setting (in this example, to notice):
postgres=# alter system set client_min_messages = 'notice';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
notice"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1NS,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show client_min_messages"
  sql_types   : STRING
  sql_expect  : "notice"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.13 Ensure the correct messages are written to the server log"
  info        : "The log_min_messages setting specifies the message levels that are written to the server log. Each level includes all the levels that follow it. The later the level, the fewer messages are sent.
Valid values are:
 DEBUG5
 DEBUG4
 DEBUG3
 DEBUG2
 DEBUG1
 INFO
 NOTICE
 WARNING
 ERROR
 LOG
 FATAL
 PANIC
WARNING is considered the best practice unless indicated otherwise by your organization's logging policy.
Rationale:
If this is not set to the correct value, too many messages or too few messages may be written to the server log."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to set it to warning):
postgres=# alter system set log_min_messages = 'warning';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
WARNING"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1NS,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_min_messages"
  sql_types   : STRING
  sql_expect  : "warning"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.14 Ensure the correct SQL statements generating errors are recorded"
  info        : "The log_min_error_statement setting causes all SQL statements generating errors at or above the specified severity level to be recorded in the server log. Each level includes all the levels that follow it. The later the level, the fewer messages are recorded. Valid values are:
 DEBUG5
 DEBUG4
 DEBUG3
 DEBUG2
 DEBUG1
 INFO
 NOTICE
 WARNING
 ERROR
 LOG
 FATAL
 PANIC
Note: To effectively turn off logging of failing statements, set this parameter to PANIC.
ERROR is considered the best practice setting. Changes should only be made in accordance with your organization's logging policy.
Rationale:
If this is not set to the correct value, too many erring SQL statements or too few erring SQL statements may be written to the server log."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting (in the example, to error):
postgres=# alter system set log_min_error_statement = 'error';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
ERROR"
  reference   : "800-53|AU-4,800-53r5|AU-4,CSCv6|6,CSCv7|6.4,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|1NS,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_min_error_statement"
  sql_types   : STRING
  sql_expect  : "error"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.15 Ensure 'log_min_duration_statement' is disabled"
  info        : "The log_min_duration_statement setting specifies the minimum execution time for a statement at which the statement will be logged. For example, if you set it to 250ms, then all SQL statements that run 250ms or longer will be logged. Setting it to -1 disables this feature, which is recommended. Setting it to 0 records all statements regardless of duration.
Rationale:
Logging of SQL statements may include sensitive information that should not be recorded in logs."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to -1):
postgres=# alter system set log_min_duration_statement = -1;
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
-1"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_min_duration_statement"
  sql_types   : STRING
  sql_expect  : "@LOG_MIN_DUR_STMT@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.16 Ensure 'debug_print_parse' is disabled"
  info        : "The debug_print_parse setting enables printing the resulting parse tree for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.
Rationale:
Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set debug_print_parse='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show debug_print_parse"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.17 Ensure 'debug_print_rewritten' is disabled"
  info        : "The debug_print_rewritten setting enables printing the query rewriter output for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.
Rationale:
Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings."
  solution    : "Execute the following SQL statement(s) to disable this setting:
postgres=# alter system set debug_print_rewritten = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show debug_print_rewritten"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.18 Ensure 'debug_print_plan' is disabled"
  info        : "The debug_print_plan setting enables printing the execution plan for each executed query. These messages are emitted at the LOG message level. Unless directed otherwise by your organization's logging policy, it is recommended this setting be disabled by setting it to off.
Rationale:
Enabling any of the DEBUG printing variables may cause the logging of sensitive information that would otherwise be omitted based on the configuration of the other logging settings."
  solution    : "Execute the following SQL statement(s) to disable this setting:
postgres=# alter system set debug_print_plan = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show debug_print_plan"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.19 Ensure 'debug_pretty_print' is enabled"
  info        : "Enabling debug_pretty_print indents the messages produced by debug_print_parse, debug_print_rewritten, or debug_print_plan making them significantly easier to read.
Rationale:
If this setting is disabled, the 'compact' format is used instead, significantly reducing readability of the DEBUG statement log messages."
  solution    : "Execute the following SQL statement(s) to enable this setting:
postgres=# alter system set debug_pretty_print = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Impact:
Be advised that the aforementioned DEBUG printing options are disabled, but if your organizational logging policy requires them to be on then this option comes into play.
Default Value:
on"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show debug_pretty_print"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.20 Ensure 'log_checkpoints' is enabled"
  info        : "Enabling the log_checkpoints setting causes checkpoints and restartpoints to be logged in the server log. Some statistics are included in the log messages, including the number of buffers written and the time spent writing them.
Rationale:
Enabling the logging of checkpoints is the easiest method of tracking both the frequency and duration of the checkpoint operations."
  solution    : "Execute the following SQL statement(s) to enable this setting:
postgres=# alter system set log_checkpoints = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_checkpoints"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.21 Ensure 'log_connections' is enabled"
  info        : "Enabling the log_connections setting causes each attempted connection to the server to be logged, as well as successful completion of client authentication. This parameter cannot be changed after session start.
Rationale:
PostgreSQL does not maintain an internal record of attempted connections to the database for later auditing. It is only by enabling the logging of these attempts that one can determine if unexpected attempts are being made."
  solution    : "Execute the following SQL statement(s) to enable this setting:
postgres=# alter system set log_connections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_connections"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.22 Ensure 'log_disconnections' is enabled"
  info        : "Enabling the log_disconnections setting logs the end of each session, including session duration. This parameter cannot be changed after session start.
Rationale:
PostgreSQL does not maintain the beginning or ending of a connection internally for later review. It is only by enabling the logging of these that one can examine connections for failed attempts, 'over long' duration, or other anomalies."
  solution    : "Execute the following SQL statement(s) to enable this setting:
postgres=# alter system set log_disconnections = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_disconnections"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.23 Ensure 'log_duration' is enabled"
  info        : "Enabling the log_duration setting causes the duration of each completed SQL statement to be logged. For clients using the extended query protocol, durations of the Parse, Bind, and Execute steps are logged independently.
Rationale:
By logging the duration of statements, it is easy to identify both non-performant queries as well as possible DoS attempts (excessively long running queries may be attempts at resource starvation)."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_duration = `on`;
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_duration"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.24 Ensure 'log_error_verbosity' is set correctly"
  info        : "The log_error_verbosity setting specifies the verbosity (amount of detail) of logged messages. Valid values are:
 TERSE
 DEFAULT
 VERBOSE
with each containing the fields of the level above it as well as additional fields.
TERSE excludes the logging of DETAIL, HINT, QUERY, and CONTEXT error information.
VERBOSE output includes the SQLSTATE error code and the source code file name, function name, and line number that generated the error.
The appropriate value should be set based on your organization's logging policy.
Rationale:
If this is not set to the correct value, too many details or too few details may be logged."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting (in this example, to verbose):
postgres=# alter system set log_error_verbosity = 'verbose';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
DEFAULT"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1NS,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_error_verbosity"
  sql_types   : STRING
  sql_expect  : "@LOG_ERR_VERBOSITY@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.25 Ensure 'log_hostname' is set correctly"
  info        : "Enabling the log_hostname setting causes the hostname of the connecting host to be logged in addition to the host's IP address for connection log messages. Disabling the setting causes only the connecting host's IP address to be logged, and not the hostname. Unless your organization's logging policy requires hostname logging, it is best to disable this setting so as not to incur the overhead of DNS resolution for each statement that is logged.
Rationale:
Depending on your hostname resolution setup, enabling this setting might impose a non-negligible performance penalty. Additionally, the IP addresses that are logged can be resolved to their DNS names when reviewing the logs (unless dynamic host names are being used as part of your DHCP setup)."
  solution    : "Execute the following SQL statement(s) to remediate this setting (in this example, to off):
postgres=# alter system set log_hostname='off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_hostname"
  sql_types   : STRING
  sql_expect  : "@LOG_HOSTNAME@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.26 Ensure 'log_line_prefix' is set correctly"
  info        : "The log_line_prefix setting specifies a printf-style string that is prefixed to each log line. If blank, no prefix is used. You should configure this as recommended by the pgBadger development team unless directed otherwise by your organization's logging policy. The default value is < %m >.
% characters begin 'escape sequences' that are replaced with status information as outlined below. Unrecognized escapes are ignored. Other characters are copied straight to the log line. Some escapes are only recognized by session processes and will be treated as empty by background processes such as the main server process. Status information may be aligned either left or right by specifying a numeric literal after the % and before the option. A negative value will cause the status information to be padded on the right with spaces to give it a minimum width, whereas a positive value will pad on the left. Padding can be useful to aid human readability in log files.
The default is < %m >, but any of the following escape sequences can be used:
Escape  Effect                                            Session only
%a      Application name                                  yes
%u      User name                                         yes
%d      Database name                                     yes
%r      Remote host name or IP address, and remote port   yes
%h      Remote host name or IP address                    yes
%p      Process ID                                        no
%t      Time stamp without milliseconds                   no
%m      Time stamp with milliseconds                      no
%i      Command tag: type of session's current command    yes
%e      SQLSTATE error code                               no
%c      Session ID: see below                             no
%l      Number of the log line for each session
        or process, starting at 1                         no
%s      Process start time stamp                          no
%v      Virtual transaction ID (backendID/localXID)       no
%x      Transaction ID (0 if none is assigned)            no
%q      Produces no output, but tells non-session
        processes to stop at this point in the string;
        ignored by session processes                      no
%%      Literal %
Rationale:
Properly setting log_line_prefix allows for adding additional information to each log entry (such as the user, or the database). Said information may then be of use in auditing or security reviews."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_line_prefix = '%t [%p]: [%l-1] db=%d,user=%u,app=%a,client=%h';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
< %m >"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1NS,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_line_prefix"
  sql_types   : STRING
  sql_expect  : "@LOG_LINE_PREFIX@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.27 Ensure 'log_lock_waits' is enabled"
  info        : "The log_lock_waits setting specifies whether a log message is produced when a session waits longer than deadlock_timeout to acquire a lock. The setting should be enabled (set to on) unless otherwise directed by your organization's logging policy.
Rationale:
If this setting is disabled, it may be harder to determine if lock waits are causing poor performance or if a specially-crafted SQL is attempting to starve resources through holding locks for excessive amounts of time."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_lock_waits = 'on';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_lock_waits"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.28 Ensure 'log_statement' is set correctly"
  info        : "The log_statement setting specifies the types of SQL statements that are logged. Valid values are:
 none (off)
 ddl
 mod
 all (all statements)
It is recommended this be set to ddl unless otherwise directed by your organization's logging policy.
ddl logs all data definition statements:
 CREATE
 ALTER
 DROP
mod logs all ddl statements, plus data-modifying statements:
 INSERT
 UPDATE
 DELETE
 TRUNCATE
 COPY FROM
(PREPARE, EXECUTE, and EXPLAIN ANALYZE statements are also logged if their contained command is of an appropriate type.)
For clients using extended query protocol, logging occurs when an Execute message is received, and values of the Bind parameters are included (with any embedded single-quote marks doubled).
Rationale:
Setting log_statement to align with your organization's security and logging policies facilitates later auditing and review of database activities."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_statement='ddl';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
none"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_statement"
  sql_types   : STRING
  sql_expect  : "@LOG_STMT@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.29 Ensure all temporary files are logged"
  info        : "Temporary files are created for sorts, hashes, and temporary query results when these operations exceed work_mem. A log entry is made for each temporary file when it is deleted. Setting log_temp_files to 0 causes all temporary file information to be logged, while positive values log only files whose size is greater than or equal to the specified number of kilobytes. A value of -1 disables temporary file information logging.
Unless directed otherwise by your organization's logging policy, you should set this to 0.
Rationale:
If all temporary files are not logged, it may be more difficult to identify potential performance issues that may be either poor application coding or deliberate resource starvation attempts."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_temp_files = 0;
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
-1"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_temp_files"
  sql_types   : STRING
  sql_expect  : "0"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.30 Ensure 'log_timezone' is set correctly"
  info        : "The log_timezone setting specifies the time zone to use in timestamps within log messages. This value is cluster-wide, so that all sessions will report timestamps consistently. Unless directed otherwise by your organization's logging policy, set this to either GMT or UTC.
Rationale:
Log entry timestamps should be configured for an appropriate time zone as defined by your organization's logging policy to ensure a lack of confusion around when a logged event occurred."
  solution    : "Execute the following SQL statement(s) to remediate this setting:
postgres=# alter system set log_timezone = 'GMT';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
GMT"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-12,800-53r5|AU-12,CSCv6|6,CSCv7|6.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-12,LEVEL|1S,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_timezone"
  sql_types   : STRING
  sql_expect  : "@LOG_TIMEZONE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.31 Ensure 'log_parser_stats' is disabled"
  info        : "Enabling the log_parser_stats setting causes parser performance statistics to be written to the server log. This is a crude profiling instrument, similar to the Unix getrusage() operating system facility. This module reports per-module statistics. The parser performance statistics logging is disabled (off) by default and should only be enabled if directed to do so by your organization's logging policy.
Rationale:
The logging of these additional statistics when not mandated by your organization's logging policy greatly reduces the signal-to-noise ratio of the PostgreSQL logs."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_parser_stats = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_parser_stats"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.32 Ensure 'log_planner_stats' is disabled"
  info        : "Enabling the log_planner_stats setting causes planner performance statistics to be written to the server log. This is a crude profiling instrument, similar to the Unix getrusage() operating system facility. This module reports per-module statistics. The planner performance statistics logging is disabled (off) by default and should only be enabled if directed to do so by your organization's logging policy.
Rationale:
The logging of these additional statistics when not mandated by your organization's logging policy greatly reduces the signal-to-noise ratio of the PostgreSQL logs."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_planner_stats = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_planner_stats"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.33 Ensure 'log_executor_stats' is disabled"
  info        : "Enabling the log_executor_stats setting causes executor performance statistics to be written to the server log. This is a crude profiling instrument, similar to the Unix getrusage() operating system facility. This module reports per-module statistics. The executor performance statistics logging is disabled (off) by default and should only be enabled if directed to do so by your organization's logging policy.
Rationale:
The logging of these additional statistics when not mandated by your organization's logging policy greatly reduces the signal-to-noise ratio of the PostgreSQL logs."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_executor_stats = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_executor_stats"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.1.34 Ensure 'log_statement_stats' is disabled"
  info        : "Enabling the log_statement_stats setting causes cumulative performance statistics to be written to the server log for each query. This is a crude profiling instrument, similar to the Unix getrusage() operating system facility. This reports total statement statistics. Cumulative performance statistics logging is disabled (off) by default and should only be enabled if directed to do so by your organization's logging policy.
Note: log_statement_stats cannot be enabled together with any of the per-module options.
Rationale:
The logging of these additional statistics when not mandated by your organization's logging policy greatly reduces the signal-to-noise ratio of the PostgreSQL logs."
  solution    : "Execute the following SQL statement(s) as superuser to remediate this setting:
postgres=# alter system set log_statement_stats = 'off';
ALTER SYSTEM
postgres=# select pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)
Default Value:
off"
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-6,800-53r5|AU-6,CN-L3|7.1.3.3(d),CSCv6|6,CSCv7|6,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.DP-4,CSF|PR.PT-1,CSF|RS.AN-1,CSF|RS.CO-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-6,LEVEL|1S,NESA|M5.2.5,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show log_statement_stats"
  sql_types   : STRING
  sql_expect  : "off"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled - audit.log"
  info        : "The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.
Rationale:
Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.
When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:
$ yum -y install pgaudit_95
Loaded plugins: fastestmirror
Setting up Install Process
Loading mirror speeds from cached hostfile
 * base: mirror.vtti.vt.edu
 * extras: mirror.cogentco.com
 * updates: bay.uchicago.edu
Resolving Dependencies
--> Running transaction check
---> Package pgaudit_95.x86_64 0:1.0.4-1.rhel6 will be installed
--> Finished Dependency Resolution
Dependencies Resolved
================================================================================
 Package            Arch           Version                 Repository      Size
================================================================================
Installing:
 pgaudit_95         x86_64         1.0.4-1.rhel6           pgdg95          18 k
Transaction Summary
================================================================================
Install       1 Package(s)
Total download size: 18 k
Installed size: 41 k
Downloading Packages:
pgaudit_95-1.0.4-1.rhel6.x86_64.rpm                      |  18 kB     00:00
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : pgaudit_95-1.0.4-1.rhel6.x86_64                              1/1
  Verifying  : pgaudit_95-1.0.4-1.rhel6.x86_64                              1/1
Installed:
  pgaudit_95.x86_64 0:1.0.4-1.rhel6
Complete!
pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:
 enable pgAudit as an extension in the shared_preload_libraries parameter
 indicate which classes of statements we want to log via the pgaudit.log parameter
and, finally, restart the PostgreSQL service:
$ vi ${PGDATA}/postgresql.conf
Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):
shared_preload_libraries = 'pgaudit'
OR
shared_preload_libraries = 'pgaudit,somethingelse'
Now, add a new pgaudit-specific entry:
pgaudit.log='ddl,write'
Restart the PostgreSQL server for changes to take affect:
$ whoami
root
$ service postgresql-9.5 restart
Stopping postgresql-9.5 service:                           [  OK  ]
Starting postgresql-9.5 service:                           [  OK  ]
Impact:
Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much."
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6,CSCv7|6.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show pgaudit.log"
  sql_types   : NULL
  sql_expect  : NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "3.2 Ensure the PostgreSQL Audit Extension (pgAudit) is enabled  - pgaudit installed"
  info        : "The PostgreSQL Audit Extension (pgAudit) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The goal of pgAudit is to provide PostgreSQL users with the capability to produce audit logs often required to comply with government, financial, or ISO certifications.
Rationale:
Basic statement logging can be provided by the standard logging facility with log_statement = all. This is acceptable for monitoring and other uses but does not provide the level of detail generally required for an audit. It is not enough to have a list of all the operations performed against the database, it must also be possible to find particular statements that are of interest to an auditor. The standard logging facility shows what the user requested, while pgAudit focuses on the details of what happened while the database was satisfying the request.
When logging SELECT and DML statements, pgAudit can be configured to log a separate entry for each relation referenced in a statement. No parsing is required to find all statements that touch a particular table. In fact, the goal is that the statement text is provided primarily for deep forensics and should not be required for an audit."
  solution    : "To install and enable pgAudit, simply install the appropriate rpm from the PGDG repo:
$ yum -y install pgaudit_95
Loaded plugins: fastestmirror
Setting up Install Process
Loading mirror speeds from cached hostfile
 * base: mirror.vtti.vt.edu
 * extras: mirror.cogentco.com
 * updates: bay.uchicago.edu
Resolving Dependencies
--> Running transaction check
---> Package pgaudit_95.x86_64 0:1.0.4-1.rhel6 will be installed
--> Finished Dependency Resolution
Dependencies Resolved
================================================================================
 Package            Arch           Version                 Repository      Size
================================================================================
Installing:
 pgaudit_95         x86_64         1.0.4-1.rhel6           pgdg95          18 k
Transaction Summary
================================================================================
Install       1 Package(s)
Total download size: 18 k
Installed size: 41 k
Downloading Packages:
pgaudit_95-1.0.4-1.rhel6.x86_64.rpm                      |  18 kB     00:00
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : pgaudit_95-1.0.4-1.rhel6.x86_64                              1/1
  Verifying  : pgaudit_95-1.0.4-1.rhel6.x86_64                              1/1
Installed:
  pgaudit_95.x86_64 0:1.0.4-1.rhel6
Complete!
pgAudit is now installed and ready to be configured. Next, we need to alter the postgresql.conf configuration file to:
 enable pgAudit as an extension in the shared_preload_libraries parameter
 indicate which classes of statements we want to log via the pgaudit.log parameter
and, finally, restart the PostgreSQL service:
$ vi ${PGDATA}/postgresql.conf
Find the shared_preload_libraries entry, and add 'pgaudit' to it (preserving any existing entries):
shared_preload_libraries = 'pgaudit'
OR
shared_preload_libraries = 'pgaudit,somethingelse'
Now, add a new pgaudit-specific entry:
pgaudit.log='ddl,write'
Restart the PostgreSQL server for changes to take affect:
$ whoami
root
$ service postgresql-9.5 restart
Stopping postgresql-9.5 service:                           [  OK  ]
Starting postgresql-9.5 service:                           [  OK  ]
Impact:
Depending on settings, it is possible for pgAudit to generate an enormous volume of logging. Be careful to determine exactly what needs to be audit logged in your environment to avoid logging too much."
  reference   : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv6|6,CSCv7|6.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-12,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show shared_preload_libraries"
  sql_types   : REGEX
  sql_expect  : "pgaudit"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "4.4 Ensure excessive function privileges are revoked"
  info        : "In certain situations, to provide required functionality, PostgreSQL needs to execute internal logic (stored procedures, functions, triggers, etc.) and/or external code modules with elevated privileges. However, if the privileges required for execution are at a higher level than the privileges assigned to organizational users invoking the functionality applications/programs, those users are indirectly provided with greater privileges than assigned by their organization. This is known as privilege elevation. Privilege elevation must be utilized only where necessary. Execute privileges for application functions should be restricted to authorized users only.
Rationale:
Ideally, all application source code should be vetted to validate interactions between the application and the logic in the database, but this is usually not possible or feasible with available resources even if the source code is available. The DBA should attempt to obtain assurances from the development organization that this issue has been addressed and should document what has been discovered. The DBA should also inspect all application logic stored in the database (in the form of functions, rules, and triggers) for excessive privileges."
  solution    : "Where possible, revoke SECURITY DEFINER on PostgreSQL functions. To change a SECURITY DEFINER function to SECURITY INVOKER, run the following SQL:
$ whoami
root
$ sudo su - postgres
$ psql -c 'ALTER FUNCTION [functionname] SECURITY INVOKER;'
If it is not possible to revoke SECURITY DEFINER, ensure the function can be executed by only the accounts that absolutely need such functionality:
REVOKE EXECUTE ON FUNCTION delete_customer(integer,boolean) FROM appreader;
REVOKE
Confirm that the appreader user may no longer execute the function:
SELECT proname, proacl FROM pg_proc WHERE proname = 'delete_customer';
     proname     |                         proacl
-----------------+--------------------------------------------------------
 delete_customer | {=X/postgres,postgres=X/postgres,appwriter=X/postgres}
(1 row)
Based on output above, appreader=X/postgres no longer exists in the proacl column results returned from query and confirms appreader is no longer granted execute privilege on the function."
  reference   : "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv6|5.1,CSCv7|4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1S,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "SELECT nspname, proname, proargtypes, prosecdef, rolname, proconfig FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid JOIN pg_authid a ON a.oid = p.proowner WHERE prosecdef OR NOT proconfig IS NULL;"
  sql_types   : NULL, NULL, NULL, NULL, NULL, NULL
  sql_expect  : NULL, NULL, NULL, NULL, NULL, NULL
</custom_item>

<report type:"WARNING">
  description : "4.5 Ensure excessive DML privileges are revoked"
  info        : "DML (insert, update, delete) operations at the table level should be restricted to only authorized users. PostgreSQL manages table level DML permissions via the GRANT statement.
Rationale:
Excessive DML grants can lead to unprivileged users changing or deleting information without proper authorization.
NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
  solution    : "If a given database user has been granted excessive DML privileges for a given database table, those privileges should be revoked immediately using the revoke SQL command.
Continuing with the example above, remove unauthorized grants for appreader user using the revoke statement and verify the Boolean values are now false.
postgres=# REVOKE INSERT, UPDATE, DELETE ON TABLE customer FROM appreader;
REVOKE
postgres=# select t.tablename, u.usename,
       has_table_privilege(u.usename, t.tablename, 'select') as select,
       has_table_privilege(u.usename, t.tablename, 'insert') as insert,
       has_table_privilege(u.usename, t.tablename, 'update') as update,
       has_table_privilege(u.usename, t.tablename, 'delete') as delete
from   pg_tables t, pg_user u
where  t.tablename = 'customer'
and    u.usename in ('appwriter','appreader');
tablename |  usename  | select | insert | update | delete
----------+-----------+--------+--------+--------+--------
customer  | appwriter | t      | t      | t      | t
customer  | appreader | t      | f      | f      | f
(2 rows)
With the publication of CVE-2018-1058, it is also recommended that all privileges be revoked from the public schema for all users on all databases:
postgres=# REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE
Default Value:
The table owner/creator has full privileges; all other users must be explicitly granted access."
  reference   : "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv6|5.1,CSCv7|4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1S,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
</report>

<report type:"WARNING">
  description : "4.6 Ensure Row Level Security (RLS) is configured correctly"
  info        : "In addition to the SQL-standard privilege system available through GRANT, tables can have row security policies that restrict, on a per-user basis, which individual rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as Row Level Security (RLS).
By default, tables do not have any policies, so if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating. Row security policies can be specific to commands, to roles, or to both. A policy can be specified to apply to ALL commands, or to any combination of SELECT, INSERT, UPDATE, or DELETE. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply.
If you use RLS and apply restrictive policies to certain users, it is important that the Bypass RLS privilege not be granted to any unauthorized users. This privilege overrides RLS-enabled tables and associated policies. Generally, only superusers and elevated users should possess this privilege.
Rationale:
If RLS policies and privileges are not configured correctly, users could perform actions on tables that they are not authorized to perform, such as inserting, updating, or deleting rows.
NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
  solution    : "Again, we are using the example from the PostgreSQL documentation using the example passwd table. We will create three database roles to illustrate the workings of RLS:
postgres=# CREATE ROLE admin;
CREATE ROLE
postgres=# CREATE ROLE bob;
CREATE ROLE
postgres=# CREATE ROLE alice;
CREATE ROLE
Now, we will insert known data into the passwd table:
postgres=# INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT 0 1
postgres=# INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');
INSERT 0 1
And we will enable RLS on the table:
postgres=# ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;
ALTER TABLE
Now that RLS is enabled, we need to define one or more policies. Create the administrator policy and allow it access to all rows:
postgres=# CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
CREATE POLICY
Create a policy for normal users to view all rows:
postgres=# CREATE POLICY all_view ON passwd FOR SELECT USING (true);
CREATE POLICY
Create a policy for normal users that allows them to update only their own rows and to limit what values can be set for their login shell:
postgres=# CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );
CREATE POLICY
Grant all the normal rights on the table to the admin user:
postgres=# GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
GRANT
Grant only select access on non-sensitive columns to everyone:
postgres=# GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
GRANT
Grant update to only the sensitive columns:
postgres=# GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
GRANT
Ensure that no one has been granted Bypass RLS inadvertantly, by running the psql display command \du+. If unauthorized users do have Bypass RLS granted then resolve this using the ALTER ROLE<user>NOBYPASSRLS; command.
You can now verify that 'admin', 'bob', and 'alice' are properly restricted by querying the passwd table as each of these roles."
  reference   : "800-171|3.1.1,800-53|AC-3,800-53r5|AC-3,CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv6|14.4,CSCv7|14.6,CSF|PR.AC-4,CSF|PR.PT-3,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,LEVEL|1NS,NESA|T4.2.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM3,NIAv2|SS29,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|13.2,TBA-FIISB|31.1"
  see_also    : "https://workbench.cisecurity.org/files/2234"
</report>

<custom_item>
  type        : SQL_POLICY
  description : "4.7 Ensure the set_user extension is installed"
  info        : "PostgreSQL access to the superuser database role must be controlled and audited to prevent unauthorized access.
Rationale:
Even when reducing and limiting the access to the superuser role as described earlier in this benchmark, it is still difficult to determine who accessed the superuser role and what actions were taken using that role. As such, it is ideal to prevent anyone from logging in as the superuser and forcing them to escalate their role. This model is used at the OS level by the use of sudo and should be emulated in the database. The set_user extension allows for this setup."
  solution    : "At the time this benchmark is being written, set_user is not available as a package in the PGDG repository. As such, we will build it from source:
$ whoami
root
$ yum -y install postgresql95-devel
Loaded plugins: fastestmirror
Setting up Install Process
Loading mirror speeds from cached hostfile
 * base: mirror.cisp.com
 * extras: packages.oit.ncsu.edu
 * updates: mirror.cisp.com
Resolving Dependencies
--> Running transaction check
---> Package postgresql95-devel.x86_64 0:9.5.15-1PGDG.rhel6 will be installed
--> Finished Dependency Resolution
Dependencies Resolved
===========================================================================================================
 Package                        Arch               Version                        Repository          Size
===========================================================================================================
Installing:
 postgresql95-devel             x86_64             9.5.15-1PGDG.rhel6             pgdg95             1.7 M
Transaction Summary
===========================================================================================================
Install       1 Package(s)
Total download size: 1.7 M
Installed size: 7.9 M
Downloading Packages:
postgresql95-devel-9.5.15-1PGDG.rhel6.x86_64.rpm                                    | 1.7 MB     00:01
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
Warning: RPMDB altered outside of yum.
  Installing : postgresql95-devel-9.5.15-1PGDG.rhel6.x86_64                                            1/1
  Verifying  : postgresql95-devel-9.5.15-1PGDG.rhel6.x86_64                                            1/1
Installed:
  postgresql95-devel.x86_64 0:9.5.15-1PGDG.rhel6
Complete!
$
$ curl https://codeload.github.com/pgaudit/set_user/tar.gz/REL1_6_1 > set_user-1.6.1.tgz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 14916    0 14916    0     0  57215      0 --:--:-- --:--:-- --:--:--  184k
$
$ tar xf set_user-1.6.1tgz
$ cd set_user-REL1_6_1
$ export PATH=/usr/pgsql-9.5/bin:$PATH
[root@centos6 set_user-REL1_6_1]# make USE_PGXS=1
gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic -fPIC -I. -I./ -I/usr/pgsql-9.5/include/server -I/usr/pgsql-9.5/include/internal -D_GNU_SOURCE -I/usr/include/libxml2  -I/usr/include  -c -o set_user.o set_user.c
gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic -fPIC -L/usr/pgsql-9.5/lib -Wl,--as-needed  -L/usr/lib64 -Wl,--as-needed -Wl,-rpath,'/usr/pgsql-9.5/lib',--enable-new-dtags -lm  -shared -o set_user.so set_user.o
[root@centos6 set_user-REL1_6_1]# make USE_PGXS=1 install
/bin/mkdir -p '/usr/pgsql-9.5/share/extension'
/bin/mkdir -p '/usr/pgsql-9.5/share/extension'
/bin/mkdir -p '/usr/pgsql-9.5/lib'
/usr/bin/install -c -m 644 'set_user.h' /usr/pgsql-9.5/include
/usr/bin/install -c -m 644 .//set_user.control '/usr/pgsql-9.5/share/extension/'
/usr/bin/install -c -m 644 .//set_user--1.6.sql .//set_user--1.5--1.6.sql .//set_user--1.4--1.5.sql .//set_user--1.1--1.4.sql .//set_user--1.0--1.1.sql  '/usr/pgsql-9.5/share/extension/'
/usr/bin/install -c -m 755  set_user.so '/usr/pgsql-9.5/lib/'
Now that set_user is installed, we need to tell PostgreSQL to load its library:
$ whoami
root
$ vi ~postgres/9.5/data/postgresql.conf
shared_preload_libraries = 'set_user, other_libs'
$ service postgresql-9.5 restart
Stopping postgresql-9.5 service:                           [  OK  ]
Starting postgresql-9.5 service:                           [  OK  ]
And now, we can install the extension from with SQL:
postgres=# select * from pg_available_extensions where name = 'set_user';
   name   | default_version | installed_version |                  comment
----------+-----------------+-------------------+--------------------------------------------
 set_user | 1.6             |                   | similar to SET ROLE but with added logging
(1 row)
postgres=# create extension set_user;
CREATE EXTENSION
postgres=# select * from pg_available_extensions where name = 'set_user';
   name   | default_version | installed_version |                  comment
----------+-----------------+-------------------+--------------------------------------------
 set_user | 1.6             | 1.6               | similar to SET ROLE but with added logging
(1 row)
Now, we use GRANT to configure each DBA role to allow it to use the set_user functions. In the example below, we will configure my db user doug. (You would do this for each DBA's normal user role.)
postgres=# grant execute on function set_user(text) to doug;
GRANT
postgres=# grant execute on function set_user_u(text) to doug;
GRANT
Connect to PostgreSQL as yourself and verify it works as expected:
$ whoami
psql
$ psql -U doug -d postgres
postgres=> select set_user('postgres');
ERROR:  switching to superuser not allowed
HINT:  Use 'set_user_u' to escalate.
postgres=> select set_user_u('postgres');
 set_user_u
------------
 OK
(1 row)
postgres=# select current_user, session_user;
 current_user | session_user
--------------+--------------
 postgres     | doug
(1 row)
postgres=# select reset_user();
 reset_user
------------
 OK
(1 row)
postgres=> select current_user, session_user;
 current_user | session_user
--------------+--------------
 doug         | doug
(1 row)
Once all DBA's normal user accounts have been GRANTed permission, revoke the ability to login as the postgres (superuser) user:
postgres=# alter user postgres NOLOGIN;
ALTER ROLE
Which results in:
$ psql
psql: FATAL:  role 'postgres' is not permitted to log in
$ psql -U doug -d postgres
psql (9.5.15)
Make sure there are no other roles that are superuser's and can still login:
postgres=# SELECT rolname FROM pg_authid WHERE rolsuper and rolcanlogin;
 rolname
---------
(0 rows)
Verify there are no unprivileged roles that can login directly that are granted a superuser role even if it is multiple layers removed:
postgres=# DROP VIEW IF EXISTS roletree;
NOTICE:  view 'roletree' does not exist, skipping
DROP VIEW
postgres=# CREATE OR REPLACE VIEW roletree AS
postgres-# WITH RECURSIVE
postgres-# roltree AS (
postgres(#   SELECT u.rolname AS rolname,
postgres(#          u.oid AS roloid,
postgres(#          u.rolcanlogin,
postgres(#          u.rolsuper,
postgres(#          '{}'::name[] AS rolparents,
postgres(#          NULL::oid AS parent_roloid,
postgres(#          NULL::name AS parent_rolname
postgres(#   FROM pg_catalog.pg_authid u
postgres(#   LEFT JOIN pg_catalog.pg_auth_members m on u.oid = m.member
postgres(#   LEFT JOIN pg_catalog.pg_authid g on m.roleid = g.oid
postgres(#   WHERE g.oid IS NULL
postgres(#   UNION ALL
postgres(#   SELECT u.rolname AS rolname,
postgres(#          u.oid AS roloid,
postgres(#          u.rolcanlogin,
postgres(#          u.rolsuper,
postgres(#          t.rolparents || g.rolname AS rolparents,
postgres(#          g.oid AS parent_roloid,
postgres(#          g.rolname AS parent_rolname
postgres(#   FROM pg_catalog.pg_authid u
postgres(#   JOIN pg_catalog.pg_auth_members m on u.oid = m.member
postgres(#   JOIN pg_catalog.pg_authid g on m.roleid = g.oid
postgres(#   JOIN roltree t on t.roloid = g.oid
postgres(# )
postgres-# SELECT
postgres-#   r.rolname,
postgres-#   r.roloid,
postgres-#   r.rolcanlogin,
postgres-#   r.rolsuper,
postgres-#   r.rolparents
postgres-# FROM roltree r
postgres-# ORDER BY 1;
CREATE VIEW
postgres=# SELECT
postgres-#   ro.rolname,
postgres-#   ro.roloid,
postgres-#   ro.rolcanlogin,
postgres-#   ro.rolsuper,
postgres-#   ro.rolparents
postgres-# FROM roletree ro
postgres-# WHERE (ro.rolcanlogin AND ro.rolsuper)
postgres-# OR
postgres-# (
postgres(#     ro.rolcanlogin AND EXISTS
postgres(#     (
postgres(#       SELECT TRUE FROM roletree ri
postgres(#       WHERE ri.rolname = ANY (ro.rolparents)
postgres(#       AND ri.rolsuper
postgres(#     )
postgres(# );
 rolname | roloid | rolcanlogin | rolsuper | rolparents
---------+--------+-------------+----------+------------
(0 rows)
If any roles are identified by this query, use REVOKE to correct.
Impact:
Much like the venerable sudo does for the OS, set_user manages superuser access for PostgreSQL. Complete configuration of set_user is documented at the extension's website and should be reviewed to ensure the logging entries that your organization cares about are properly configured.
Note that some external tools assume they can connect as the postgres user by default and this is no longer true. You may find some tools need different options, reconfigured, or even abandoned to compensate for this."
  reference   : "800-171|3.1.1,800-53|AC-2(9),800-53r5|AC-2(9),CN-L3|8.1.4.2(c),CSCv6|5.1,CSCv6|5.8,CSCv7|4.3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1NS,NIAv2|AM16,PCI-DSSv3.2.1|8.5,PCI-DSSv4.0|8.2.2,PCI-DSSv4.0|8.2.3,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name from pg_available_extensions where name = 'set_user';"
  sql_types   : STRING
  sql_expect  : "set_user"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.2 Ensure 'backend' runtime parameters are configured correctly"
  info        : "In order to serve multiple clients efficiently, the PostgreSQL server launches a new 'backend' process for each client. The runtime parameters in this benchmark section are controlled by the backend process. The server's performance, in the form of slow queries causing a denial of service, and the RDBM's auditing abilities for determining root cause analysis can be compromised via these parameters.
Rationale:
A denial of service is possible by denying the use of indexes and by slowing down client access to an unreasonable level. Unsanctioned behavior can be introduced by introducing rogue libraries which can then be called in a database session. Logging can be altered and obfuscated inhibiting root cause analysis.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Once detected, the unauthorized/undesired change can be corrected by altering the configuration file and executing a server restart. In the case where the parameter has been on the command line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
1. Query the view pg_settings and compare with previous query outputs for any changes.
2. Review configuration files postgresql.conf and postgresql.auto.conf and compare them with previously archived file copies for any changes.
3. Examine the process output and look for parameters that were used at server startup:
ps aux | grep -E '[p]ostgres|[p]ostmaster'
Impact:
All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files."
  reference   : "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv6|18.7,CSCv7|18.11,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1S,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name, setting, unit from pg_settings where context like '%backend%' order by 1"
  sql_types   : NULL, NULL, NULL
  sql_expect  : NULL, NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.3 Ensure 'Postmaster' Runtime Parameters are Configured"
  info        : "PostgreSQL runtime parameters that are executed by the postmaster process.
Rationale:
The postmaster, or postgres, process is the supervisory process that assigns a backend process to an incoming client connection. The postmaster manages key runtime parameters that are either shared by all backend connections or needed by the postmaster process itself to run.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Once detected, the unauthorized/undesired change can be corrected by editing the altered configuration file and executing a server restart. In the case where the parameter has been on the command line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:
1. Query the view pg_settings and compare with previous query outputs for any changes
2. Review the configuration files postgresql.conf and postgresql.auto.conf and compare with previously archived file copies for any changes
3. Examine the process output and look for parameters that were used at server startup:
ps aux | grep -E '[p]ostgres|[p]ostmaster'
Impact:
All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis."
  reference   : "800-171|3.13.1,800-171|3.13.2,800-53|SA-8,800-53r5|SA-8,CSCv6|18,CSCv7|18,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1NS,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name, setting from pg_settings where context = 'postmaster' order by 1"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.4 Ensure 'SIGHUP' Runtime Parameters are Configured"
  info        : "PostgreSQL runtime parameters that are executed by the SIGHUP signal.
Rationale:
In order to define server behavior and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration files postgresql.conf and pg_hba.conf. Alternatively, those parameters found in postgresql.conf can also be changed using a server login session and executing the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Restore all values in the PostgreSQL configuration files and invoke the server to reload the configuration files.
Impact:
All changes made on this level will affect the overall behavior of the server. These changes can be effected by editing the PostgreSQL configuration files and by either executing a server SIGHUP from the command line or, as superuser postgres, executing the SQL command select pg_reload_conf(). A denial of service is possible by the over-allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis."
  reference   : "800-171|3.13.1,800-171|3.13.2,800-53|SA-8,800-53r5|SA-8,CSCv6|18,CSCv7|18,CSF|PR.IP-2,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|SA-8,ITSG-33|SA-8a.,LEVEL|1NS,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.6.5,NIAv2|SS3,NIAv2|VL2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name, setting from pg_settings where context = 'sighup' order by 1"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.5 Ensure 'Superuser' Runtime Parameters are Configured"
  info        : "PostgreSQL runtime parameters that can only be executed by the server's superuser, which is traditionally postgres.
Rationale:
In order to improve and optimize server performance, the server's superuser has the privilege of setting these parameters which are found in the configuration file postgresql.conf. Alternatively, they can be changed in a PostgreSQL login session via the SQL command ALTER SYSTEM which writes its changes in the configuration file postgresql.auto.conf.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "The exploit is made in the configuration files. These changes are effected upon server restart. Once detected, the unauthorized/undesired change can be made by editing the altered configuration file and executing a server restart. In the case where the parameter has been set on the command line invocation of pg_ctl the restart invocation is insufficient and an explicit stop and start must instead be made.
Detecting a change is possible by one of the following methods:
1. Query the view pg_settings and compare with previous query outputs for any changes.
2. Review the configuration files postgreql.conf and postgreql.auto.conf and compare with previously archived file copies for any changes
3. Examine the process output and look for parameters that were used at server startup:
ps aux | grep -E '[p]ostgres|[p]ostmaster'
Impact:
All changes made on this level will affect the overall behavior of the server. These changes can only be affected by a server restart after the parameters have been altered in the configuration files. A denial of service is possible by the over allocating of limited resources, such as RAM. Data can be corrupted by allowing damaged pages to load or by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Client messages can be altered in such a way as to interfere with the application logic. Logging can be altered and obfuscated inhibiting root cause analysis."
  reference   : "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv6|5.1,CSCv7|4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1NS,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name, setting from pg_settings where context = 'superuser' order by 1"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.6 Ensure 'User' Runtime Parameters are Configured"
  info        : "These PostgreSQL runtime parameters are managed at the user account (ROLE) level.
Rationale:
In order to improve performance and optimize features, a ROLE has the privilege of setting numerous parameters in a transaction, session, or as an entity attribute. Any ROLE can alter any of these parameters.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "In the matter of a user session, the login sessions must be validated that it is not executing undesired parameter changes. In the matter of attributes that have been changed in entities, they must be manually reverted to its default value(s).
Impact:
A denial of service is possible by the over-allocating of limited resources, such as RAM. Changing VACUUM parameters can force a server shutdown which is standard procedure preventing data corruption from transaction ID wraparound. Data can be corrupted by changing parameters to reinterpret values in an unexpected fashion, e.g. changing the time zone. Logging can be altered and obfuscated to inhibit root cause analysis."
  reference   : "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv6|5.1,CSCv7|4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1NS,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select name, setting from pg_settings where context = 'user' order by 1"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.8 Ensure SSL is enabled and configured correctly"
  info        : "SSL on a PostgreSQL server should be enabled (set to on) and configured to encrypt TCP traffic to and from the server.
Rationale:
If SSL is not enabled and configured correctly, this increases the risk of data being compromised in transit."
  solution    : "For this example, and ease of illustration, we will be using a self-signed certificate for the server generated via openssl, and the PostgreSQL defaults for file naming and location in the PostgreSQL $PGDATA directory.
$ whoami
postgres
$ # create new certificate and enter details at prompts
$ openssl req -new -text -out server.req
Generating a 2048 bit RSA private key
.....................+++
..................................................................+++
writing new private key to 'privkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:US
State or Province Name (full name) []:Ohio
Locality Name (eg, city) [Default City]:Columbus
Organization Name (eg, company) [Default Company Ltd]:Me Inc
Organizational Unit Name (eg, section) []:IT
Common Name (eg, your name or your server's hostname) []:my.me.inc
Email Address []:me@meinc.com
Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
$ # remove passphrase (required for automatic server start up)
$ openssl rsa -in privkey.pem -out server.key && rm privkey.pem
Enter pass phrase for privkey.pem:
writing RSA key
$ # modify certificate to self signed, generate .key and .crt files
$ openssl req -x509 -in server.req -text -key server.key -out server.crt
$ # copy .key and .crt files to appropriate location, here default $PGDATA
$ cp server.key server.crt $PGDATA
$ # restrict file mode for server.key
$ chmod og-rwx server.key
Edit the PostgreSQL configuration file postgresql.conf to ensure the following items are set. Again, we are using defaults. Note that altering these parameters will require restarting the cluster.
ssl = on
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'
password_encryption = on
Finally, restart PostgreSQL and confirm ssl using commands outlined in Audit Procedures:
postgres=# show ssl;
 ssl
-----
 on
(1 row)
Impact:
A self-signed certificate can be used for testing, but a certificate signed by a certificate authority (CA) (either one of the global CAs or a local one) should be used in production so that clients can verify the server's identity. If all the database clients are local to the organization, using a local CA is recommended.
To ultimately enable and enforce ssl authentication for the server, appropriate hostssl records must be added to the pg_hba.conf file. Be sure to reload PostgreSQL after any changes (restart not required).
Note: The hostssl record matches connection attempts made using TCP/IP, but only when the connection is made with SSL encryption. The host record matches attempts made using TCP/IP, but allows both SSL and non-SSL connections. The hostnossl record matches attempts made using TCP/IP, but only those without SSL. Care should be taken to enforce SSL as appropriate."
  reference   : "800-171|3.13.8,800-53|SC-8,800-53r5|SC-8,CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv6|14.2,CSCv7|14.4,CSF|PR.DS-2,CSF|PR.DS-5,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ITSG-33|SC-8,ITSG-33|SC-8a.,LEVEL|1S,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show ssl"
  sql_types   : STRING
  sql_expect  : "on"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "6.9 Ensure the pgcrypto extension is installed and configured correctly"
  info        : "PostgreSQL must implement cryptographic mechanisms to prevent unauthorized disclosure or modification of organization-defined information at rest (to include, at a minimum, PII and classified information) on organization-defined information system components.
Rationale:
PostgreSQL handling data that requires 'data at rest' protections must employ cryptographic mechanisms to prevent unauthorized disclosure and modification of the information at rest. These cryptographic mechanisms may be native to PostgreSQL or implemented via additional software or operating system/file system settings, as appropriate to the situation. Information at rest refers to the state of information when it is located on a secondary storage device (e.g. disk drive, tape drive) within an organizational information system.
Selection of a cryptographic mechanism is based on the need to protect the integrity of organizational information. The strength of the mechanism is commensurate with the security category and/or classification of the information. Organizations have the flexibility to either encrypt all information on storage devices (i.e. full disk encryption) or encrypt specific data structures (e.g. files, records, or fields). Organizations may also optionally choose to implement both to implement layered security.
The decision whether, and what, to encrypt rests with the data owner and is also influenced by the physical measures taken to secure the equipment and media on which the information resides. Organizations may choose to employ different mechanisms to achieve confidentiality and integrity protections, as appropriate. If the confidentiality and integrity of application data is not protected, the data will be open to compromise and unauthorized modification.
The PostgreSQL pgcrypto extension provides cryptographic functions for PostgreSQL and is intended to address the confidentiality and integrity of user and system information at rest in non-mobile devices."
  solution    : "The pgcrypto extension is included with the PostgreSQL 'contrib' package. Although included, it needs to be created in the database.
As the database administrator, run the following:
postgres=# CREATE EXTENSION pgcrypto;
CREATE EXTENSION
Verify pgcrypto is installed:
postgres=# SELECT * FROM pg_available_extensions WHERE name='pgcrypto';
   name   | default_version | installed_version |         comment
----------+-----------------+-------------------+-------------------------
 pgcrypto | 1.2             | 1.2               | cryptographic functions
(1 row)
Impact:
When considering or undertaking any form of encryption, it is critical to understand the state of the encrypted data at all stages of the data lifecycle. The use of pgcrypto ensures that the data at rest in the tables (and therefore on disk) is encrypted, but for the data to be accessed by any users or applications, said users/applications will, by necessity, have access to the encrypt and decrypt keys and the data in question will be encrypted/decrypted in memory and then transferred to/from the user/application in that form."
  reference   : "800-171|3.13.16,800-53|SC-28,800-53r5|SC-28,CN-L3|8.1.4.7(b),CN-L3|8.1.4.8(b),CSCv6|14.5,CSCv7|14.8,CSF|PR.DS-1,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(iv),HIPAA|164.312(e)(2)(ii),ITSG-33|SC-28,ITSG-33|SC-28a.,LEVEL|1NS,PCI-DSSv3.2.1|3.4,PCI-DSSv4.0|3.3.2,PCI-DSSv4.0|3.5.1,QCSC-v1|5.2.2,QCSC-v1|6.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "SELECT * FROM pg_available_extensions where name='pgcrypto'"
  sql_types   : STRING, REGEX, REGEX, REGEX
  sql_expect  : "pgcrypto", ".*", ".*", ".*"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "7.1 Ensure SSL Certificates are Configured For Replication - ssl key file"
  info        : "Creating and managing SSL certificates on the PRIMARY and STANDBY host(s).
Rationale:
Secure Sockets Layer (SSL) certificates enable encrypted communications between the PRIMARY and STANDBY hosts. SSL certificates can also be used to authenticate the identity of the host. The use of SSL certificates mitigates against sniffing of what would otherwise be sensitive information that's being transmitted in the clear."
  solution    : "Running a server with ssl=on is not possible until both a server certificate and key have been created, installed in the correct location, and are set with the correct permissions.
Although generating certificates signed by a Certificate Authority, CA is ideal, one can use self-signed certificates too.
Use the following example as a starting point to generate a self-signed certificate, the script is executed on the server in question. Note that the value of the SUBJ variable contains a carriage return to allow for formatting - the entire value should appear on a single line in the script.
set -e
state='Washington'
city='Seattle'
organization='My Company'
org_unit='My department'
cn=$(hostname -f)
email='you@company.com'
SUBJ='/C=US/ST=$state/L=$city/O=$organization/
      OU=$org_unit/CN=$cn/emailAddress=$email'
DAYS=3650
if [ -e '$PGDATA' ]; then
  KEY='$PGDATA/server.key'
  CRT='$PGDATA/server.crt'
else
  KEY='server.key'
  CRT='server.crt'
fi
openssl  req \
        -nodes \
        -x509 \
        -newkey rsa:2048 \
        -keyout $KEY \
        -out $CRT \
        -days $DAYS \
        -subj '$SUBJ'
chmod 600 $KEY
chmod 664 $CRT
echo 'DONE'"
  reference   : "800-171|3.13.8,800-53|SC-8,800-53r5|SC-8,CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv6|14.2,CSCv7|14.4,CSF|PR.DS-2,CSF|PR.DS-5,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ITSG-33|SC-8,ITSG-33|SC-8a.,LEVEL|1S,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show ssl_key_file"
  sql_types   : STRING
  sql_expect  : "@SSL_KEY_FILE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "7.1 Ensure SSL Certificates are Configured For Replication - ssl cert file"
  info        : "Creating and managing SSL certificates on the PRIMARY and STANDBY host(s).
Rationale:
Secure Sockets Layer (SSL) certificates enable encrypted communications between the PRIMARY and STANDBY hosts. SSL certificates can also be used to authenticate the identity of the host. The use of SSL certificates mitigates against sniffing of what would otherwise be sensitive information that's being transmitted in the clear."
  solution    : "Running a server with ssl=on is not possible until both a server certificate and key have been created, installed in the correct location, and are set with the correct permissions.
Although generating certificates signed by a Certificate Authority, CA is ideal, one can use self-signed certificates too.
Use the following example as a starting point to generate a self-signed certificate, the script is executed on the server in question. Note that the value of the SUBJ variable contains a carriage return to allow for formatting - the entire value should appear on a single line in the script.
set -e
state='Washington'
city='Seattle'
organization='My Company'
org_unit='My department'
cn=$(hostname -f)
email='you@company.com'
SUBJ='/C=US/ST=$state/L=$city/O=$organization/
      OU=$org_unit/CN=$cn/emailAddress=$email'
DAYS=3650
if [ -e '$PGDATA' ]; then
  KEY='$PGDATA/server.key'
  CRT='$PGDATA/server.crt'
else
  KEY='server.key'
  CRT='server.crt'
fi
openssl  req \
        -nodes \
        -x509 \
        -newkey rsa:2048 \
        -keyout $KEY \
        -out $CRT \
        -days $DAYS \
        -subj '$SUBJ'
chmod 600 $KEY
chmod 664 $CRT
echo 'DONE'"
  reference   : "800-171|3.13.8,800-53|SC-8,800-53r5|SC-8,CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv6|14.2,CSCv7|14.4,CSF|PR.DS-2,CSF|PR.DS-5,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ITSG-33|SC-8,ITSG-33|SC-8a.,LEVEL|1S,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "show ssl_cert_file"
  sql_types   : STRING
  sql_expect  : "@SSL_CERT_FILE@"
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "7.2 Ensure a replication-only user is created and used for streaming replication"
  info        : "Create a new user specifically for use by streaming replication instead of using the superuser account.
Rationale:
As it is not necessary to be a superuser to initiate a replication connection, it is proper to create an account specifically for replication. This allows further 'locking down' the uses of the superuser account and follows the general principle of using the least privileges necessary."
  solution    : "It will be necessary to create a new role for replication purposes:
postgres=# create user replication_user REPLICATION encrypted password 'XXX';
CREATE ROLE
postgres=# select rolname from pg_roles where rolreplication is true;
     rolname
------------------
 postgres
 replication_user
(2 rows)
When using pg_basebackup (or other replication tools) and when configuring recovery.conf on your standby server, you would use the replication_user (and its password).
Ensure you allow the new user via your pg_hba.conf file:
hostssl replication     replication_user       0.0.0.0/0               md5"
  reference   : "800-171|3.1.1,800-53|AC-2,800-53r5|AC-2,CN-L3|7.1.3.2(d),CSCv6|5.1,CSCv7|4,CSF|DE.CM-1,CSF|DE.CM-3,CSF|PR.AC-1,CSF|PR.AC-4,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.1,ITSG-33|AC-2,LEVEL|1NS,NIAv2|AM28,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "select rolname from pg_roles where rolreplication is true;"
  sql_types   : STRING
  sql_expect  : "@REPLICATION_USER@"
</custom_item>

<report type:"WARNING">
  description : "7.3 Ensure base backups are configured and functional"
  info        : "A 'base backup' is a copy of the PRIMARY host's data cluster ($PGDATA) and is used to create STANDBY hosts and for Point In Time Recovery (PITR) mechanisms. Base backups should be copied across networks in a secure manner using an encrypted transport mechanism. CLI examples includes scp, sftp and rsync -e ssh. Alternatively, the CLI cp can be used with an SSL-enabled implementation of an NFS mount point, or the PostgreSQL CLI pg_basebackup can be used. However, SSL encryption should be enabled on the server. Beware it is possible to use this utility without SSL encryption enabled.
NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
  solution    : "There are two methods of creating base backups; manual and simple. The 'manual' method explicitly first signals that a backup is about to start, then copies both the data cluster and WALs, using the appropriate tools/utilities, and finally signaling the PRIMARY host the copy process has finished and the backup has finished.
 postgres=# SELECT pg_start_backup('my base backup');
  pg_start_backup
 -----------------
  0/2000028
 (1 row)
   # copy both the data cluster and
   # all WALs generated during the process
   # ex:
   $ scp -rp $PGDATA user@dest:/path
 postgres=# SELECT pg_stop_backup();
  pg_start_backup
 -----------------
  0/2000030
 (1 row)
Executing base backups using pg_basebackup requires the following steps on the standby server:
$ whoami
postgres
$ pg_basebackup -h name_or_IP_of_master \
-p 5432 \
-U replication_user \
-D ~postgres/9.6/data \
-P -v -R -XS"
  reference   : "800-53|CP-10(1),800-53r5|CP-10(1),CSCv6|10.2,CSCv7|10.3,CSF|RC.RP-1,CSF|RS.RP-1,GDPR|32.1.b,GDPR|32.1.c,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(ii),ITSG-33|CP-10(1),LEVEL|1NS,NESA|T2.2.4,QCSC-v1|5.2.3,QCSC-v1|10.2.1,QCSC-v1|11.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
</report>

<report type:"WARNING">
  description : "7.5 Ensure streaming replication parameters are configured correctly"
  info        : "Streaming replication from a PRIMARY host transmits DDL, DML, passwords, and other potentially sensitive activities and data. These connections should be protected with Secure Sockets Layer (SSL).
Rationale:
Unencrypted transmissions could reveal sensitive information to unauthorized parties. Unauthenticated connections could enable man-in-the-middle attacks.
NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
  solution    : "Review prior sections in this benchmark regarding SSL certificates, replication user, and WAL archiving.
Confirm the file recovery.conf is present on the STANDBY host and contains lines similar to the following:
standby_mode=on
primary_conninfo = 'user=replication_user password=mypassword host=mySrcHost port=5432 sslmode=require sslcompression=1'"
  reference   : "800-171|3.13.8,800-53|SC-8,800-53r5|SC-8,CN-L3|8.1.2.2(a),CN-L3|8.1.2.2(b),CN-L3|8.1.4.7(a),CN-L3|8.1.4.8(a),CN-L3|8.2.4.5(c),CN-L3|8.2.4.5(d),CN-L3|8.5.2.2,CSCv6|14.2,CSCv7|14.4,CSF|PR.DS-2,CSF|PR.DS-5,GDPR|32.1.a,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(e)(1),HIPAA|164.312(e)(2)(i),ITSG-33|SC-8,ITSG-33|SC-8a.,LEVEL|1NS,NESA|T4.3.1,NESA|T4.3.2,NESA|T4.5.1,NESA|T4.5.2,NESA|T7.3.3,NESA|T7.4.1,NIAv2|IE8,NIAv2|IE9,NIAv2|IE12,NIAv2|NS29,NIAv2|SS24,PCI-DSSv3.2.1|2.3,PCI-DSSv3.2.1|4.1,PCI-DSSv4.0|2.2.7,PCI-DSSv4.0|4.2.1,QCSC-v1|5.2.2,QCSC-v1|6.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
</report>

<custom_item>
  type        : SQL_POLICY
  description : "8.1 Ensure PostgreSQL configuration files are outside the data cluster"
  info        : "PostgreSQL configuration files within the data cluster's directory tree can be changed by anyone logging into the data cluster as the superuser, i.e. postgres. As a matter of default policy, configuration files such as postgresql.conf, pg_hba.conf, and pg_ident, are placed in the data cluster's directory, $PGDATA. PostgreSQL can be configured to relocate these files to locations outside the data cluster which cannot then be accessed by an ordinary superuser login session.
Consideration should also be given to 'include directives'; these are cluster subdirectories where one can locate files containing additional configuration parameters. Include directives are meant to add more flexibility for unique installs or large network environments while maintaining order and consistent architectural design.
Rationale:
Leaving PostgreSQL configuration files within the data cluster's directory tree increases the changes that they will be inadvertently or intentionally altered.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Follow these steps to remediate the configuration file locations and permissions:
 Determine appropriate locations for relocatable configuration files based on your organization's security policies. If necessary, relocate and/or rename configuration files outside of the data cluster.
 Ensure their file permissions are restricted as much as possible, i.e. only superuser read access.
 Change the settings accordingly in the postgresql.conf configuration file.
 Restart the database cluster for the changes to take effect.
Default Value:
The defaults for PostgreSQL configuration files are listed below.
       name        |                 setting
-------------------+-----------------------------------------
 config_file       | /var/lib/pgsql/9.6/data/postgresql.conf
 external_pid_file |
 hba_file          | /var/lib/pgsql/9.6/data/pg_hba.conf
 ident_file        | /var/lib/pgsql/9.6/data/pg_ident.conf
 ssl_ca_file       |
 ssl_cert_file     | server.crt
 ssl_crl_file      |
 ssl_key_file      | server.key"
  reference   : "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv6|18.7,CSCv7|18.11,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1NS,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "SELECT name, setting FROM pg_settings WHERE name IN ('hba_file' ,'ident_file' ,'ssl_cert_file' ,'ssl_key_file' ,'ssl_ca_file' ,'ssl_crl_file' ,'krb_server_keyfile')"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "8.2 Ensure PostgreSQL subdirectory locations are outside the data cluster"
  info        : "The PostgreSQL cluster is organized to carry out specific tasks in subdirectories. For the purposes of performance, reliability, and security these subdirectories should be relocated outside the data cluster.
Rationale:
Some subdirectories contain information, such as logs, which can be of value to others such as developers. Other subdirectories can gain a performance benefit when placed on fast storage devices. Finally, relocating a subdirectory to a separate and distinct partition mitigates denial of service and involuntary server shutdown when excessive writes fill the data cluster's partition, e.g. pg_xlog and pg_log.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Perform the following steps to remediate the subdirectory locations and permissions:
 Determine appropriate data, log, and tablespace directories and locations based on your organization's security policies. If necessary, relocate all listed directories outside the data cluster.
 Ensure file permissions are restricted as much as possible, i.e. only superuser read access.
 When directories are relocated to other partitions, ensure that they are of sufficient size to mitigate against excessive space utilization.
 Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.
Default Value:
The default for data_directory is ConfigDir and the default for log_directory is pg_log (based on absolute path of data_directory). The defaults for tablespace settings are null, or not set, upon cluster creation."
  reference   : "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv6|18.7,CSCv7|18.11,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1NS,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "SELECT name, setting FROM pg_settings WHERE name IN ('data_directory' ,'log_directory' ,'default_tablespace' ,'temp_tablespaces' )"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : SQL_POLICY
  description : "8.4 Ensure miscellaneous configuration settings are correct"
  info        : "This recommendation covers non-regular, special files, and dynamic libraries.
PostgreSQL permits local logins via the UNIX DOMAIN SOCKET and, for the most part, anyone with a legitimate Unix login account can make the attempt. Limiting PostgreSQL login attempts can be made by relocating the UNIX DOMAIN SOCKET to a subdirectory with restricted permissions.
The creation and implementation of user-defined dynamic libraries is an extraordinary powerful capability. In the hands of an experienced DBA/programmer, it can significantly enhance the power and flexibility of the RDBMS. But new and unexpected behavior can also be assigned to the RDBMS, resulting in a very dangerous environment in what should otherwise be trusted.
NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Follow these steps to remediate the configuration:
 Determine permissions based on your organization's security policies.
 Relocate all files and ensure their permissions are restricted as much as possible, i.e. only superuser read access.
 Ensure all directories where these files are located have restricted permissions such that the superuser can read but not write.
 Lastly, change the settings accordingly in the postgresql.conf configuration file and restart the database cluster for changes to take effect.
Default Value:
The dynamic_library_path default is $libdir and unix_socket_directories default is /var/run/postgresql, /tmp. The default for external_pid_file and all library parameters are initially null, or not set, upon cluster creation."
  reference   : "800-171|3.4.1,800-53|CM-2,800-53r5|CM-2,CSCv6|18.7,CSCv7|18.11,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,LEVEL|1NS,NESA|T3.2.5,NESA|T7.5.1,NIAv2|SS16,QCSC-v1|5.2.1,QCSC-v1|5.2.2"
  see_also    : "https://workbench.cisecurity.org/files/2234"
  sql_request : "SELECT name, setting FROM pg_settings WHERE name IN ('external_pid_file' ,'unix_socket_directories' ,'shared_preload_libraries' ,'dynamic_library_path' ,'local_preload_libraries' ,'session_preload_libraries' )"
  sql_types   : NULL, NULL
  sql_expect  : NULL, NULL
  severity    : MEDIUM
</custom_item>

</check_type>

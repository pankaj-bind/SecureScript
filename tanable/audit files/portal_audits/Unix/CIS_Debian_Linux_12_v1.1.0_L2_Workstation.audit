#TRUSTED 8f93ffaceb0c08cb7d7891a8e0d910de54bac279569288dec050a6ffc2f349c2471b0406cb246ce03e1591b06e6961fd6f48353230cb41112023cdefe6cbad543f9293ffe0fdb0fd39f9d2836ed1be508db2dcf898f497065b9a13ec2aa1e9704d5ede06d592e25333757bf503f39cd19c3142caa54bd895a862541b12df4f55d64471975d70ba522a5a25da5fc961a28048156dad138d5107cf1ba47646df3b1879c31c624f29e43fd4dbebf5d2f98b30a7619c10b57ea2d7b3ce74964c8d24393e718f87201e18ac2d8a12a27c34d08bd6f867df17ce156aeefd5e3860a2356bdb8af15bc1f9b799b0d660dff08a506a8d45c30c39cb319a94b4f7330a7c0508f677d48952ea6fda514cf83f67eea45bcaefba4b93f7781e9a2d27cdf10d481795bd51d46b76bf1420848eb499dd82166fb598289c80c2e1b7190d726fdabb966ebac223e0090dfe59be9daf652fe71b36cc53a31d15a3fe8178e79a2fdbf560403003be3e7a201da09e434f5d628905b27028efdf7e77963e831b3c62056bd5e497453cc1f54a07d7a3d7d2d31fc87f72f51dcd2df6f29dfae088e17d658a32c922740a5f580333d9c4816497888303cfee51a07e00d618cbdbd687bad7c1344a1f801bb3c5609797900b283932122ed8e7cc8f5c0293bd834784fad537d6c4001da4e0e70d852138ef56a6408b022876f74828c5cfbd604da9f63356c771
#TRUST-RSA-SHA256 166cd037c2da27159f16dc4159e50c15eaf6dc2df5250b27cd0d50a14e5ff3c522d1beb5fd52caabc03ce5f5ab3f0bb127c34e8669660deab18be441424097e48ab0b25a44b261a64c486a1db67d51b244b29c97c68c76ebe0912233acce607ddfaa35c58bb7f1eaed6e6f3d9bf1a0cbf718de3ec7770bdc07e08a3d2bb2090da99709bab0467be242864f232d8bcb0bc23bae9b957366b1aef282801db67b5404f047aa1eaaa1fb7c879929df3bc060585ad3a5dc24cfdc9f08451616c1df0714534b61c7242580c9ab063b4bdb5206ad5a900360436b531cdfcae9f5ced28cc187b8008296aa56c400ec60f5d362d994c257e11e9f7ec8a364f903a628325d3ced06b0f43ad1c0b0490722965aa6d8885ef2997cb26f2fce0941dd675be57784cc1413bd4b7c86020abcf49e33be4a6eae362a959dedb61598aa7077b93cba9396bb9f8ac19ad9a66eed15b24829622dfdc9d7504f4aaf6fe0aff0833baae4148d5153bbe9b41a30d33cdc9629ea482a041818a58305b7d90a667c778157103cdd93039a59ad9d67e55add95f483a64b51311a4b7dae7ec686e851eddd678019f789b0bb34c3013a0ef3b0b6bb55fcc9ae3ed5af93c7ecdb7661ab4f21b639240d714d979b09e630cb5a992abe9d594a783b70143dc8323256ec7e8d1592b9c7b15e341790bda551e2d64677d95518005eb7aaa4d73615a46531e7b62d1c7e
#
# This script is Copyright (C) 2004-2025 and is owned by Tenable, Inc. or an Affiliate thereof.
#
# This script is released under the Tenable Subscription License and
# may not be used from within scripts released under another license
# without authorization from Tenable, Inc.
#
# See the following licenses for details:
#
# http://static.tenable.com/prod_docs/Nessus_6_SLA_and_Subscription_Agreement.pdf
#
# @PROFESSIONALFEED@
# $Revision: 1.1 $
# $Date: 2025/01/06 $
#
# description : This .audit is designed against the CIS Debian Linux 12 Benchmark 1.1.0
#
#<ui_metadata>
#<display_name>CIS Debian Linux 12 v1.1.0 L2 Workstation</display_name>
#<spec>
#  <type>CIS</type>
#  <name>Debian Linux 12</name>
#  <profile>L2 Workstation</profile>
#  <version>1.1.0</version>
#  <link>https://workbench.cisecurity.org/benchmarks/18960</link>
#</spec>
#<labels>cis,debian_linux_12,agent</labels>
#<benchmark_refs>CSCv6,CSCv7,CSCv8,LEVEL</benchmark_refs>
#<variables>
#  <variable>
#    <name>PLATFORM_VERSION</name>
#    <default>^12</default>
#    <description>Linux Distribution Version</description>
#    <info>Linux Distribution Version</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>PASSWORD_ROOT_UNLOCK_TIME</name>
#    <default>([6-9][0-9]{1,})</default>
#    <description>Root password lockout time setting</description>
#    <info>Amount of time in seconds access will be blocked after a lock out.</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>PASSWORD_MIN_DAYS</name>
#    <default>1</default>
#    <description>Password minimum days</description>
#    <info>Minimum days between password changes parameter found in /etc/login.defs</info>
#    <value_type>INTEGER</value_type>
#  </variable>
#  <variable>
#    <name>FIND_TIMEOUT</name>
#    <default>7200</default>
#    <description>Timeout for checks that search for files</description>
#    <info>Timeout, in seconds, for checks that search for files. Range of 1-7200.</info>
#    <value_type>INTEGER</value_type>
#  </variable>
#  <variable>
#    <name>MAX_AUDIT_LOG_FILE_SIZE</name>
#    <default>32</default>
#    <description>Log file size</description>
#    <info>The max size, in MBs, each audit log can be before log file rotation.</info>
#    <value_type>STRING</value_type>
#  </variable>
#</variables>
#</ui_metadata>

<check_type:"Unix">

<if>
  <condition type:"AND">
    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "Debian found"
      file        : "/etc/debian_version"
      regex       : "@PLATFORM_VERSION@"
      expect      : "@PLATFORM_VERSION@"
    </custom_item>
  </condition>

  <then>
    <report type:"PASSED">
      description : "CIS_Debian_Linux_12_v1.1.0_L2_Workstation.audit from CIS Debian Linux 12 Benchmark v1.1.0"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
    </report>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.10 Ensure unused filesystems kernel modules are not available"
      info        : "Filesystem kernel modules are pieces of code that can be dynamically loaded into the Linux kernel to extend its filesystem capabilities, or so-called base kernel, of an operating system. Filesystem kernel modules are typically used to add support for new hardware (as device drivers), or for adding system calls.

While loadable filesystem kernel modules are a convenient method of modifying the running kernel, this can be abused by attackers on a compromised system to prevent detection of their processes or files, allowing them to maintain control over the system. Many rootkits make use of loadable filesystem kernel modules in this way.

Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it. The following filesystem kernel modules have known CVE's and should be made unavailable if no dependencies exist:

 - afs - CVE-2022-37402
 - ceph - CVE-2022-0670
 - cifs - CVE-2022-29869
 - exfat CVE-2022-29973
 - fat CVE-2022-22043
 - fscache CVE-2022-3630
 - fuse CVE-2023-0386
 - gfs2 CVE-2023-3212

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
      solution    : "- IF - the module is available in the running kernel:

 - Unload the filesystem kernel module from the kernel
 - Create a file ending inconf with install filesystem kernel modules /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with deny list filesystem kernel modules in the /etc/modprobe.d/ directory

WARNING : unloading, disabling or denylisting filesystem modules that are in use on the system maybe FATAL. It is extremely important to thoroughly review the filesystems returned by the audit before following the remediation procedure.

Example of unloading the gfs2 kernel module:

# modprobe -r gfs2 2>/dev/null
# rmmod gfs2 2>/dev/null

Example of fully disabling the gfs2 kernel module:

# printf '%s\n' \"blacklist gfs2\" \"install gfs2 /bin/false\" >> /etc/modprobe.d/gfs2.conf

Note:

 - Disabling a kernel module by modifying the command above for each unused filesystem kernel module
 - The example gfs2 must be updated with the appropriate module name for the command or example script bellow to run correctly.

Below is an example Script that can be modified to use on various filesystem kernel modules manual remediation process:

Example Script

#!/usr/bin/env bash

{
   a_output2=(); a_output3=(); l_dl=\"\" # Initialize arrays and clear variables
   l_mod_name=\"gfs2\" # set module name
   l_mod_type=\"fs\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}

Impact:

This list may be quite extensive and covering all edges cases is difficult. Therefore, it's crucial to carefully consider the implications and dependencies before making any changes to the filesystem kernel module configurations."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2M,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   a_output=(); a_output2=(); a_modprope_config=(); a_excluded=(); a_available_modules=()
   a_ignore=(\"xfs\" \"vfat\" \"ext2\" \"ext3\" \"ext4\")
   a_cve_exists=(\"afs\" \"ceph\" \"cifs\" \"exfat\" \"fat\" \"fscache\" \"fuse\" \"gfs2\")
   f_module_chk()
   {
      l_out2=\"\"; grep -Pq -- \"\\b$l_mod_name\\b\" <<< \"${a_cve_exists[*]}\" && l_out2=\" <- CVE exists!\"
      if ! grep -Pq -- '\\bblacklist\\h+'\"$l_mod_name\"'\\b' <<< \"${a_modprope_config[*]}\"; then
         a_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is not fully disabled $l_out2\")
      elif ! grep -Pq -- '\\binstall\\h+'\"$l_mod_name\"'\\h+(\\/usr)?\\/bin\\/(false|true)\\b' <<< \"${a_modprope_config[*]}\"; then
         a_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is not fully disabled $l_out2\")
      fi
      if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         l_output2+=(\"  - Kernel module: \\\"$l_mod_name\\\" is loaded\" \"\")
      fi
   }
   while IFS= read -r -d $'\\0' l_module_dir; do
      a_available_modules+=(\"$(basename \"$l_module_dir\")\")
   done < <(find \"$(readlink -f /lib/modules/\"$(uname -r)\"/kernel/fs)\" -mindepth 1 -maxdepth 1 -type d ! -empty -print0)
   while IFS= read -r l_exclude; do
      if grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_cve_exists[*]}\"; then
         a_output2+=(\"  - ** WARNING: kernel module: \\\"$l_exclude\\\" has a CVE and is currently mounted! **\")
      elif
         grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_available_modules[*]}\"; then
         a_output+=(\"  - Kernel module: \\\"$l_exclude\\\" is currently mounted - do NOT unload or disable\")
      fi
      ! grep -Pq -- \"\\b$l_exclude\\b\" <<< \"${a_ignore[*]}\" && a_ignore+=(\"$l_exclude\")
   done < <(findmnt -knD | awk '{print $2}' | sort -u)
   while IFS= read -r l_config; do
      a_modprope_config+=(\"$l_config\")
   done < <(modprobe --showconfig | grep -P '^\\h*(blacklist|install)')
   for l_mod_name in \"${a_available_modules[@]}\"; do # Iterate over all filesystem modules
      [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
      if grep -Pq -- \"\\b$l_mod_name\\b\" <<< \"${a_ignore[*]}\"; then
         a_excluded+=(\" - Kernel module: \\\"$l_mod_name\\\"\")
      else
         f_module_chk
      fi
   done
   [ \"${#a_excluded[@]}\" -gt 0 ] && printf '%s\\n' \"\" \" -- INFO --\" \\
   \"The following intentionally skipped\" \\
    \"${a_excluded[@]}\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"  - No unused filesystem kernel modules are enabled\" \"${a_output[@]}\" \"\"
   else
      printf '%s\\n' \"\" \"-- Audit Result: --\" \"  ** REVIEW the following **\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"\" \"-- Correctly set: --\" \"${a_output[@]}\" \"\"
   fi
}"
      expect      : "^Manual Review Required$"
      severity    : MEDIUM
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.6 Ensure overlayfs kernel module is not available"
      info        : "overlayfs is a Linux filesystem that layers multiple filesystems to create a single unified view which allows a user to \"merge\" several mount points into a unified filesystem.

The overlayfs has known CVE's: CVE-2023-32629, CVE-2023-2640, CVE-2023-0386. Disabling the overlayfs reduces the local attack surface by removing support for unnecessary filesystem types and mitigates potential risks associated with unauthorized execution of setuid files, enhancing the overall system security."
      solution    : "Run the following script to unload and disable the overlayfs module:

- IF - the overlayfs kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install overlayfs /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist overlayfs in the /etc/modprobe.d/ directory
 - Run modprobe -r overlay 2>/dev/null; rmmod overlay 2>/dev/null to remove overlayfs from the kernel

- IF - the overlayfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"overlayfs\" l_mod_type=\"fs\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}

Impact:

WARNING: If Container applications such as Docker, Kubernetes, Podman, Linux Containers (LXC), etc. are in use proceed with caution and consider the impact on containerized workloads, as disabling the overlayfs may severely disrupt containerization."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   a_output=() a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"overlayfs\" l_mod_type=\"fs\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_chk_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_chk_name//-/_}\"'\\h+(\\/usr)?\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_chk_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\\/}\")\" ]; then
         a_output3+=(\"  - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.7 Ensure squashfs kernel module is not available"
      info        : "The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image.

Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
      solution    : "Run the following script to unload and disable the udf module:

- IF - the squashfs kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install squashfs /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist squashfs in the /etc/modprobe.d/ directory
 - Run modprobe -r squashfs 2>/dev/null; rmmod squashfs 2>/dev/null to remove squashfs from the kernel

- IF - the squashfs kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"squashfs\" l_mod_type=\"fs\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}

Impact:

As Snap packages utilize squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail.

Snap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"squashfs\" # set module name
   l_mod_type=\"fs\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.8 Ensure udf kernel module is not available"
      info        : "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats.

Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
      solution    : "Run the following script to unload and disable the udf module:

- IF - the udf kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install udf /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist udf in the /etc/modprobe.d/ directory
 - Run modprobe -r udf 2>/dev/null; rmmod udf 2>/dev/null to remove udf from the kernel

- IF - the udf kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"udf\" l_mod_type=\"fs\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}

Impact:

Microsoft Azure requires the usage of udf

udf should not be disabled on systems run on Microsoft Azure."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"udf\" # set module name
   l_mod_type=\"fs\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.9 Ensure usb-storage kernel module is not available"
      info        : "USB storage provides a means to transfer and store files ensuring persistence and availability of the files independent of network connection status. Its popularity and utility has led to USB-based malware being a simple and common means for network infiltration and a first step to establishing a persistent threat within a networked environment.

Restricting USB access on the system will decrease the physical attack surface for a device and diminish the possible vectors to introduce malware."
      solution    : "Run the following script to unload and disable the usb-storage module:

- IF - the usb-storage kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install usb-storage /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist usb-storage in the /etc/modprobe.d/ directory
 - Run modprobe -r usb-storage 2>/dev/null; rmmod usb-storage 2>/dev/null to remove usb-storage from the kernel

- IF - the usb-storage kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"usb-storage\" l_mod_type=\"drivers\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}

Impact:

Disabling the usb-storage module will disable any usage of USB storage devices.

If requirements and local site policy allow the use of such devices, other solutions should be configured accordingly instead. One example of a commonly used solution is USBGuard"
      reference   : "800-171|3.8.7,800-53|MP-7,800-53r5|MP-7,CN-L3|8.5.4.1(c),CSCv7|13.7,CSCv8|10.3,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.8.3.1,ISO/IEC-27001|A.8.3.3,LEVEL|2A,NESA|T1.4.1"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"usb-storage\" # set module name
   l_mod_type=\"drivers\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "1.1.2.3.1 Ensure separate partition exists for /home"
      info        : "The /home directory is used to support disk storage needs of local users.

The default installation only creates a single / partition. Since the /home directory contains user generated data, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /home and impact all local users.

Configuring /home as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. In the case of /home options such as usrquota/grpquota may be considered to limit the impact that users can have on each other with regards to disk resource exhaustion. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

As /home contains user data, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /home

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/proc/self/mountinfo"
      regex       : "[\\s]+/home[\\s]+"
      expect      : "[\\s]+/home[\\s]+"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "1.1.2.4.1 Ensure separate partition exists for /var"
      info        : "The /var directory is used by daemons and other system services to temporarily store dynamic data. Some directories created by these processes may be world-writable.

The reasoning for mounting /var on a separate partition is as follows.

The default installation only creates a single / partition. Since the /var directory may contain world writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system. In addition, other operations on the system could fill up the disk unrelated to /var and cause unintended behavior across the system as the disk is full. See man auditd.conf for details.

Configuring /var as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

An example of exploiting /var may be an attacker establishing a hard-link to a system setuid program and waiting for it to be updated. Once the program is updated, the hard-link can be broken and the attacker would have their own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/proc/self/mountinfo"
      regex       : "[\\s]+/var[\\s]+"
      expect      : "[\\s]+/var[\\s]+"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "1.1.2.5.1 Ensure separate partition exists for /var/tmp"
      info        : "The /var/tmp directory is a world-writable directory used for temporary storage by all users and some applications. Temporary files residing in /var/tmp are to be preserved between reboots.

The default installation only creates a single / partition. Since the /var/tmp directory is world-writable, there is a risk of resource exhaustion. In addition, other operations on the system could fill up the disk unrelated to /var/tmp and cause potential disruption to daemons as the disk is full.

Configuring /var/tmp as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/tmp

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/proc/self/mountinfo"
      regex       : "[\\s]+/var/tmp[\\s]+"
      expect      : "[\\s]+/var/tmp[\\s]+"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "1.1.2.6.1 Ensure separate partition exists for /var/log"
      info        : "The /var/log directory is used by system services to store log data.

The default installation only creates a single / partition. Since the /var/log directory contains log files which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole.

Configuring /var/log as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

As /var/log contains log files, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/proc/self/mountinfo"
      regex       : "[\\s]+/var/log[\\s]+"
      expect      : "[\\s]+/var/log[\\s]+"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "1.1.2.7.1 Ensure separate partition exists for /var/log/audit"
      info        : "The auditing daemon, auditd stores log data in the /var/log/audit directory.

The default installation only creates a single / partition. Since the /var/log/audit directory contains the audit.log file which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var/log/audit and cause auditd to trigger its space_left_action as the disk is full. See man auditd.conf for details.

Configuring /var/log/audit as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

As /var/log/audit contains audit logs, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log/audit

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/proc/self/mountinfo"
      regex       : "[\\s]+/var/log/audit[\\s]+"
      expect      : "[\\s]+/var/log/audit[\\s]+"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "apparmor_status - processes are confined"
          cmd         : "/sbin/apparmor_status"
          expect      : "^[\\s]*0[\\s]+processes[\\s]+are[\\s]+unconfined"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "apparmor_status - profiles are loaded"
          cmd         : "/sbin/apparmor_status"
          expect      : "^[\\s]*[1-9][0-9]*[\\s]+profiles[\\s]+are[\\s]+loaded"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "apparmor_status - profiles in complain mode"
          cmd         : "/sbin/apparmor_status"
          expect      : "^[\\s]*0[\\s]+profiles[\\s]+are[\\s]+in[\\s]+complain[\\s]+mode"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "1.3.1.4 Ensure all AppArmor Profiles are enforcing"
          info        : "AppArmor profiles define what resources applications are able to access.

Security configuration requirements vary from site to site. Some sites may mandate a policy that is stricter than the default policy, which is perfectly acceptable. This item is intended to ensure that any policies that exist on the system are activated."
          solution    : "Run the following command to set all profiles to enforce mode:

# aa-enforce /etc/apparmor.d/*

Note: Any unconfined processes may need to have a profile created or activated for them and then be restarted"
          reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "GDM is installed"
          cmd         : "/bin/dpkg -s gdm3 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "Ensure automount is disabled"
              cmd         : "/bin/gsettings get org.gnome.desktop.media-handling automount"
              expect      : "^[\\s]*false[\\s]*$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "Ensure automount-open is disabled"
              cmd         : "/bin/gsettings get org.gnome.desktop.media-handling automount-open"
              expect      : "^[\\s]*false[\\s]*$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "1.7.6 Ensure GDM automatic mounting of removable media is disabled"
              info        : "By default GNOME automatically mounts removable media when inserted as a convenience to the user.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in system even if they lacked permissions to mount it themselves."
              solution    : "- IF - A user profile exists run the following commands to ensure automatic mounting is disabled:

# gsettings set org.gnome.desktop.media-handling automount false
# gsettings set org.gnome.desktop.media-handling automount-open false

Note:

 - gsettings commands in this section MUST be done from a command window on a graphical desktop or an error will be returned.
 - The system must be restarted after all gsettings configurations have been set in order for CIS-CAT Assessor to appropriately assess.
 - If the dconf database is not updating correctly due to umask requirements contain in the benchmark, then use (umask 0022 && gsetting set) commands from above to temporarily set umask ensuring that any files or directories created by gsettings will have the required permissions.

- OR/IF - A user profile does not exist:

 - Create a file /etc/dconf/db/local.d/00-media-automount with following content:

[org/gnome/desktop/media-handling]
automount=false
automount-open=false <xhtml:ol start=\"2\"> - After creating the file, apply the changes using below command :

# dconf update

Note: Users must log out and back in again before the system-wide settings take effect.

Impact:

The use of portable hard drives is very common for workstation users. If your organization allows the use of portable storage or media on workstations and physical access controls to workstations is considered adequate there is little value add in turning off automounting."
              reference   : "800-171|3.8.7,800-53|MP-7,800-53r5|MP-7,CN-L3|8.5.4.1(c),CSCv7|8.5,CSCv8|10.3,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.8.3.1,ISO/IEC-27001|A.8.3.3,LEVEL|2A,NESA|T1.4.1"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <report type:"PASSED">
          description : "1.7.6 Ensure GDM automatic mounting of removable media is disabled"
          info        : "By default GNOME automatically mounts removable media when inserted as a convenience to the user.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in system even if they lacked permissions to mount it themselves."
          solution    : "- IF - A user profile exists run the following commands to ensure automatic mounting is disabled:

# gsettings set org.gnome.desktop.media-handling automount false
# gsettings set org.gnome.desktop.media-handling automount-open false

Note:

 - gsettings commands in this section MUST be done from a command window on a graphical desktop or an error will be returned.
 - The system must be restarted after all gsettings configurations have been set in order for CIS-CAT Assessor to appropriately assess.
 - If the dconf database is not updating correctly due to umask requirements contain in the benchmark, then use (umask 0022 && gsetting set) commands from above to temporarily set umask ensuring that any files or directories created by gsettings will have the required permissions.

- OR/IF - A user profile does not exist:

 - Create a file /etc/dconf/db/local.d/00-media-automount with following content:

[org/gnome/desktop/media-handling]
automount=false
automount-open=false <xhtml:ol start=\"2\"> - After creating the file, apply the changes using below command :

# dconf update

Note: Users must log out and back in again before the system-wide settings take effect.

Impact:

The use of portable hard drives is very common for workstation users. If your organization allows the use of portable storage or media on workstations and physical access controls to workstations is considered adequate there is little value add in turning off automounting."
          reference   : "800-171|3.8.7,800-53|MP-7,800-53r5|MP-7,CN-L3|8.5.4.1(c),CSCv7|8.5,CSCv8|10.3,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.8.3.1,ISO/IEC-27001|A.8.3.3,LEVEL|2A,NESA|T1.4.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "GDM is installed"
          cmd         : "/bin/dpkg -s gdm3 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          type        : CMD_EXEC
          description : "1.7.7 Ensure GDM disabling automatic mounting of removable media is not overridden"
          info        : "By default GNOME automatically mounts removable media when inserted as a convenience to the user.

By using the lockdown mode in dconf, you can prevent users from changing specific settings. To lock down a dconf key or subpath, create a locks subdirectory in the keyfile directory. The files inside this directory contain a list of keys or subpaths to lock. Just as with the keyfiles, you may add any number of files to this directory.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in system even if they lacked permissions to mount it themselves."
          solution    : "- To prevent the user from overriding these settings, create the file /etc/dconf/db/local.d/locks/00-media-automount with the following content:

[org/gnome/desktop/media-handling]
automount=false
automount-open=false <xhtml:ol start=\"2\"> - Update the systems databases:

# dconf update

Note:

 - A user profile must exist in order to apply locks.
 - Users must log out and back in again before the system-wide settings take effect.

Impact:

The use of portable hard drives is very common for workstation users"
          reference   : "800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|MP-2,800-53r5|MP-2,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          cmd         : "#!/bin/bash

{
   a_output=() a_output2=()
   check_setting()
   {
      grep -Psrilq \"^\\h*$1\\h*=\\h*false\\b\" /etc/dconf/db/local.d/locks/* 2> /dev/null && \\
      echo \"- \\\"$3\\\" is locked and set to false\" || echo \"- \\\"$3\\\" is not locked or not set to false\"
   }
   declare -A settings=(
      [\"automount\"]=\"org/gnome/desktop/media-handling\"
      [\"automount-open\"]=\"org/gnome/desktop/media-handling\"
   )
   for setting in \"${!settings[@]}\"; do
      result=$(check_setting \"$setting\" \"${settings[$setting]}\" \"$setting\")
      if [[ $result == *\"is not locked\"* || $result == *\"not set to false\"* ]]; then
         a_output2+=(\"$result\")
      else
         a_output+=(\"$result\")
      fi
   done
   printf '%s\\n' \"\" \"- Audit Result:\"
   if [ \"${#a_output2[@]}\" -gt 0 ]; then
      printf '%s\\n' \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"\" \"- Correctly set:\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"  ** PASS **\" \"${a_output[@]}\"
   fi
}"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </then>

      <else>
        <report type:"PASSED">
          description : "1.7.7 Ensure GDM disabling automatic mounting of removable media is not overridden"
          info        : "By default GNOME automatically mounts removable media when inserted as a convenience to the user.

By using the lockdown mode in dconf, you can prevent users from changing specific settings. To lock down a dconf key or subpath, create a locks subdirectory in the keyfile directory. The files inside this directory contain a list of keys or subpaths to lock. Just as with the keyfiles, you may add any number of files to this directory.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in system even if they lacked permissions to mount it themselves."
          solution    : "- To prevent the user from overriding these settings, create the file /etc/dconf/db/local.d/locks/00-media-automount with the following content:

[org/gnome/desktop/media-handling]
automount=false
automount-open=false <xhtml:ol start=\"2\"> - Update the systems databases:

# dconf update

Note:

 - A user profile must exist in order to apply locks.
 - Users must log out and back in again before the system-wide settings take effect.

Impact:

The use of portable hard drives is very common for workstation users"
          reference   : "800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|MP-2,800-53r5|MP-2,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "autofs"
          cmd         : "/bin/dpkg -s autofs 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          type        : CMD_EXEC
          description : "2.1.1 Ensure autofs services are not in use"
          info        : "autofs allows automatic mounting of devices, typically including CD/DVDs and USB drives.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in the filesystem even if they lacked permissions to mount it themselves."
          solution    : "Run the following commands to stop autofs.service and remove the autofs package:

# systemctl stop autofs.service
# apt purge autofs

- OR -

- IF - the autofs package is required as a dependency:

Run the following commands to stop and mask autofs.service :

# systemctl stop autofs.service
# systemctl mask autofs.service

Impact:

The use of portable hard drives is very common for workstation users. If your organization allows the use of portable storage or media on workstations and physical access controls to workstations is considered adequate there is little value add in turning off automounting.

There may be packages that are dependent on the autofs package. If the autofs package is removed, these dependent packages will be removed as well. Before removing the autofs package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask the autofs.service leaving the autofs package installed."
          reference   : "800-171|3.8.7,800-53|MP-7,800-53r5|MP-7,CN-L3|8.5.4.1(c),CSCv7|8.5,CSCv8|10.3,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.8.3.1,ISO/IEC-27001|A.8.3.3,LEVEL|2A,NESA|T1.4.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          cmd         : "/bin/dpkg -s autofs 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "autofs.service active"
              cmd         : "/bin/systemctl is-active autofs.service 2>/dev/null | /bin/grep '^active' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "autofs.service enabled"
              cmd         : "/bin/systemctl is-enabled autofs.service 2>/dev/null | /bin/grep 'enabled' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "2.1.1 Ensure autofs services are not in use"
              info        : "autofs allows automatic mounting of devices, typically including CD/DVDs and USB drives.

With automounting enabled anyone with physical access could attach a USB drive or disc and have its contents available in the filesystem even if they lacked permissions to mount it themselves."
              solution    : "Run the following commands to stop autofs.service and remove the autofs package:

# systemctl stop autofs.service
# apt purge autofs

- OR -

- IF - the autofs package is required as a dependency:

Run the following commands to stop and mask autofs.service :

# systemctl stop autofs.service
# systemctl mask autofs.service

Impact:

The use of portable hard drives is very common for workstation users. If your organization allows the use of portable storage or media on workstations and physical access controls to workstations is considered adequate there is little value add in turning off automounting.

There may be packages that are dependent on the autofs package. If the autofs package is removed, these dependent packages will be removed as well. Before removing the autofs package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask the autofs.service leaving the autofs package installed."
              reference   : "800-171|3.8.7,800-53|MP-7,800-53r5|MP-7,CN-L3|8.5.4.1(c),CSCv7|8.5,CSCv8|10.3,CSF|PR.PT-2,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.8.3.1,ISO/IEC-27001|A.8.3.3,LEVEL|2A,NESA|T1.4.1"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "Cups installed"
          cmd         : "/bin/dpkg -s cups 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "cups.socket cups.service active"
              cmd         : "/bin/systemctl is-active cups.socket cups.service 2>/dev/null | /bin/grep '^active' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "cups.socket cups.service enabled"
              cmd         : "/bin/systemctl is-enabled cups.socket cups.service 2>/dev/null | /bin/grep 'enabled' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "2.1.11 Ensure print server services are not in use"
              info        : "The Common Unix Print System (CUPS) provides the ability to print to both local and network printers. A system running CUPS can also accept print jobs from remote systems and print them to local printers. It also provides a web based remote administration capability.

If the system does not need to print jobs or accept print jobs from other systems, it is recommended that CUPS be removed to reduce the potential attack surface."
              solution    : "Run the following commands to stop cups.socket and cups.service and remove the cups package:

# systemctl stop cups.socket cups.service
# apt purge cups

- OR -

- IF - the cups package is required as a dependency:

Run the following commands to stop and mask the cups.socket and cups.service :

# systemctl stop cups.socket cups.service
# systemctl mask cups.socket cups.service

Impact:

Removing the cups package, or disabling cups.socket and/or cups.service will prevent printing from the system, a common task for workstation systems.

There may be packages that are dependent on the cups package. If the cups package is removed, these dependent packages will be removed as well. Before removing the cups package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask cups.socket and cups.service leaving the cups package installed."
              reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <custom_item>
          type        : CMD_EXEC
          description : "2.1.11 Ensure print server services are not in use"
          info        : "The Common Unix Print System (CUPS) provides the ability to print to both local and network printers. A system running CUPS can also accept print jobs from remote systems and print them to local printers. It also provides a web based remote administration capability.

If the system does not need to print jobs or accept print jobs from other systems, it is recommended that CUPS be removed to reduce the potential attack surface."
          solution    : "Run the following commands to stop cups.socket and cups.service and remove the cups package:

# systemctl stop cups.socket cups.service
# apt purge cups

- OR -

- IF - the cups package is required as a dependency:

Run the following commands to stop and mask the cups.socket and cups.service :

# systemctl stop cups.socket cups.service
# systemctl mask cups.socket cups.service

Impact:

Removing the cups package, or disabling cups.socket and/or cups.service will prevent printing from the system, a common task for workstation systems.

There may be packages that are dependent on the cups package. If the cups package is removed, these dependent packages will be removed as well. Before removing the cups package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask cups.socket and cups.service leaving the cups package installed."
          reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          cmd         : "/bin/dpkg -s cups 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "package installed"
          cmd         : "/bin/dpkg -s avahi-daemon 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "socket not enabled"
              cmd         : "/bin/systemctl is-enabled avahi-daemon.socket 2>/dev/null | /bin/grep '^enabled' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "^pass$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "service not active"
              cmd         : "/bin/systemctl is-active avahi-daemon.service 2>/dev/null | /bin/grep '^active' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "^pass$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "service not enabled"
              cmd         : "/bin/systemctl is-enabled avahi-daemon.service 2>/dev/null | /bin/grep '^enabled' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "^pass$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "socket not active"
              cmd         : "/bin/systemctl is-active avahi-daemon.socket 2>/dev/null | /bin/grep '^active' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "^pass$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "2.1.2 Ensure avahi daemon services are not in use"
              info        : "Avahi is a free zeroconf implementation, including a system for multicast DNS/DNS-SD service discovery. Avahi allows programs to publish and discover services and hosts running on a local network with no specific configuration. For example, a user can plug a computer into a network and Avahi automatically finds printers to print to, files to look at and people to talk to, as well as network services running on the machine.

Automatic discovery of network services is not normally required for system functionality. It is recommended to remove this package to reduce the potential attack surface."
              solution    : "Run the following commands to stop avahi-daemon.socket and avahi-daemon.service and remove the avahi-daemon package:

# systemctl stop avahi-daemon.socket avahi-daemon.service
# apt purge avahi-daemon

- OR -

- IF - the avahi-daemon package is required as a dependency:

Run the following commands to stop and mask the avahi-daemon.socket and avahi-daemon.service :

# systemctl stop avahi-daemon.socket avahi-daemon.service
# systemctl mask avahi-daemon.socket avahi-daemon.service

Impact:

There may be packages that are dependent on the avahi package. If the avahi package is removed, these dependent packages will be removed as well. Before removing the avahi package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask the avahi-daemon.socket and avahi-daemon.service leaving the avahi package installed."
              reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <custom_item>
          type        : CMD_EXEC
          description : "2.1.2 Ensure avahi daemon services are not in use"
          info        : "Avahi is a free zeroconf implementation, including a system for multicast DNS/DNS-SD service discovery. Avahi allows programs to publish and discover services and hosts running on a local network with no specific configuration. For example, a user can plug a computer into a network and Avahi automatically finds printers to print to, files to look at and people to talk to, as well as network services running on the machine.

Automatic discovery of network services is not normally required for system functionality. It is recommended to remove this package to reduce the potential attack surface."
          solution    : "Run the following commands to stop avahi-daemon.socket and avahi-daemon.service and remove the avahi-daemon package:

# systemctl stop avahi-daemon.socket avahi-daemon.service
# apt purge avahi-daemon

- OR -

- IF - the avahi-daemon package is required as a dependency:

Run the following commands to stop and mask the avahi-daemon.socket and avahi-daemon.service :

# systemctl stop avahi-daemon.socket avahi-daemon.service
# systemctl mask avahi-daemon.socket avahi-daemon.service

Impact:

There may be packages that are dependent on the avahi package. If the avahi package is removed, these dependent packages will be removed as well. Before removing the avahi package, review any dependent packages to determine if they are required on the system.

- IF - a dependent package is required: stop and mask the avahi-daemon.socket and avahi-daemon.service leaving the avahi package installed."
          reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          cmd         : "/bin/dpkg -s avahi-daemon 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "bluez"
          cmd         : "/bin/dpkg -s bluez 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          type        : CMD_EXEC
          description : "3.1.3 Ensure bluetooth services are not in use"
          info        : "Bluetooth is a short-range wireless technology standard that is used for exchanging data between devices over short distances. It employs UHF radio waves in the ISM bands, from 2.402 GHz to 2.48 GHz. It is mainly used as an alternative to wire connections.

An attacker may be able to find a way to access or corrupt your data. One example of this type of activity is bluesnarfing which refers to attackers using a Bluetooth connection to steal information off of your Bluetooth device. Also, viruses or other malicious code can take advantage of Bluetooth technology to infect other devices. If you are infected, your data may be corrupted, compromised, stolen, or lost."
          solution    : "Run the following commands to stop bluetooth.service and remove the bluez package:

# systemctl stop bluetooth.service
# apt purge bluez

- OR -

- IF - the bluez package is required as a dependency:

Run the following commands to stop and mask bluetooth.service :

# systemctl stop bluetooth.service
# systemctl mask bluetooth.service

Note: A reboot may be required

Impact:

Many personal electronic devices (PEDs) use Bluetooth technology. For example, you may be able to operate your computer with a wireless keyboard. Disabling Bluetooth will prevent these devices from connecting to the system.

There may be packages that are dependent on the bluez package. If the bluez package is removed, these dependent packages will be removed as well. Before removing the bluez package, review any dependent packages to determine if they are required on the system.

-IF- a dependent package is required: stop and mask bluetooth.service leaving the bluez package installed."
          reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          cmd         : "/bin/dpkg -s bluez 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "(^Status: deinstall ok|not installed)"
        </custom_item>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "bluetooth.service active"
              cmd         : "/bin/systemctl is-active bluetooth.service 2>/dev/null | /bin/grep '^active' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "bluetooth.service enabled"
              cmd         : "/bin/systemctl is-enabled bluetooth.service 2>/dev/null | /bin/grep 'enabled' | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "3.1.3 Ensure bluetooth services are not in use"
              info        : "Bluetooth is a short-range wireless technology standard that is used for exchanging data between devices over short distances. It employs UHF radio waves in the ISM bands, from 2.402 GHz to 2.48 GHz. It is mainly used as an alternative to wire connections.

An attacker may be able to find a way to access or corrupt your data. One example of this type of activity is bluesnarfing which refers to attackers using a Bluetooth connection to steal information off of your Bluetooth device. Also, viruses or other malicious code can take advantage of Bluetooth technology to infect other devices. If you are infected, your data may be corrupted, compromised, stolen, or lost."
              solution    : "Run the following commands to stop bluetooth.service and remove the bluez package:

# systemctl stop bluetooth.service
# apt purge bluez

- OR -

- IF - the bluez package is required as a dependency:

Run the following commands to stop and mask bluetooth.service :

# systemctl stop bluetooth.service
# systemctl mask bluetooth.service

Note: A reboot may be required

Impact:

Many personal electronic devices (PEDs) use Bluetooth technology. For example, you may be able to operate your computer with a wireless keyboard. Disabling Bluetooth will prevent these devices from connecting to the system.

There may be packages that are dependent on the bluez package. If the bluez package is removed, these dependent packages will be removed as well. Before removing the bluez package, review any dependent packages to determine if they are required on the system.

-IF- a dependent package is required: stop and mask bluetooth.service leaving the bluez package installed."
              reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "3.2.1 Ensure dccp kernel module is not available"
      info        : "The Datagram Congestion Control Protocol (DCCP) is a transport layer protocol that supports streaming media and telephony. DCCP provides a way to gain access to congestion control, without having to do it at the application layer, but does not provide in-sequence delivery.

- IF - the protocol is not required, it is recommended that the drivers not be installed to reduce the potential attack surface."
      solution    : "Run the following script to unload and disable the dccp module:

- IF - the dccp kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install dccp /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist dccp in the /etc/modprobe.d/ directory
 - Run modprobe -r dccp 2>/dev/null; rmmod dccp 2>/dev/null to remove dccp from the kernel

- IF - the dccp kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"dccp\" l_mod_type=\"net\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"dccp\" # set module name
   l_mod_type=\"net\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.2.2 Ensure tipc kernel module is not available"
      info        : "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communication between cluster nodes.

- IF - the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to unload and disable the tipc module:

- IF - the tipc kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install tipc /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist tipc in the /etc/modprobe.d/ directory
 - Run modprobe -r tipc 2>/dev/null; rmmod tipc 2>/dev/null to remove tipc from the kernel

- IF - the tipc kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"tipc\" l_mod_type=\"net\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"tipc\" # set module name
   l_mod_type=\"net\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.2.3 Ensure rds kernel module is not available"
      info        : "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide low-latency, high-bandwidth communications between cluster nodes. It was developed by the Oracle Corporation.

- IF - the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to unload and disable the rds module:

- IF - the rds kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install rds /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist rds in the /etc/modprobe.d/ directory
 - Run modprobe -r rds 2>/dev/null; rmmod rds 2>/dev/null to remove rds from the kernel

- IF - the rds kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"rds\" l_mod_type=\"net\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"rds\" # set module name
   l_mod_type=\"net\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.2.4 Ensure sctp kernel module is not available"
      info        : "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to support message oriented communication, with several streams of messages in one connection. It serves a similar function as TCP and UDP, incorporating features of both. It is message-oriented like UDP, and ensures reliable in-sequence transport of messages with congestion control like TCP.

- IF - the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to unload and disable the sctp module:

- IF - the sctp kernel module is available in ANY installed kernel:

 - Create a file ending inconf with install sctp /bin/false in the /etc/modprobe.d/ directory
 - Create a file ending inconf with blacklist sctp in the /etc/modprobe.d/ directory
 - Run modprobe -r sctp 2>/dev/null; rmmod sctp 2>/dev/null to remove sctp from the kernel

- IF - the sctp kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary

#!/usr/bin/env bash

{
   a_output2=() a_output3=() l_dl=\"\" l_mod_name=\"sctp\" l_mod_type=\"net\"
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_fix()
   {
      l_dl=\"y\" a_showconfig=()
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'\"${l_mod_chk_name//-/_}\"'\b')
      if lsmod | grep \"$l_mod_chk_name\" &> /dev/null; then
         a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")
         modprobe -r \"$l_mod_chk_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null
      fi
      if ! grep -Pq -- '\binstall\h+'\"${l_mod_chk_name//-/_}\"'\h+(\/usr)?\/bin\/(true|false)\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"$(readlink -f /bin/false)\\\"\")
         printf '%s\n' \"install $l_mod_chk_name $(readlink -f /bin/false)\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
      if ! grep -Pq -- '\bblacklist\h+'\"${l_mod_chk_name//-/_}\"'\b' <<< \"${a_showconfig[*]}\"; then
         a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")
         printf '%s\n' \"blacklist $l_mod_chk_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\/}\" ] && [ -n \"$(ls -A \"$l_mod_base_directory/${l_mod_name/-/\/}\")\" ]; then
         a_output3+=(\" - \\\"$l_mod_base_directory\\\"\")
         l_mod_chk_name=\"$l_mod_name\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_chk_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_fix
      else
         printf '%s\n' \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"
      fi
   done
   [ \"${#a_output3[@]}\" -gt 0 ] && printf '%s\n' \"\" \" -- INFO --\" \" - module: \\\"$l_mod_name\\\" exists in:\" \"${a_output3[@]}\"
   [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\n' \"\" \"${a_output2[@]}\" || printf '%s\n' \"\" \" - No changes needed\"
   printf '%s\n' \"\" \" - remediation of kernel module: \\\"$l_mod_name\\\" complete\" \"\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output3=\"\" l_dl=\"\" # clear variables
   unset a_output; unset a_output2 # unset arrays
   l_mod_name=\"sctp\" # set module name
   l_mod_type=\"net\" # set module type
   l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"
   f_module_chk()
   {
      l_dl=\"y\" # Set to ignore duplicate checks
      a_showconfig=() # Create array with modprobe output
      while IFS= read -r l_showconfig; do
         a_showconfig+=(\"$l_showconfig\")
      done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')
      if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loaded\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loaded\")
      fi
      if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is not loadable\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is loadable\")
      fi
      if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then
         a_output+=(\"  - kernel module: \\\"$l_mod_name\\\" is deny listed\")
      else
         a_output2+=(\"  - kernel module: \\\"$l_mod_name\\\" is not deny listed\")
      fi
   }
   for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
      if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mod_base_directory\\\"\"
         [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\"
         [ \"$l_dl\" != \"y\" ] && f_module_chk
      else
         a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")
      fi
   done
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\"
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK_NOT
      description : "5.2.4 Ensure users must provide password for privilege escalation"
      info        : "The operating system must be configured so that users must provide a password for privilege escalation.

Without (re-)authentication, users may access resources or perform tasks for which they do not have authorization.

When operating systems provide the capability to escalate a functional capability, it is critical the user (re-)authenticate."
      solution    : "Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit the relevant sudoers file.

Remove any line with occurrences of NOPASSWD tags in the file.

Impact:

This will prevent automated processes from being able to elevate privileges."
      reference   : "800-171|3.1.5,800-171|3.1.6,800-53|AC-6(2),800-53|AC-6(5),800-53r5|AC-6(2),800-53r5|AC-6(5),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.10.6(a),CSCv7|4.3,CSCv8|5.4,CSF|PR.AC-4,CSF2.0|PR.AA-05,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.2.3,ITSG-33|AC-6(2),ITSG-33|AC-6(5),LEVEL|2A,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.6.1,NIAv2|AM1,NIAv2|AM23f,NIAv2|AM32,NIAv2|AM33,NIAv2|SS13c,NIAv2|SS15c,NIAv2|VL3a,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|5.2.2,QCSC-v1|6.2,SWIFT-CSCv1|1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/etc/sudoers /etc/sudoers.d/*"
      regex       : "^[^#]*NOPASSWD"
      expect      : "^[^#]*NOPASSWD"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "/etc/security/faillock.conf even_deny_root or root_unlock_time"
          file        : "/etc/security/faillock.conf"
          regex       : "(?i)^\\h*(even_deny_root|root_unlock_time\\h*=\\h*\\d+)\\b"
          expect      : "(?i)^\\h*(even_deny_root|root_unlock_time\\h*=\\h*\\d+)\\b"
        </custom_item>

        <custom_item>
          type            : FILE_CONTENT_CHECK
          description     : "faillock - root_unlock_time"
          file            : "/etc/security/faillock.conf"
          regex           : "(?i)^\\h*root_unlock_time\\h*="
          expect          : "(?i)^\\h*root_unlock_time\\h*=\\h*@PASSWORD_ROOT_UNLOCK_TIME@\\b"
          string_required : NO
        </custom_item>

        <custom_item>
          type            : FILE_CONTENT_CHECK
          description     : "/etc/pam.d/common-auth"
          file            : "/etc/pam.d/common-auth"
          regex           : "(?i)^\\h*auth\\h+([^#\\n\\r]+\\h+)pam_faillock\\.so\\h+([^#\\n\\r]+\\h+)?root_unlock_time\\h*="
          expect          : "(?i)^\\h*auth\\h+([^#\\n\\r]+\\h+)pam_faillock\\.so\\h+([^#\\n\\r]+\\h+)?root_unlock_time\\h*=\\h*@PASSWORD_ROOT_UNLOCK_TIME@\\b"
          string_required : NO
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.3.3.1.3 Ensure password failed attempts lockout includes root account"
          info        : "even_deny_root - Root account can become locked as well as regular accounts

root_unlock_time=n - This option implies even_deny_root option. Allow access after n seconds to root account after the account is locked. In case the option is not specified the value is the same as of the unlock_time option.

Locking out user IDs after n unsuccessful consecutive login attempts mitigates brute force password attacks against your systems."
          solution    : "Edit /etc/security/faillock.conf :

 - Remove or update any line containing root_unlock_time - OR - set it to a value of 60 or more
 - Update or add the following line:

even_deny_root

Run the following command:

# grep -Pl -- '\bpam_faillock\.so\h+([^#\n\r]+\h+)?(root_unlock_time=([0-9]|[1-5][0-9]))' /usr/share/pam-configs/*

Edit any returned files and remove the root_unlock_time arguments from the pam_faillock.so line(s) and run the following command to regenerate the effected pam files:

# pam-auth-update

Impact:

Use of unlock_time=0 or root_unlock_time=0 may allow an attacker to cause denial of service to legitimate users."
          reference   : "800-171|3.1.1,800-53|AC-1,800-53|AC-2,800-53|AC-2(1),800-53r5|AC-1,800-53r5|AC-2,800-53r5|AC-2(1),CN-L3|7.1.3.2(d),CN-L3|8.1.4.2(e),CN-L3|8.1.10.6(c),CSCv7|16.7,CSCv8|6.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|ID.GV-1,CSF|ID.GV-3,CSF|PR.AC-1,CSF|PR.AC-4,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|GV.OC-03,CSF2.0|GV.OV-01,CSF2.0|GV.PO-01,CSF2.0|GV.PO-02,CSF2.0|GV.SC-03,CSF2.0|ID.IM-01,CSF2.0|ID.IM-02,CSF2.0|ID.IM-03,CSF2.0|PR.AA-01,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.9.1.1,ISO/IEC-27001|A.9.2.1,ITSG-33|AC-1,ITSG-33|AC-2,ITSG-33|AC-2(1),LEVEL|2A,NESA|M1.2.2,NIAv2|AM28,NIAv2|AM29,NIAv2|AM30,NIAv2|NS5j,NIAv2|SS14e,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|8.2.1,QCSC-v1|13.2,QCSC-v1|15.2"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "shadow password min days"
          cmd         : "/bin/awk -F: '($2~/^\\$.+\\$/) {if($4 < @PASSWORD_MIN_DAYS@)print \"User: \" $1 \" PASS_MIN_DAYS: \" $4}' /etc/shadow | /bin/awk '{print} END {if (NR == 0) print \"pass\"; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "login.defs - PASS_MIN_DAYS"
          file        : "/etc/login.defs"
          regex       : "(?i)^\\h*PASS_MIN_DAYS\\h+\\d+\\b"
          expect      : "(?i)^\\h*PASS_MIN_DAYS\\h+@PASSWORD_MIN_DAYS@\\b"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.4.1.2 Ensure minimum password days is configured"
          info        : "PASS_MIN_DAYS <

N

> - The minimum number of days allowed between password changes. Any password changes attempted sooner than this will be rejected. If not specified, 0 will be assumed (which disables the restriction).

Users may have favorite passwords that they like to use because they are easy to remember and they believe that their password choice is secure from compromise. Unfortunately, passwords are compromised and if an attacker is targeting a specific individual user account, with foreknowledge of data about that user, reuse of old, potentially compromised passwords, may cause a security breach.

By restricting the frequency of password changes, an administrator can prevent users from repeatedly changing their password in an attempt to circumvent password reuse controls"
          solution    : "Edit /etc/login.defs and set PASS_MIN_DAYS to a value greater than 0 that follows local site policy:

Example:

PASS_MIN_DAYS 1

Run the following command to modify user parameters for all users with a password set to a minimum days greater than zero that follows local site policy:

# chage --mindays <N> <user>

Example:

# awk -F: '($2~/^\$.+\$/) {if($4 < 1)system (\"chage --mindays 1 \" $1)}' /etc/shadow

Impact:

If a users password is set by other personnel as a procedure in dealing with a lost or expired password, the user should be forced to update this \"set\" password with their own password. e.g. force \"change at next logon\".

If it is not possible to have a user set their own password immediately, and this recommendation or local site procedure may cause a user to continue using a third party generated password, PASS_MIN_DAYS for the effected user should be temporally changed to 0 to allow a user to change their password immediately.

For applications where the user is not using the password at console, the ability to \"change at next logon\" may be limited. This may cause a user to continue to use a password created by other personnel."
          reference   : "800-171|3.5.2,800-53|IA-5(1),800-53r5|IA-5(1),CSCv7|4.4,CSCv8|5.2,CSF|PR.AC-1,CSF2.0|PR.AA-01,CSF2.0|PR.AA-03,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(2)(i),HIPAA|164.312(d),ITSG-33|IA-5(1),LEVEL|2M,NESA|T5.2.3,QCSC-v1|5.2.2,QCSC-v1|13.2,SWIFT-CSCv1|4.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <custom_item>
      type        : FILE_CONTENT_CHECK_NOT
      description : "5.4.3.1 Ensure nologin is not listed in /etc/shells"
      info        : "/etc/shells is a text file which contains the full pathnames of valid login shells. This file is consulted by chsh and available to be queried by other programs.

Be aware that there are programs which consult this file to find out if a user is a normal user; for example, FTP daemons traditionally disallow access to users with shells not included in this file.

A user can use chsh to change their configured shell.

If a user has a shell configured that isn't in in /etc/shells then the system assumes that they're somehow restricted. In the case of chsh it means that the user cannot change that value.

Other programs might query that list and apply similar restrictions.

By putting nologin in /etc/shells any user that has nologin as its shell is considered a full, unrestricted user. This is not the expected behavior for nologin"
      solution    : "Edit /etc/shells and remove any lines that include nologin"
      reference   : "800-171|3.4.2,800-53|CM-6b.,800-53r5|CM-6b.,CN-L3|8.1.10.6(d),CSF|PR.IP-1,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6b.,LEVEL|2A,NESA|T3.2.1,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/etc/shells"
      regex       : "^\\h*([^#\\n\\r]+)?\\/nologin\\b"
      expect      : "^\\h*([^#\\n\\r]+)?\\/nologin\\b"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "dpkg check auditd"
          cmd         : "/bin/dpkg -s auditd 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "dpkg check audispd-plugins"
          cmd         : "/bin/dpkg -s audispd-plugins 2>&1 | /bin/grep -E '(^Status:|not installed)'"
          expect      : "^Status: install ok"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.1.1 Ensure auditd packages are installed"
          info        : "auditd is the userspace component to the Linux Auditing System. It's responsible for writing audit records to the disk

The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
          solution    : "Run the following command to Install auditd and audispd-plugins

# apt install auditd audispd-plugins"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "active"
          cmd         : "/bin/systemctl is-active auditd"
          expect      : "^active$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "enabled"
          cmd         : "/bin/systemctl is-enabled auditd"
          expect      : "^enabled$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.1.2 Ensure auditd service is enabled and active"
          info        : "Turn on the auditd daemon to record system events.

The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
          solution    : "Run the following commands to unmask, enable and start auditd :

# systemctl unmask auditd
# systemctl enable auditd
# systemctl start auditd"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.1.3 Ensure auditing for processes that start prior to auditd is enabled"
      info        : "Configure grub2 so that processes that are capable of being audited can be audited even if they start up prior to auditd startup.

Audit events need to be captured on processes that start up prior to auditd so that potential malicious activity cannot go undetected."
      solution    : "Edit /etc/default/grub and add audit=1 to GRUB_CMDLINE_LINUX :

Example:

GRUB_CMDLINE_LINUX=\"audit=1\"

Run the following command to update the grub2 configuration:

# update-grub"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash
  {
  l_output=\"\" l_output2=\"\" l_gout=\"\"
  l_gparameters=\"audit=1\"

	l_gpfile=\"$(find /boot -type f \\( -name 'grubenv' -o -name 'grub.conf' -o -name 'grub.cfg' \\) -exec grep -Pl -- '^\\h*(kernelopts=|linux|kernel)' {} +)\"
	[ -f \"$l_gpfile\" ] && l_gout=\"$(grep -P -- \"\\b$l_gparameters\\b\" \"$l_gpfile\")\"
	l_lout=\"$(grep -Ps -- \"\\b$l_gparameters\\b\" /boot/loader/entries/*)\"
	if [ -n \"$l_gout\" ] || [ -n \"$l_lout\" ]; then
		[ -n \"$l_gout\" ] && l_output=\"$l_output\\n - Grub parameter: \\\"$l_gparameters\\\" exists in: \\\"$l_gpfile\\\"\"
		[ -n \"$l_lout\" ] && l_output=\"$l_output\\n - Grub parameter: \\\"$l_gparameters\\\" exists in: \\\"$(grep -Pls -- \"\\b$l_gparameters\\b\" /boot/loader/entries/*)\\\"\"
	else
		l_output2=\"$l_output2\\n - Grub parameter: \\\"$l_gparameters\\\" is not set\"
	fi

# If l_output2 is not set, then we pass
if [ -z \"$l_output2\" ]; then
	echo -e \"\\n- Audit Result:\\n  ** PASS **\\n$l_output\\n\"
else
	echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n - Reason(s) for audit failure:\\n$l_output2\\n\"
	[ -n \"$l_output\" ] && echo -e \"\\n- Correctly set:\\n$l_output\\n\"
fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.1.4 Ensure audit_backlog_limit is sufficient"
      info        : "In the kernel-level audit subsystem, a socket buffer queue is used to hold audit events. Whenever a new audit event is received, it is logged and prepared to be added to this queue.

The kernel boot parameter audit_backlog_limit=N with N representing the amount of messages, will ensure that a queue cannot grow beyond a certain size. If an audit event is logged which would grow the queue beyond this limit, then a failure occurs and is handled according to the system configuration

If an audit event is logged which would grow the queue beyond the audit_backlog_limit then a failure occurs, auditd records will be lost, and potential malicious activity could go undetected."
      solution    : "Edit /etc/default/grub and add audit_backlog_limit=N to GRUB_CMDLINE_LINUX. The recommended size for N is 8192 or larger.

Example:

GRUB_CMDLINE_LINUX=\"audit_backlog_limit=8192\"

Run the following command to update the grub2 configuration:

# update-grub"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/bin/find /boot -type f -name 'grub.cfg' -exec /bin/grep -Ph -- '^\\h*linux' {} + | /bin/grep -Pv 'audit_backlog_limit=\\d+\\b' | /bin/awk '{print} END { if (NR==0) print \"pass\" }'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "6.2.2.1 Ensure audit log storage size is configured"
      info        : "Configure the maximum size of the audit log file. Once the log reaches the maximum size, it will be rotated and a new log file will be started.

It is important that an appropriate size is determined for log files so that they do not impact the system and audit data is not lost."
      solution    : "Set the following parameter in /etc/audit/auditd.conf in accordance with site policy:

max_log_file = <MB>"
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/etc/audit/auditd.conf"
      regex       : "^[\\s]*max_log_file[\\s]*="
      expect      : "^[\\s]*max_log_file[\\s]*=[\\s]*@MAX_AUDIT_LOG_FILE_SIZE@[\\s]*$"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "6.2.2.2 Ensure audit logs are not automatically deleted"
      info        : "The max_log_file_action setting determines how to handle the audit log file reaching the max file size. A value of keep_logs will rotate the logs but never delete old logs.

In high security contexts, the benefits of maintaining a long audit history exceed the cost of storing the audit history."
      solution    : "Set the following parameter in /etc/audit/auditd.conf:

max_log_file_action = keep_logs"
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/etc/audit/auditd.conf"
      regex       : "^[\\s]*max_log_file_action[\\s]*="
      expect      : "^[\\s]*max_log_file_action[\\s]*=[\\s]*(?i)keep_logs(?-i)[\\s]*$"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "disk_full_action"
          file        : "/etc/audit/auditd.conf"
          regex       : "(?i)^[\\s]*disk_full_action[\\s]*="
          expect      : "(?i)^[\\s]*disk_full_action[\\s]*=[\\s]*(halt|single)[\\s]*$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "disk_error_action = root"
          file        : "/etc/audit/auditd.conf"
          regex       : "(?i)^[\\s]*disk_error_action[\\s]*="
          expect      : "(?i)^[\\s]*disk_error_action[\\s]*=[\\s]*(syslog|single|halt)[\\s]*$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.2.3 Ensure system is disabled when audit logs are full"
          info        : "The auditd daemon can be configured to halt the system or put the system in single user mode, if no free space is available or an error is detected on the partition that holds the audit log files.

The disk_full_action parameter tells the system what action to take when no free space is available on the partition that holds the audit log files. Valid values are ignore syslog rotate exec suspend single and halt

 - ignore the audit daemon will issue a syslog message but no other action is taken
 - syslog the audit daemon will issue a warning to syslog
 - rotate the audit daemon will rotate logs, losing the oldest to free up space
 - exec /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action
 - suspend the audit daemon will stop writing records to the disk
 - single the audit daemon will put the computer system in single user mode
 - halt the audit daemon will shut down the system

The disk_error_action parameter tells the system what action to take when an error is detected on the partition that holds the audit log files. Valid values are ignore syslog exec suspend single and halt

 - ignore the audit daemon will not take any action
 - syslog the audit daemon will issue no more than 5 consecutive warnings to syslog
 - exec /path-to-script will execute the script. You cannot pass parameters to the script
 - suspend the audit daemon will stop writing records to the disk
 - single the audit daemon will put the computer system in single user mode
 - halt the audit daemon will shut down the system

In high security contexts, the risk of detecting unauthorized access or nonrepudiation exceeds the benefit of the system's availability."
          solution    : "Set one of the following parameters in /etc/audit/auditd.conf depending on your local security policies.

disk_full_action = <halt|single>
disk_error_action = <syslog|single|halt>

Example:

disk_full_action = halt
disk_error_action = halt

Impact:

disk_full_action parameter:

 - Set to halt - the auditd daemon will shutdown the system when the disk partition containing the audit logs becomes full.
 - Set to single - the auditd daemon will put the computer system in single user mode when the disk partition containing the audit logs becomes full.

disk_error_action parameter:

 - Set to halt - the auditd daemon will shutdown the system when an error is detected on the partition that holds the audit log files.
 - Set to single - the auditd daemon will put the computer system in single user mode when an error is detected on the partition that holds the audit log files.
 - Set to syslog - the auditd daemon will issue no more than 5 consecutive warnings to syslog when an error is detected on the partition that holds the audit log files."
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-4,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-4,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv8|8.2,CSCv8|8.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.DS-4,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-4,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.3.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "admin_space_left_action"
          file        : "/etc/audit/auditd.conf"
          regex       : "(?i)^[\\s]*admin_space_left_action[\\s]*="
          expect      : "(?i)^[\\s]*admin_space_left_action[\\s]*=[\\s]*(single|halt)[\\s]*$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "space_left_action"
          file        : "/etc/audit/auditd.conf"
          regex       : "(?i)^[\\s]*space_left_action[\\s]*="
          expect      : "(?i)^[\\s]*space_left_action[\\s]*=[\\s]*(email|exec|single|halt)[\\s]*$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.2.4 Ensure system warns when audit logs are low on space"
          info        : "The auditd daemon can be configured to halt the system, put the system in single user mode or send a warning message, if the partition that holds the audit log files is low on space.

The space_left_action parameter tells the system what action to take when the system has detected that it is starting to get low on disk space. Valid values are ignore syslog rotate email exec suspend single and halt

 - ignore the audit daemon does nothing
 - syslog the audit daemon will issue a warning to syslog
 - rotate the audit daemon will rotate logs, losing the oldest to free up space
 - email the audit daemon will send a warning to the email account specified in action_mail_acct as well as sending the message to syslog
 - exec /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action
 - suspend the audit daemon will stop writing records to the disk
 - single the audit daemon will put the computer system in single user mode
 - halt the audit daemon will shut down the system

The admin_space_left_action parameter tells the system what action to take when the system has detected that it is low on disk space. Valid values are ignore syslog rotate email exec suspend single and halt

 - ignore the audit daemon does nothing
 - syslog the audit daemon will issue a warning to syslog
 - rotate the audit daemon will rotate logs, losing the oldest to free up space
 - email the audit daemon will send a warning to the email account specified in action_mail_acct as well as sending the message to syslog
 - exec /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action
 - suspend the audit daemon will stop writing records to the disk
 - single the audit daemon will put the computer system in single user mode
 - halt the audit daemon will shut down the system

In high security contexts, the risk of detecting unauthorized access or nonrepudiation exceeds the benefit of the system's availability."
          solution    : "Set the space_left_action parameter in /etc/audit/auditd.conf to email exec single or halt :

Example:

space_left_action = email

Set the admin_space_left_action parameter in /etc/audit/auditd.conf to single or halt :

Example:

admin_space_left_action = single

Note: A Mail Transfer Agent (MTA) must be installed and configured properly to set space_left_action = email

Impact:

If the admin_space_left_action is set to single the audit daemon will put the computer system in single user mode."
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-4,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-4,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSCv8|8.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.DS-4,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-4,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.3.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl sudoers"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "sudoers.d"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sudoers\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "sudoers"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl sudoers.d"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sudoers\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.1 Ensure changes to system administration scope (sudoers) is collected"
          info        : "Monitor scope changes for system administrators. If the system has been properly configured to force system administrators to log in as themselves first and then use the sudo command to execute privileged commands, it is possible to monitor changes in scope. The file /etc/sudoers or files in /etc/sudoers.d will be written to when the file(s) or related attributes have changed. The audit records will be tagged with the identifier \"scope\".

Changes in the /etc/sudoers and /etc/sudoers.d files can indicate that an unauthorized change has been made to the scope of system administrator activity."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor scope changes for system administrators.

Example:

# printf \"
-w /etc/sudoers -p wa -k scope
-w /etc/sudoers.d -p wa -k scope
\" >> /etc/audit/rules.d/50-scope.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.8,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.10 Ensure successful file system mounts are collected"
              info        : "Monitor the use of the mount system call. The mount (and umount ) system call controls the mounting and unmounting of file systems. The parameters below configure the system to create an audit record when the mount system call is used by a non-privileged user

It is highly unusual for a non privileged user to mount file systems to the system. While tracking mount commands gives the system administrator evidence that external media may have been mounted (based on a review of the source of the mount and confirming it's an external media type), it does not conclusively indicate that data was exported to the media. System administrators who wish to determine if data were exported, would also have to track successful open creat and truncate system calls requiring write access to a file under the mount point of the external media file system. This could give a fair indication that a write occurred. The only way to truly prove it, would be to track successful writes to the external media. Tracking write system calls could quickly fill up the audit log and is not recommended. Recommendations on configuration options to track data export to media is beyond the scope of this document."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful file system mounts.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b32 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
-a always,exit -F arch=b64 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
\" >> /etc/audit/rules.d/50-mounts.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.10 Ensure successful file system mounts are collected"
              info        : "Monitor the use of the mount system call. The mount (and umount ) system call controls the mounting and unmounting of file systems. The parameters below configure the system to create an audit record when the mount system call is used by a non-privileged user

It is highly unusual for a non privileged user to mount file systems to the system. While tracking mount commands gives the system administrator evidence that external media may have been mounted (based on a review of the source of the mount and confirming it's an external media type), it does not conclusively indicate that data was exported to the media. System administrators who wish to determine if data were exported, would also have to track successful open creat and truncate system calls requiring write access to a file under the mount point of the external media file system. This could give a fair indication that a write occurred. The only way to truly prove it, would be to track successful writes to the external media. Tracking write system calls could quickly fill up the audit log and is not recommended. Recommendations on configuration options to track data export to media is beyond the scope of this document."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful file system mounts.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b32 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
-a always,exit -F arch=b64 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
\" >> /etc/audit/rules.d/50-mounts.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl utmp"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/run\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "utmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/run\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "btmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/log\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl wtmp"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/log\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl btmp"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/log\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "wtmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/log\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.11 Ensure session initiation information is collected"
          info        : "Monitor session initiation events. The parameters in this section track changes to the files associated with session events.

 - /var/run/utmp - tracks all currently logged in users.
 - /var/log/wtmp - file tracks logins, logouts, shutdown, and reboot events.
 - /var/log/btmp - keeps track of failed login attempts and can be read by entering the command /usr/bin/last -f /var/log/btmp

All audit records will be tagged with the identifier \"session.\"

Monitoring these files for changes could alert a system administrator to logins occurring at unusual hours, which could indicate intruder activity (i.e. a user logging in at a time when they do not normally log in)."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor session initiation information.

Example:

# printf \"
-w /var/run/utmp -p wa -k session
-w /var/log/wtmp -p wa -k session
-w /var/log/btmp -p wa -k session
\" >> /etc/audit/rules.d/50-session.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv7|16.13,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "faillock"
          cmd         : "/bin/awk '/^ *-w/ && /\\/var\\/run\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl lastlog"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ && /\\/var\\/log\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl faillock"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ && /\\/var\\/run\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "lastlog"
          cmd         : "/bin/awk '/^ *-w/ && /\\/var\\/log\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.12 Ensure login and logout events are collected"
          info        : "Monitor login and logout events. The parameters below track changes to files associated with login/logout events.

 - /var/log/lastlog - maintain records of the last time a user successfully logged in.
 - /var/run/faillock - directory maintains records of login failures via the pam_faillock module.

Monitoring login/logout events could provide a system administrator with information associated with brute force attacks against user logins."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor login and logout events.

Example:

# printf \"
-w /var/log/lastlog -p wa -k logins
-w /var/run/faillock -p wa -k logins
\" >> /etc/audit/rules.d/50-login.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv7|16.11,CSCv7|16.13,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.13 Ensure file deletion events by users are collected"
              info        : "Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for:

 - unlink - remove a file
 - unlinkat - remove a file attribute
 - rename - rename a file
 - renameat rename a file attributesystem calls and tags them with the identifier \"delete\".

Monitoring these calls from non-privileged users could provide a system administrator with evidence that inappropriate removal of files and file attributes associated with protected files is occurring. While this audit option will look at all events, system administrators will want to look for specific privileged files that are being deleted or altered."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor file deletion events by users.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
-a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
\" >> /etc/audit/rules.d/50-delete.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.13 Ensure file deletion events by users are collected"
              info        : "Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for:

 - unlink - remove a file
 - unlinkat - remove a file attribute
 - rename - rename a file
 - renameat rename a file attributesystem calls and tags them with the identifier \"delete\".

Monitoring these calls from non-privileged users could provide a system administrator with evidence that inappropriate removal of files and file attributes associated with protected files is occurring. While this audit option will look at all events, system administrators will want to look for specific privileged files that are being deleted or altered."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor file deletion events by users.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
-a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
\" >> /etc/audit/rules.d/50-delete.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl - /etc/apparmor.d/"
          cmd         : "/sbin/auditctl -l 2>/dev/null | /bin/awk '/^ *-w/ && /\\/etc\\/apparmor.d/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/apparmor/"
          cmd         : "/bin/awk '/^ *-w/ && /\\/etc\\/apparmor/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/apparmor.d/"
          cmd         : "/bin/awk '/^ *-w/ && /\\/etc\\/apparmor.d/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl - /etc/apparmor/"
          cmd         : "/sbin/auditctl -l 2>/dev/null | /bin/awk '/^ *-w/ && /\\/etc\\/apparmor/ && / +-p *wa/ && (/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected"
          info        : "Monitor AppArmor, an implementation of mandatory access controls. The parameters below monitor any write access (potential additional, deletion or modification of files in the directory) or attribute changes to the /etc/apparmor/ and /etc/apparmor.d/ directories.

Note: If a different Mandatory Access Control method is used, changes to the corresponding directories should be audited.

Changes to files in the /etc/apparmor/ and /etc/apparmor.d/ directories could indicate that an unauthorized user is attempting to modify access controls and change security contexts, leading to a compromise of the system."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the system's Mandatory Access Controls.

Example:

# printf \"
-w /etc/apparmor/ -p wa -k MAC-policy
-w /etc/apparmor.d/ -p wa -k MAC-policy
\" >> /etc/audit/rules.d/50-MAC-policy.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are collected"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the chcon command.

The chcon command is used to change file security context. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the chcon command.

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are collected"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the setfacl command

This utility sets Access Control Lists (ACLs) of files and directories. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the setfacl command.

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are collected"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the chacl command.

chacl is an IRIX-compatibility command, and is maintained for those users who are familiar with its use from either XFS or IRIX.

chacl changes the ACL(s) for a file or directory. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the chacl command.

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/sbin\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/sbin\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are collected"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the usermod command.

The usermod command modifies the system account files to reflect the changes that are specified on the command line. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the usermod command.

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k usermod
\" >> /etc/audit/rules.d/50-usermod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "rules path"
          cmd         : "#!/bin/bash

{
  UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)
  [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\
  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\
  &&/ -F *auid>=${UID_MIN}/ \\
  &&/ -F *perm=x/ \\
  &&/ -F *path=\\/usr\\/bin\\/kmod/ \\
  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\
  || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"
}| /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules arch"
          cmd         : "#!/bin/bash

{
  awk '/^ *-a *always,exit/ \\
  &&/ -F *arch=b(32|64)/ \\
  &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\
  &&/ -S/ \\
  &&(/init_module/ \\
  ||/finit_module/ \\
  ||/delete_module/ \\
  ||/create_module/ \\
  ||/query_module/) \\
  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
}| /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl path"
          cmd         : "#!/bin/bash

{
  UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)
  [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\
  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\
  &&/ -F *auid>=${UID_MIN}/ \\
  &&/ -F *perm=x/ \\
  &&/ -F *path=\\/usr\\/bin\\/kmod/ \\
  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\
  || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"
}| /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl arch"
          cmd         : "#!/bin/bash

{
  auditctl -l | awk '/^ *-a *always,exit/ \\
  &&/ -F *arch=b(32|64)/ \\
  &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\
  &&/ -S/ \\
  &&(/init_module/ \\
  ||/finit_module/ \\
  ||/delete_module/ \\
  ||/create_module/ \\
  ||/query_module/) \\
  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'
}| /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "symlinks"
          cmd         : "#!/bin/bash

{
  fail=0
  a_files=(\"/usr/sbin/lsmod\" \"/usr/sbin/rmmod\" \"/usr/sbin/insmod\" \"/usr/sbin/modinfo\" \"/usr/sbin/modprobe\" \"/usr/sbin/depmod\")
  for l_file in \"${a_files[@]}\"; do
    if [ \"$(readlink -f \"$l_file\")\" = \"$(readlink -f /bin/kmod)\" ]; then
      printf \"OK: \\\"$l_file\\\"\\n\"
    else
      printf \"Issue with symlink for file: \\\"$l_file\\\"\\n\"
      fail=1
    fi
  done
  if [ $fail -eq 0 ]; then
    printf \"pass\"
  else
    printf \"fail\"
  fi
}"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.19 Ensure kernel module loading unloading and modification is collected"
          info        : "Monitor the loading and unloading of kernel modules. All the loading / listing / dependency checking of modules is done by kmod via symbolic links.

The following system calls control loading and unloading of modules:

 - init_module - load a module
 - finit_module - load a module (used when the overhead of using cryptographically signed modules to determine the authenticity of a module can be avoided)
 - delete_module - delete a module
 - create_module - create a loadable module entry
 - query_module - query the kernel for various bits pertaining to modules

Any execution of the loading and unloading module programs and system calls will trigger an audit record with an identifier of modules

Monitoring the use of all the various ways to manipulate kernel modules could provide system administrators with evidence that an unauthorized change was made to a kernel module, possibly compromising the security of the system."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor kernel module modification.

Example:

#!/usr/bin/env bash

{
  UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
  [ -n \"${UID_MIN}\" ] && printf \"
  -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules
  -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules
  \" >> /etc/audit/rules.d/50-kernel_modules.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.2 Ensure actions as another user are always logged"
              info        : "sudo provides users with temporary elevated privileges to perform operations, either as the superuser or another user.

Creating an audit log of users with temporary elevated privileges and the operation(s) they performed is essential to reporting. Administrators will want to correlate the events written to the audit trail with the records written to sudo 's logfile to verify if unauthorized commands have been executed."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor elevated privileges.

Example:

# printf \"
-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
\" >> /etc/audit/rules.d/50-user_emulation.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.2 Ensure actions as another user are always logged"
              info        : "sudo provides users with temporary elevated privileges to perform operations, either as the superuser or another user.

Creating an audit log of users with temporary elevated privileges and the operation(s) they performed is essential to reporting. Administrators will want to correlate the events written to the audit trail with the records written to sudo 's logfile to verify if unauthorized commands have been executed."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor elevated privileges.

Example:

# printf \"
-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
\" >> /etc/audit/rules.d/50-user_emulation.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.3.20 Ensure the audit configuration is immutable"
      info        : "Set system audit so that audit rules cannot be modified with auditctl Setting the flag \"-e 2\" forces audit to be put in immutable mode. Audit changes can only be made on system reboot.

Note: This setting will require the system to be rebooted to update the active auditd configuration settings.

In immutable mode, unauthorized users cannot execute changes to the audit system to potentially hide malicious activity and then put the audit rules back. Users would most likely notice a system reboot and that could alert administrators of an attempt to make unauthorized audit changes."
      solution    : "Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line -e 2 at the end of the file:

Example:

# printf '\n%s' \"-e 2\" >> /etc/audit/rules.d/99-finalize.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,800-53r5|MP-2,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(b),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|6.2,CSCv7|6.3,CSCv8|3.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-2,CSF|PR.PT-3,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T3.6.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,SWIFT-CSCv1|6.4,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/bin/grep -Ph -- '^\\h*-e\\h+2\\b' /etc/audit/rules.d/*.rules | /bin/tail -1"
      expect      : "^[\\s]*-e[\\s]+2[\\s]*$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.3.21 Ensure the running and on disk configuration is the same"
      info        : "The Audit system have both on disk and running configuration. It is possible for these configuration settings to differ.

Note: Due to the limitations of augenrules and auditctl it is not absolutely guaranteed that loading the rule sets via augenrules --load will result in all rules being loaded or even that the user will be informed if there was a problem loading the rules.

Configuration differences between what is currently running and what is on disk could cause unexpected problems or may give a false impression of compliance requirements."
      solution    : "If the rules are not aligned across all three () areas, run the following command to merge and load all rules:

# augenrules --load

Check if reboot is required.

if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then echo \"Reboot required to load rules\"; fi"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/sbin/augenrules --check"
      expect      : "^[\\s]*/sbin/augenrules:[\\s]*No change[\\s]*$"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl sudo log"
          cmd         : "#!/bin/bash
      {
        SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g')
        [ -n \"${SUDO_LOG_FILE}\" ] && auditctl -l | awk \"/^ *-w/ \\
        &&/\"${SUDO_LOG_FILE}\"/ \\
        &&/ +-p *wa/ \\
        &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\
        || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\\n\"
      } | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "sudo log"
          cmd         : "#!/bin/bash
      {
        SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g')
        [ -n \"${SUDO_LOG_FILE}\" ] && awk \"/^ *-w/ \\
        &&/\"${SUDO_LOG_FILE}\"/ \\
        &&/ +-p *wa/ \\
        &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\
        || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\\n\"
      } | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "^pass$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.3 Ensure events that modify the sudo log file are collected"
          info        : "Monitor the sudo log file. If the system has been properly configured to disable the use of the su command and force all administrators to have to log in first and then use sudo to execute privileged commands, then all administrator commands will be logged to /var/log/sudo.log Any time a command is executed, an audit event will be triggered as the /var/log/sudo.log file will be opened for write and the executed administration command will be written to the log.

Changes in /var/log/sudo.log indicate that an administrator has executed a command or the log file itself has been tampered with. Administrators will want to correlate the events written to the audit trail with the records written to /var/log/sudo.log to verify if unauthorized commands have been executed."
          solution    : "Note: This recommendation requires that the sudo logfile is configured. See guidance provided in the recommendation \"Ensure sudo log file exists\"

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the sudo log file.

Example:

# {
SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g')
[ -n \"${SUDO_LOG_FILE}\" ] && printf \"
-w ${SUDO_LOG_FILE} -p wa -k sudo_log_file
\" >> /etc/audit/rules.d/50-sudo.rules || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\n\"
}

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday x32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime x32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/localtime"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/localtime"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex x64"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.4 Ensure events that modify date and time information are collected"
              info        : "Capture events where the system date and/or time has been modified. The parameters in this section are set to determine if the;

 - adjtimex - tune kernel clock
 - settimeofday - set time using timeval and timezone structures
 - stime - using seconds since 1/1/1970
 - clock_settime - allows for the setting of several internal clocks and timers

system calls have been executed. Further, ensure to write an audit record to the configured audit log file upon exit, tagging the records with a unique identifier such as \"time-change\".

Unexpected changes in system date and/or time could be a sign of malicious activity on the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify date and time information.

Example:

# printf \"
-a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change
-a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change
-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change
-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change
-w /etc/localtime -p wa -k time-change
\" >> /etc/audit/rules.d/50-time-change.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/localtime"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/localtime"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex b32"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.4 Ensure events that modify date and time information are collected"
              info        : "Capture events where the system date and/or time has been modified. The parameters in this section are set to determine if the;

 - adjtimex - tune kernel clock
 - settimeofday - set time using timeval and timezone structures
 - stime - using seconds since 1/1/1970
 - clock_settime - allows for the setting of several internal clocks and timers

system calls have been executed. Further, ensure to write an audit record to the configured audit log file upon exit, tagging the records with a unique identifier such as \"time-change\".

Unexpected changes in system date and/or time could be a sign of malicious activity on the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify date and time information.

Example:

# printf \"
-a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change
-a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change
-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change
-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change
-w /etc/localtime -p wa -k time-change
\" >> /etc/audit/rules.d/50-time-change.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/network/"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/network\\// &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/issue.net"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - b32 setdomainname"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/setdomainname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/networks"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/networks/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl b64 setdomainname"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/setdomainname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl b64 sethostname"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - b64 setdomainname"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/setdomainname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl b32 sethostname"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl - /etc/network/"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/network / &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/issue.net"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/issue"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue / &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "b32 sethostname"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl - /etc/networks"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/networks/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/hosts"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "b64 sethostname"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/issue"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue / &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "rules - /etc/netplan/"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/netplan\\// &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl b32 setdomainname"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/setdomainname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/hosts"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl - /etc/network/"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/netplan/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.5 Ensure events that modify the system's network environment are collected"
          info        : "Record changes to network environment files or system calls. The below parameters monitors the following system calls, and write an audit event on system call exit:

 - sethostname - set the systems host name
 - setdomainname - set the systems domain name

The files being monitored are:

 - /etc/issue and /etc/issue.net - messages displayed pre-login
 - /etc/hosts - file containing host names and associated IP addresses
 - /etc/networks - symbolic names for networks
 - /etc/network/ - directory containing network interface scripts and configurations files
 - /etc/netplan/ - central location for YAML networking configurations files

Monitoring system events that change network environments, such as sethostname and setdomainname helps identify unauthorized alterations to host and domain names, which could compromise security settings reliant on these names. Changes to /etc/hosts can signal unauthorized attempts to alter machine associations with IP addresses, potentially redirecting users and processes to unintended destinations. Surveillance of /etc/issue and /etc/issue.net is crucial to detect intruders inserting false information to deceive users. Monitoring /etc/network/ reveals modifications to network interfaces or scripts that may jeopardize system availability or security. Additionally, tracking changes in the /etc/netplan/ directory ensures swift detection of unauthorized adjustments to network configurations. All audit records should be appropriately tagged for relevance"
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the system's network environment.

Example:

# printf \"
-a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
-a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
-w /etc/issue -p wa -k system-locale
-w /etc/issue.net -p wa -k system-locale
-w /etc/hosts -p wa -k system-locale
-w /etc/networks -p wa -k system-locale
-w /etc/network/ -p wa -k system-locale
-w /etc/netplan/ -p wa -k system-locale
\" >> /etc/audit/rules.d/50-system_locale.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "RUNNING=$(/sbin/auditctl -l); [ -n \"${RUNNING}\" ] && for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do printf -- \"${RUNNING}\" | /bin/grep -q \"${PRIVILEGED}\" && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in running configuration.\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'"
          expect      : "^Pass - No warning entries found$"
          timeout     : "@FIND_TIMEOUT@"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d"
          cmd         : "for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do /bin/grep -qr \"${PRIVILEGED}\" /etc/audit/rules.d && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in on disk configuration.\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'"
          expect      : "^Pass - No warning entries found$"
          timeout     : "@FIND_TIMEOUT@"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.6 Ensure use of privileged commands are collected"
          info        : "Monitor privileged programs, those that have the setuid and/or setgid bit set on execution, to determine if unprivileged users are running these commands.

Execution of privileged commands by non-privileged users could be an indication of someone trying to gain unauthorized access to the system."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor the use of privileged commands.

Example script:

#!/usr/bin/env bash

{
  UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
  AUDIT_RULE_FILE=\"/etc/audit/rules.d/50-privileged.rules\"
  NEW_DATA=()
  for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\" | awk '{print $1}'); do
    readarray -t DATA < <(find \"${PARTITION}\" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print \"-a always,exit -F path=\" $1 \" -F perm=x -F auid>=\"UID_MIN\" -F auid!=unset -k privileged\" }')
      for ENTRY in \"${DATA[@]}\"; do
        NEW_DATA+=(\"${ENTRY}\")
      done
  done
  readarray &> /dev/null -t OLD_DATA < \"${AUDIT_RULE_FILE}\"
  COMBINED_DATA=( \"${OLD_DATA[@]}\" \"${NEW_DATA[@]}\" )
  printf '%s\n' \"${COMBINED_DATA[@]}\" | sort -u > \"${AUDIT_RULE_FILE}\"
}

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

Special mount points

If there are any special mount points that are not visible by default from just scanning / change the PARTITION variable to the appropriate partition and re-run the remediation.

Impact:

Both the audit and remediation section of this recommendation will traverse all mounted file systems that is not mounted with either noexec or nosuid mount options. If there are large file systems without these mount options, such traversal will be significantly detrimental to the performance of the system.

Before running either the audit or remediation section, inspect the output of the following command to determine exactly which file systems will be traversed:

# findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\"

To exclude a particular file system due to adverse performance impacts, update the audit and remediation sections by adding a sufficiently unique string to the grep statement. The above command can be used to test the modified exclusions."
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.7 Ensure unsuccessful file access attempts are collected"
              info        : "Monitor for unsuccessful attempts to access files. The following parameters are associated with system calls that control files:

 - creation - creat
 - opening - open openat
 - truncation - truncate ftruncate

An audit log record will only be written if all of the following criteria is met for the user when trying to access a file:

 - a non-privileged user (auid>=UID_MIN)
 - is not a Daemon event (auid=4294967295/unset/-1)
 - if the system call returned EACCES (permission denied) or EPERM (some other permanent error associated with the specific system call)

Failed attempts to open, create or truncate files could be an indication that an individual or process is trying to gain unauthorized access to the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor unsuccessful file access attempts.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
\" >> /etc/audit/rules.d/50-access.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.7 Ensure unsuccessful file access attempts are collected"
              info        : "Monitor for unsuccessful attempts to access files. The following parameters are associated with system calls that control files:

 - creation - creat
 - opening - open openat
 - truncation - truncate ftruncate

An audit log record will only be written if all of the following criteria is met for the user when trying to access a file:

 - a non-privileged user (auid>=UID_MIN)
 - is not a Daemon event (auid=4294967295/unset/-1)
 - if the system call returned EACCES (permission denied) or EPERM (some other permanent error associated with the specific system call)

Failed attempts to open, create or truncate files could be an indication that an individual or process is trying to gain unauthorized access to the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor unsuccessful file access attempts.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
\" >> /etc/audit/rules.d/50-access.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/shadow"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/nsswitch.conf"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/nsswitch\\.conf/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/pam.conf"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/pam\\.conf/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/gshadow"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/security/opasswd"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/security\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/group"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/passwd"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/pam.d"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/pam\\.d/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/shadow"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/gshadow"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/nsswitch.conf"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/nsswitch\\.conf/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/passwd"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/security/opasswd"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/security\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/pam.d"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/pam\\.d/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/group"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/pam.conf"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/pam\\.conf/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "6.2.3.8 Ensure events that modify user/group information are collected"
          info        : "Record events affecting the modification of user or group information, including that of passwords and old passwords if in use.

 - /etc/group - system groups
 - /etc/passwd - system users
 - /etc/gshadow - encrypted password for each group
 - /etc/shadow - system user passwords
 - /etc/security/opasswd - storage of old passwords if the relevant PAM module is in use
 - /etc/nsswitch.conf - file configures how the system uses various databases and name resolution mechanisms
 - /etc/pam.conf - file determines the authentication services to be used, and the order in which the services are used.
 - /etc/pam.d - directory contains the PAM configuration files for each PAM-aware application.

The parameters in this section will watch the files to see if they have been opened for write or have had attribute changes (e.g. permissions) and tag them with the identifier \"identity\" in the audit log file.

Unexpected changes to these files could be an indication that the system has been compromised and that an unauthorized user is attempting to hide their activities or compromise additional accounts."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify user/group information.

Example:

# printf \"
-w /etc/group -p wa -k identity
-w /etc/passwd -p wa -k identity
-w /etc/gshadow -p wa -k identity
-w /etc/shadow -p wa -k identity
-w /etc/security/opasswd -p wa -k identity
-w /etc/nsswitch.conf -p wa -k identity
-w /etc/pam.conf -p wa -k identity
-w /etc/pam.d -p wa -k identity
\" >> /etc/audit/rules.d/50-identity.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.8,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.9 Ensure discretionary access control permission modification events are collected"
              info        : "Monitor changes to file permissions, attributes, ownership and group. The parameters in this section track changes for system calls that affect file permissions and attributes. The following commands and system calls effect the permissions, ownership and various attributes of files.

 - chmod
 - fchmod
 - fchmodat
 - chown
 - fchown
 - fchownat
 - lchown
 - setxattr
 - lsetxattr
 - fsetxattr
 - removexattr
 - lremovexattr
 - fremovexattr

In all cases, an audit record will only be written for non-system user ids and will ignore Daemon events. All audit records will be tagged with the identifier \"perm_mod.\"

Monitoring for changes in file attributes could alert a system administrator to activity that could indicate intruder activity or policy violation."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor discretionary access control permission modification events.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
\" >> /etc/audit/rules.d/50-perm_mod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "6.2.3.9 Ensure discretionary access control permission modification events are collected"
              info        : "Monitor changes to file permissions, attributes, ownership and group. The parameters in this section track changes for system calls that affect file permissions and attributes. The following commands and system calls effect the permissions, ownership and various attributes of files.

 - chmod
 - fchmod
 - fchmodat
 - chown
 - fchown
 - fchownat
 - lchown
 - setxattr
 - lsetxattr
 - fsetxattr
 - removexattr
 - lremovexattr
 - fremovexattr

In all cases, an audit record will only be written for non-system user ids and will ignore Daemon events. All audit records will be tagged with the identifier \"perm_mod.\"

Monitoring for changes in file attributes could alert a system administrator to activity that could indicate intruder activity or policy violation."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor discretionary access control permission modification events.

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
\" >> /etc/audit/rules.d/50-perm_mod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.1 Ensure audit log files mode is configured"
      info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
      solution    : "Run the following command to remove more permissive mode than 0640 from audit log files:

# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f -perm /0137 -exec chmod u-x,g-wx,o-rwx {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_perm_mask=\"0137\"
   if [ -e \"/etc/audit/auditd.conf\" ]; then
      l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"
      if [ -d \"$l_audit_log_directory\" ]; then
         l_maxperm=\"$(printf '%o' $(( 0777 & ~$l_perm_mask )) )\"
         a_files=()
         while IFS= read -r -d $'\\0' l_file; do
            [ -e \"$l_file\" ] && a_files+=(\"$l_file\")
         done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f -perm /\"$l_perm_mask\" -print0)
		 if (( \"${#a_files[@]}\" > 0 )); then
            for l_file in \"${a_files[@]}\"; do
               l_file_mode=\"$(stat -Lc '%#a' \"$l_file\")\"
               echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - File: \\\"$l_file\\\" is mode: \\\"$l_file_mode\\\"\\n     (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"
            done
         else
            echo -e \"\\n- Audit Result:\\n  ** PASS **\\n  - All files in \\\"$l_audit_log_directory\\\" are mode: \\\"$l_maxperm\\\" or more restrictive\"
         fi
      else
         echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"
      fi
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n  - ** Verify auditd is installed **\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "6.2.4.10 Ensure audit tools group owner is configured"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to change group ownership to the groop root :

# chgrp root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      group       : "root"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.2 Ensure audit log files owner is configured"
      info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
      solution    : "Run the following command to configure the audit log files to be owned by the root user:

# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f ! -user root -exec chown root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\"
   if [ -e \"/etc/audit/auditd.conf\" ]; then
      l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"
      if [ -d \"$l_audit_log_directory\" ]; then
         while IFS= read -r -d $'\\0' l_file; do
            l_output2=\"$l_output2\\n  - File: \\\"$l_file\\\" is owned by user: \\\"$(stat -Lc '%U' \"$l_file\")\\\"\\n     (should be owned by user: \\\"root\\\")\\n\"
         done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f ! -user root -print0)
      else
         l_output2=\"$l_output2\\n  - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"
      fi
   else
      l_output2=\"$l_output2\\n  - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n  - ** Verify auditd is installed **\"
   fi
   if [ -z \"$l_output2\" ]; then
      l_output=\"$l_output\\n  - All files in \\\"$l_audit_log_directory\\\" are owned by user: \\\"root\\\"\\n\"
      echo -e \"\\n- Audit Result:\\n  ** PASS **\\n - * Correctly configured * :$l_output\"
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.3 Ensure audit log files group owner is configured"
      info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
      solution    : "Run the following command to configure the audit log files to be group owned by adm :

# find $(dirname $(awk -F\"=\" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +

Run the following command to set the log_group parameter in the audit configuration file to log_group = adm :

# sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/' /etc/audit/auditd.conf

Run the following command to restart the audit daemon to reload the configuration file:

# systemctl restart auditd"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
  l_output=\"\" l_output2=\"\"
  if [ -e \"/etc/audit/auditd.conf\" ]; then
    l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"
    l_audit_log_group=\"$(awk -F= '/^\\s*log_group\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\"
    if grep -Pq -- '^\\h*(root|adm)\\h*$' <<< \"$l_audit_log_group\"; then
      l_output=\"$l_output\\n - Log file group correctly set to: \\\"$l_audit_log_group\\\" in \\\"/etc/audit/auditd.conf\\\"\"
    else
      l_output2=\"$l_output2\\n - Log file group is set to: \\\"$l_audit_log_group\\\" in \\\"/etc/audit/auditd.conf\\\"\\n (should be set to group: \\\"root or adm\\\")\\n\"
    fi
    if [ -d \"$l_audit_log_directory\" ]; then
      while IFS= read -r -d $'\\0' l_file; do
        l_output2=\"$l_output2\\n - File: \\\"$l_file\\\" is group owned by group: \\\"$(stat -Lc '%G' \"$l_file\")\\\"\\n (should be group owned by group: \\\"root or adm\\\")\\n\"
      done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f \\( ! -group root -a ! -group adm \\) -print0)
    else
      l_output2=\"$l_output2\\n - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"
    fi
  else
    l_output2=\"$l_output2\\n - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n - ** Verify auditd is installed **\"
  fi
  if [ -z \"$l_output2\" ]; then
    l_output=\"$l_output\\n - All files in \\\"$l_audit_log_directory\\\" are group owned by group: \\\"root or adm\\\"\\n\"
    echo -e \"\\n- Audit Result:\\n ** PASS **\\n - * Correctly configured * :$l_output\"
  else
    echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"
    [ -n \"$l_output\" ] && echo -e \" - * Correctly configured * :\\n$l_output\\n\"
  fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.4 Ensure the audit log file directory mode is configured"
      info        : "The audit log directory contains audit log files.

Audit information includes all information including: audit records, audit settings and audit reports. This information is needed to successfully audit system activity. This information must be protected from unauthorized modification or deletion. If this information were to be compromised, forensic analysis and discovery of the true source of potentially malicious system activity is impossible to achieve."
      solution    : "Run the following command to configure the audit log directory to have a mode of \"0750\" or less permissive:

# chmod g-w,o-rwx \"$(dirname \"$(awk -F= '/^\s*log_file\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\""
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   l_perm_mask=\"0027\"
   if [ -e \"/etc/audit/auditd.conf\" ]; then
      l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"
      if [ -d \"$l_audit_log_directory\" ]; then
         l_maxperm=\"$(printf '%o' $(( 0777 & ~$l_perm_mask )) )\"
         l_directory_mode=\"$(stat -Lc '%#a' \"$l_audit_log_directory\")\"
         if [ $(( $l_directory_mode & $l_perm_mask )) -gt 0 ]; then
            echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - Directory: \\\"$l_audit_log_directory\\\" is mode: \\\"$l_directory_mode\\\"\\n     (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"
         else
            echo -e \"\\n- Audit Result:\\n  ** PASS **\\n  - Directory: \\\"$l_audit_log_directory\\\" is mode: \\\"$l_directory_mode\\\"\\n     (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"
         fi
      else
         echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"
      fi
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n  - File: \\\"/etc/audit/auditd.conf\\\" not found\\n  - ** Verify auditd is installed **\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.5 Ensure audit configuration files mode is configured"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to remove more permissive mode than 0640 from the audit configuration files:

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) -exec /bin/stat -Lc \"%n %a\" {} + | /bin/grep -Pv -- '^\\h*\\H+\\h*([0,2,4,6][0,4]0)\\h*$' | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.6 Ensure audit configuration files owner is configured"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to change ownership to root user:

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -user root | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.2.4.7 Ensure audit configuration files group owner is configured"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to change group to root :

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -group root | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "6.2.4.8 Ensure audit tools mode is configured"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to remove more permissive mode from the audit tools:

# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      mask        : "022"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "6.2.4.9 Ensure audit tools owner is configured"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to change the owner of the audit tools to the root user:

# chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      owner       : "root"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.3.3 Ensure cryptographic mechanisms are used to protect the integrity of audit tools"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

aide.conf is case-sensitive. Leading and trailing white spaces are ignored. Each config lines must end with new line.

AIDE uses the backslash character () as escape character for ' ' (space), '@' and '' (backslash) (e.g. '\ ' or '@'). To literally match a '' in a file path with a regular expression you have to escape the backslash twice (i.e. '\\').

There are three types of lines in aide.conf :

 - The configuration options which are used to set configuration parameters and define groups.
 - (restricted) rules that are used to indicate which files are added to the database.
 - Macro lines define or undefine variables within the config file. Note: Lines beginning with # are ignored as comments.

@@include

<FILE>

- Include

<FILE>

.

 - The content of the file is used as if it were inserted in this part of the config file.
 - The maximum depth of nested includes is 16.

`@@include

<DIRECTORY>

<REGEX>

- [RULE_PREFIX] (added in AIDE v0.17)

 - Include all (regular) files found in <DIRECTORY> matching regular expression <REGEX> (sub-directories are ignored).
 - The file are included in lexical sort order.
 - If RULE_PREFIX is set, all rules included by the statement are prefixed with given <RULE_PREFIX> (added in AIDE v0.18). Prefixes from nested include statements are concatenated.
 - The content of the files is used as if it were inserted in this part of the config file.

@x_include :

 - is identical to @@include except that if a config file is executable is is run and the output is used as config.
 - If the executable file exits with status greater than zero or writes to stderr aide stops with an error.
 - For security reasons

<DIRECTORY>

and each executable config file must be owned by the current user or root. They must not be group- or world-writable.
 - @@x_include _<FILE>_ (added in AIDE v0.17):
 - `@@x_include

<DIRECTORY>

<REGEX>

[RULE_PREFIX] (added in AIDE v0.17)

@@x_include_setenv

<VAR>

<VALUE>

(added in AIDE v0.17)

 - Adds the variable

<VAR>

with the value

<VALUE>

to the environment used for config file execution.
 - Environment variable names are limited to alphanumeric characters (A-Za-z0-9) and the underscore '_' and must not begin with a digit.

Protecting the integrity of the tools used for auditing purposes is a critical step toward ensuring the integrity of audit information. Audit information includes all information (e.g., audit records, audit settings, and audit reports) needed to successfully audit information system activity.

Attackers may replace the audit tools or inject code into the existing tools with the purpose of providing the capability to hide or erase system activity from the audit logs.

Audit tools should be cryptographically signed in order to provide the capability to identify when the audit tools have been modified, manipulated, or replaced. An example is a checksum hash of the file or files."
      solution    : "Run the following command to determine the absolute path to the non-symlinked version on the audit tools:

# readlink -f /sbin

The output will be either /usr/sbin - OR - /sbin Ensure the correct path is used.

Edit /etc/aide/aide.conf and add or update the following selection lines replacing <PATH> with the correct path returned in the command above:

# Audit Tools
<PATH>/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512
<PATH>/auditd p+i+n+u+g+s+b+acl+xattrs+sha512
<PATH>/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512
<PATH>/aureport p+i+n+u+g+s+b+acl+xattrs+sha512
<PATH>/autrace p+i+n+u+g+s+b+acl+xattrs+sha512
<PATH>/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512

Example

# printf '%s\n' \"\" \"# Audit Tools\" \"$(readlink -f /sbin/auditctl) p+i+n+u+g+s+b+acl+xattrs+sha512\" \"$(readlink -f /sbin/auditd) p+i+n+u+g+s+b+acl+xattrs+sha512\" \"$(readlink -f /sbin/ausearch) p+i+n+u+g+s+b+acl+xattrs+sha512\" \"$(readlink -f /sbin/aureport) p+i+n+u+g+s+b+acl+xattrs+sha512\" \"$(readlink -f /sbin/autrace) p+i+n+u+g+s+b+acl+xattrs+sha512\" \"$(readlink -f /sbin/augenrules) p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide/aide.conf

Note: - IF - /etc/aide/aide.conf includes a @@x_include statement:

 -

<DIRECTORY>

and each executable config file must be owned by the current user or root
 - They must not be group or world-writable

Example:

@@x_include /etc/aide.conf.d ^[a-zA-Z0-9_-]+$"
      reference   : "800-53|SI-7,800-53r5|SI-7,CSF|PR.DS-6,CSF2.0|DE.CM-09,CSF2.0|ID.RA-09,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.PS-02,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(c)(1),HIPAA|164.312(c)(2),HIPAA|164.312(e)(2)(i),ITSG-33|SI-7,ITSG-33|SI-7a.,LEVEL|2A,NESA|T3.4.1,NESA|T7.3.2,NESA|T7.3.3,PCI-DSSv3.2.1|10.5.5,QCSC-v1|3.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
      cmd         : "#!/bin/bash

{
   a_output=() a_output2=() l_tool_dir=\"$(readlink -f /sbin)\";
   a_items=(\"p\" \"i\" \"n\" \"u\" \"g\" \"s\" \"b\" \"acl\" \"xattrs\" \"sha512\")
   l_aide_cmd=\"$(whereis aide | awk '{print $2}')\";
   a_audit_files=(\"auditctl\" \"auditd\" \"ausearch\" \"aureport\" \"autrace\" \"augenrules\")
   if [ -f \"$l_aide_cmd\" ] && command -v \"$l_aide_cmd\" &>/dev/null; then
      a_aide_conf_files=(\"$(find -L /etc -type f -name 'aide.conf')\")
      f_file_par_chk()
      {
         a_out2=()
         for l_item in \"${a_items[@]}\"; do
            ! grep -Psiq -- '(\\h+|\\+)'\"$l_item\"'(\\h+|\\+)' <<< \"$l_out\" && \\
            a_out2+=(\"  - Missing the \\\"$l_item\\\" option\")
         done
         if [ \"${#a_out2[@]}\" -gt \"0\" ]; then
            a_output2+=(\" - Audit tool file: \\\"$l_file\\\"\" \"${a_out2[@]}\")
         else
            a_output+=(\" - Audit tool file: \\\"$l_file\\\" includes:\" \"   \\\"${a_items[*]}\\\"\")
         fi
      }
      for l_file in \"${a_audit_files[@]}\"; do
         if [ -f \"$l_tool_dir/$l_file\" ]; then
            l_out=\"$(\"$l_aide_cmd\" --config \"${a_aide_conf_files[@]}\" -p f:\"$l_tool_dir/$l_file\")\";
            f_file_par_chk
         else
            a_output+=(\"  - Audit tool file \\\"$l_file\\\" doesn't exist\")
         fi
      done
   else
      a_output2+=(\"  - The command \\\"aide\\\" was not found\"  \"    Please install AIDE\")
   fi
   if [ \"${#a_output2[@]}\" -le 0 ]; then
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** PASS **\" \"${a_output[@]}\" \"\";
   else
      printf '%s\\n' \"\" \"- Audit Result:\" \"  ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\";
      [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"\" \"- Correctly set:\" \"${a_output[@]}\" \"\";
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>
  </then>

  <else>
    <report type:"WARNING">
      description : "CIS_Debian_Linux_12_v1.1.0_L2_Workstation.audit from CIS Debian Linux 12 Benchmark v1.1.0"
      info        : "NOTE: Nessus has not identified that the chosen audit applies to the target device."
      see_also    : "https://workbench.cisecurity.org/benchmarks/18960"
    </report>
  </else>
</if>

</check_type>

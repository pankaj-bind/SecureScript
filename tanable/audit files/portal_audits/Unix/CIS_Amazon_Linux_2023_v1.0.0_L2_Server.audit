#TRUSTED 518d4f493b86b1294fd0d44a828c1363b06aea4a6f25d7f1e7a793be65be785e44f25052c777ee9e3bbf836dbbbcbae0f9b668b3a76123c1d00e19d734ef73a6cd7087d8aed5dd4c700a4ddbd34f5aaf6aab3c362c58b373913b428e1fd95c3023ecde1fef9f71eb8c92e8f545d59451428eb3a4241ea0de5bcae2d897c442462e28d47e4262106f25708ac67c33b0465bb6558ee7900a0f639bf686d7dc58e525b96ee0e1c563d85b8f39933684289357a5066cfc36043b46309f5447c2938c0e6b50d5fac8844d5129090bf42876a6584c0d14c1aa18cee2f959249ee6a729e89ea56f5b2ba1f349a37491ef16371f9cc9bb49836accb41691b3b039e6c634d26c7dc46c80beb5ec2cdb939cf87ebe741394d20bf868940153bbbd92da30baa7c7416c30e1335b583d4ec3db0068be59fbf3c6ef5f2be9f1b36e49a64cfca04352cff645a94c785a134255790be7583de0f067cfa475e646706f4ebe19079fd33bebfee4dca7f4553f28b0bed9593a77404d4eea85c522cb5207bd7931fd077736ed4927e20b033d72ccc09536b66a79e8cff86a355be6c0ddcf643e949808e0acf0ff4137b19c867e78bc799cb46c30b2b4299850c371f158434c0222abd740c55723d156dd5e5429f3e9110211889ad2e0efa959ffd4b611b9f08b3470c12dab14deaedcd116b45c6c32d0aefcf94ef724c70275eae7014e3d7c65646751
#TRUST-RSA-SHA256 3ed79084938a04cefc876866832636054c7439859cb704cb1c36f2e8f08f3a01cd7ce19edf4dcf2ad0417edcfb94253657718ffd52ed3c3ab5d417d0d029506698f076a55eb89cfcccf7fb16f47bfe5fdbbf5bf2d59fe8e0461d50a79b728a1c987594c5f5caf4b14d12d39f71bef5623b217b475cac494c535c3fbaedb73e055742455d0577ff4f3e8102af4e10c17ed5682545103038abb7a2a4428ab38c1b8b5f59f930f11efd45a18a8ca6b2721c10ef6c5243009cbcc1e06caa7a8f4498a86429149931d4d1a62ea16132558609f851694bb24931544347705a962dbf8b34e1244cde4e02406eb71b958a3865fc4d6c7d34d04c5085d78ef4e3d52be81586fe8b6a0bbf52bc0c396116fa68ef4679010c5a795a6a0c85ad6673ebfca9c5dcb380e9e4c5c191acfe32f1d64c56fc48454410e17199c64e4c1380f70dc7e35cb0b317d38a3ef9879f5fb6da7ad73e84272ee4f9f198ed55560a684089d9e42c74d9cdac096a14af3944089e2edc00c29a04781286456f4b0e7e1c65ec889df3ea1c820dc89300984892874b5e9a3fe62ae29b98817a2567f46ecf17f5e92df8ade7b1eabc006a457828d71c1f4edc656bc702fb30629a3b11274e5541ebbefa559ed493c8c8be079510607934f874fde6889e44fb051736bf21130dc560195a0f32581175b3d07e1a54bb8c945366924e69ff73bfab25ff04e66035a72cce
#
# This script is Copyright (C) 2004-2025 and is owned by Tenable, Inc. or an Affiliate thereof.
#
# This script is released under the Tenable Subscription License and
# may not be used from within scripts released under another license
# without authorization from Tenable, Inc.
#
# See the following licenses for details:
#
# http://static.tenable.com/prod_docs/Nessus_6_SLA_and_Subscription_Agreement.pdf
#
# @PROFESSIONALFEED@
# $Revision: 1.7 $
# $Date: 2025/01/06 $
#
# Description   : This document implements the security configuration as recommended by the CIS Amazon Linux 2023 Benchmark v1.0.0
#
#<ui_metadata>
#<display_name>CIS Amazon Linux 2023 Server L2 v1.0.0</display_name>
#<spec>
#  <type>CIS</type>
#  <name>Amazon Linux 2023 Server</name>
#  <profile>L2</profile>
#  <version>1.0.0</version>
#  <link>https://workbench.cisecurity.org/benchmarks/12705</link>
#</spec>
#<labels>unix,cis,amazon,linux,amazon_linux_2023,agent</labels>
#<benchmark_refs>CSCv6,CSCv7,CSCv8,LEVEL</benchmark_refs>
#<variables>
#  <variable>
#    <name>PLATFORM_VERSION</name>
#    <default>2023</default>
#    <description>Linux Distribution Version</description>
#    <info>Linux Distribution Version</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>BACKLOG_SIZE</name>
#    <default>8192</default>
#    <description>Audit backlog limit</description>
#    <info>Audit backlog record limit.</info>
#    <value_type>INTEGER</value_type>
#  </variable>
#  <variable>
#    <name>MAX_AUDIT_LOG_FILE_SIZE</name>
#    <default>32</default>
#    <description>Log file size</description>
#    <info>The max size, in MBs, each audit log can be before log file rotation.</info>
#    <value_type>STRING</value_type>
#  </variable>
#  <variable>
#    <name>FIND_TIMEOUT</name>
#    <default>7200</default>
#    <description>Timeout for checks that search for files</description>
#    <info>Timeout, in seconds, for checks that search for files. Range of 1-7200.</info>
#    <value_type>INTEGER</value_type>
#  </variable>
#  <variable>
#    <name>FIREWALLD_DEFAULT_ZONE</name>
#    <default>public</default>
#    <description>Firewalld default zone</description>
#    <info>The default zone adhering to company policy. Default is public.</info>
#    <value_type>STRING</value_type>
#  </variable>
#</variables>
#</ui_metadata>

<check_type:"Unix">

<if>
  <condition type:"AND">
    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "Amazon Linux 2023 is installed"
      file        : "/etc/system-release"
      regex       : "^[\\s]*Amazon Linux release"
      expect      : "^[\\s]*Amazon Linux release @PLATFORM_VERSION@"
    </custom_item>
  </condition>

  <then>
    <report type:"PASSED">
      description : "CIS_Amazon_Linux_2023_v1.0.0_L2_Server.audit from CIS Amazon Linux 2023 Benchmark v1.0.0"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
    </report>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.1 Ensure mounting of squashfs filesystems is disabled"
      info        : "The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image.

Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
      solution    : "Run the following script to disable the squashfs module:

If the module is available in the running kernel:

 - Create a file with install squashfs /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist squashfs in the /etc/modprobe.d/ directory
 - Unload squashfs from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist squashfs in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"squashfs\" # set module name
   l_mtype=\"fs\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}

Impact:

As Snap packages utilizes squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail.

Snap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"squashfs\" # set module name
   l_mtype=\"fs\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"\\n- Audit Result:\\n  ** PASS **\\n$l_output\\n\"
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n - Reason(s) for audit failure:\\n$l_output2\\n\"
      [ -n \"$l_output\" ] && echo -e \"\\n- Correctly set:\\n$l_output\\n\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.1.2 Ensure mounting of udf filesystems is disabled"
      info        : "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats.

Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
      solution    : "Run the following script to disable the udf module:

If the module is available in the running kernel:

 - Create a file with install udf /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist udf in the /etc/modprobe.d/ directory
 - Unload udf from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist udf in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"udf\" # set module name
   l_mtype=\"fs\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"udf\" # set module name
   l_mtype=\"fs\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3
  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"

 -- INFO --
 - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"
- Audit Result:
  ** PASS **
$l_output
\"
   else
      echo -e \"
- Audit Result:
  ** FAIL **
 - Reason(s) for audit failure:
$l_output2
\"
      [ -n \"$l_output\" ] && echo -e \"
- Correctly set:
$l_output
\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.3.1 Ensure separate partition exists for /var"
      info        : "The /var directory is used by daemons and other system services to temporarily store dynamic data. Some directories created by these processes may be world-writable.

The reasoning for mounting /var on a separate partition is as follows.

Protection from resource exhaustion

The default installation only creates a single / partition. Since the /var directory may contain world-writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var and cause unintended behavior across the system as the disk is full. See man auditd.conf for details.

Fine grained control over the mount

Configuring /var as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limits an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

Protection from exploitation

An example of exploiting /var may be an attacker establishing a hard-link to a system setuid program and wait for it to be updated. Once the program was updated, the hard-link would be broken and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/findmnt -kn /var"
      expect      : "^[\\s]*/var[\\s]+"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.4.1 Ensure separate partition exists for /var/tmp"
      info        : "The /var/tmp directory is a world-writable directory used for temporary storage by all users and some applications. Temporary files residing in /var/tmp are to be preserved between reboots.

The reasoning for mounting /var/tmp on a separate partition is as follows.

Protection from resource exhaustion

The default installation only creates a single / partition. Since the /var/tmp directory may contain world-writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var/tmp and cause potential disruption to daemons as the disk is full.

Fine grained control over the mount

Configuring /var/tmp as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limits an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

Protection from exploitation

An example of exploiting /var/tmp may be an attacker establishing a hard-link to a system setuid program and wait for it to be updated. Once the program was updated, the hard-link would be broken and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/tmp

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/findmnt --kernel /var/tmp"
      expect      : "^[\\s]*/var/tmp[\\s]+.+[\\s]+.+"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.5.1 Ensure separate partition exists for /var/log"
      info        : "The /var/log directory is used by system services to store log data.

The reasoning for mounting /var/log on a separate partition is as follows.

Protection from resource exhaustion

The default installation only creates a single / partition. Since the /var/log directory contains log files which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole.

Fine grained control over the mount

Configuring /var/log as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attackers ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

Protection of log data

As /var/log contains log files, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/findmnt --kernel /var/log"
      expect      : "^[\\s]*/var/log[\\s]+.+[\\s]+.+"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.6.1 Ensure separate partition exists for /var/log/audit"
      info        : "The auditing daemon, auditd stores log data in the /var/log/audit directory.

The reasoning for mounting /var/log/audit on a separate partition is as follows.

Protection from resource exhaustion

The default installation only creates a single / partition. Since the /var/log/audit directory contains the audit.log file which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /var/log/audit and cause auditd to trigger it's space_left_action as the disk is full. See man auditd.conf for details.

Fine grained control over the mount

Configuring /var/log/audit as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

Protection of audit data

As /var/log/audit contains audit logs, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /var/log/audit

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/findmnt --kernel /var/log/audit"
      expect      : "^[\\s]*/var/log/audit[\\s]+.+[\\s]+.+"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "1.1.7.1 Ensure separate partition exists for /home"
      info        : "The /home directory is used to support disk storage needs of local users.

The reasoning for mounting /home on a separate partition is as follows.

Protection from resource exhaustion

The default installation only creates a single / partition. Since the /home directory contains user generated data, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to /home and impact all local users.

Fine grained control over the mount

Configuring /home as its own file system allows an administrator to set additional mount options such as noexec/nosuid/nodev These options limit an attacker's ability to create exploits on the system. In the case of /home options such as usrquota/grpquota may be considered to limit the impact that users can have on each other with regards to disk resource exhaustion. Other options allow for specific behavior. See man mount for exact details regarding filesystem-independent and filesystem-specific options.

Protection of user data

As /home contains user data, care should be taken to ensure the security and integrity of the data and mount point."
      solution    : "For new installations, during installation create a custom partition setup and specify a separate partition for /home

For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.

Impact:

Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/findmnt --kernel /home"
      expect      : "^[\\s]*/home[\\s]+.+[\\s]+.+"
    </custom_item>

    <if>
      <condition auto:"WARNING" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "Per repository configuration"
          cmd         : "/bin/grep -l \"repo_gpgcheck=0\" /etc/yum.repos.d/* | /bin/awk '{print} END {if (NR == 0) print \"pass\" ; else print \"manual_review_required\"}\'"
          expect      : "^pass$"
          severity    : MEDIUM
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "Global configuration"
          file        : "/etc/dnf/dnf.conf"
          regex       : "^[\\s]*repo_gpgcheck[\\s]*="
          expect      : "^[\\s]*repo_gpgcheck[\\s]*=[\\s]*1[\\s]*$"
          severity    : MEDIUM
        </custom_item>
      </condition>

      <then>
        <report type:"WARNING">
          description : "1.2.4 Ensure repo_gpgcheck is globally activated"
          info        : "The repo_gpgcheck option, found in the main section of the /etc/dnf/dnf.conf and individual /etc/yum.repos.d/* files, will perform a GPG signature check on the repodata.

It is important to ensure that the repository data signature is always checked prior to installation to ensure that the software is not tampered with in any way.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
          solution    : "Global configuration

Edit /etc/dnf/dnf.conf and set repo_gpgcheck=1 in the [main] section.

Example:

[main]
repo_gpgcheck=1

Per repository configuration

First check that the particular repository support GPG checking on the repodata.

Edit any failing files in /etc/yum.repos.d/* and set all instances starting with repo_gpgcheck to 1

Impact:

Not all repositories, notably RedHat, support repo_gpgcheck Take care to set this value to false (default) for particular repositories that do not support it. If enabled on repositories that do not support repo_gpgcheck installation of packages will fail.

Research is required by the user to determine which repositories is configured on the local system and, from that list, which support repo_gpgcheck"
          reference   : "800-171|3.11.2,800-171|3.11.3,800-171|3.14.1,800-53|RA-5,800-53|SI-2,800-53|SI-2(2),800-53r5|RA-5,800-53r5|RA-7,800-53r5|SI-2,800-53r5|SI-2(2),CN-L3|8.1.4.4(e),CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv8|7.3,CSF|DE.CM-8,CSF|DE.DP-4,CSF|DE.DP-5,CSF|ID.RA-1,CSF|PR.IP-12,CSF|RS.CO-3,CSF|RS.MI-3,CSF2.0|GV.SC-10,CSF2.0|ID.IM-01,CSF2.0|ID.IM-02,CSF2.0|ID.IM-03,CSF2.0|ID.RA-01,CSF2.0|ID.RA-08,CSF2.0|PR.PS-02,GDPR|32.1.b,GDPR|32.1.d,HIPAA|164.306(a)(1),ISO/IEC-27001|A.12.6.1,ITSG-33|RA-5,ITSG-33|SI-2,ITSG-33|SI-2(2),LEVEL|2M,NESA|M1.2.2,NESA|M5.4.1,NESA|T7.6.2,NESA|T7.7.1,NIAv2|PR9,PCI-DSSv3.2.1|6.1,PCI-DSSv3.2.1|6.2,PCI-DSSv4.0|6.3,PCI-DSSv4.0|6.3.1,PCI-DSSv4.0|6.3.3,QCSC-v1|3.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,SWIFT-CSCv1|2.2,SWIFT-CSCv1|2.7"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "/etc/selinux/config"
          file        : "/etc/selinux/config"
          regex       : "(?i)^[\\s]*SELINUX[\\s]*="
          expect      : "(?i)^[\\s]*SELINUX[\\s]*=[\\s]*enforcing[\\s]*$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "getenforce"
          cmd         : "/sbin/getenforce"
          expect      : "(?i)^[\\s]*enforcing[\\s]*$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "1.6.1.5 Ensure the SELinux mode is enforcing"
          info        : "SELinux can run in one of three modes: disabled, permissive, or enforcing:

 - Enforcing - Is the default, and recommended, mode of operation; in enforcing mode SELinux operates normally, enforcing the loaded security policy on the entire system.
 - Permissive - The system acts as if SELinux is enforcing the loaded security policy, including labeling objects and emitting access denial entries in the logs, but it does not actually deny any operations. While not recommended for production systems, permissive mode can be helpful for SELinux policy development.
 - Disabled - Is strongly discouraged; not only does the system avoid enforcing the SELinux policy, it also avoids labeling any persistent objects such as files, making it difficult to enable SELinux in the future

Note: you can set individual domains to permissive mode while the system runs in enforcing mode. For example, to make the httpd_t domain permissive:

# semanage permissive -a httpd_t

Running SELinux in disabled mode the system not only avoids enforcing the SELinux policy, it also avoids labeling any persistent objects such as files, making it difficult to enable SELinux in the future.

Running SELinux in Permissive mode, though helpful for developing SELinux policy, only logs access denial entries, but does not deny any operations."
          solution    : "Run the following command to set SELinux's running mode:

# setenforce 1

Edit the /etc/selinux/config file to set the SELINUX parameter:

For Enforcing mode:

SELINUX=enforcing"
          reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <custom_item>
      type        : RPM_CHECK
      description : "2.2.1 Ensure xorg-x11-server-common is not installed"
      info        : "The X Window System provides a Graphical User Interface (GUI) where users can have multiple windows in which to run programs and various add on. The X Windows system is typically used on workstations where users login, but not on servers where users typically do not login.

Unless your organization specifically requires graphical login access via X Windows, remove it to reduce the potential attack surface."
      solution    : "Run the following command to remove the X Windows Server packages:

# dnf remove xorg-x11-server-common

Impact:

Many Linux systems run applications which require a Java runtime. Some Linux Java packages have a dependency on specific X Windows xorg-x11-fonts. One workaround to avoid this dependency is to use the \"headless\" Java packages for your specific Java runtime."
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      rpm         : "xorg-x11-server-common-0.0.0-0"
      operator    : "lte"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.1.2 Ensure DCCP is disabled"
      info        : "The Datagram Congestion Control Protocol (DCCP) is a transport layer protocol that supports streaming media and telephony. DCCP provides a way to gain access to congestion control, without having to do it at the application layer, but does not provide in-sequence delivery.

If the protocol is not required, it is recommended that the drivers not be installed to reduce the potential attack surface."
      solution    : "Run the following script to disable the dccp module:

If the module is available in the running kernel:

 - Create a file with install dccp /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist dccp in the /etc/modprobe.d/ directory
 - Unload dccp from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist dccp in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"dccp\" # set module name
   l_mtype=\"net\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"dccp\" # set module name
   l_mtype=\"net\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3
  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"

 -- INFO --
 - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"
- Audit Result:
  ** PASS **
$l_output
\"
   else
      echo -e \"
- Audit Result:
  ** FAIL **
 - Reason(s) for audit failure:
$l_output2
\"
      [ -n \"$l_output\" ] && echo -e \"
- Correctly set:
$l_output
\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.1.3 Ensure SCTP is disabled"
      info        : "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to support message oriented communication, with several streams of messages in one connection. It serves a similar function as TCP and UDP, incorporating features of both. It is message-oriented like UDP, and ensures reliable in-sequence transport of messages with congestion control like TCP.

If the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to disable the sctp module:

If the module is available in the running kernel:

 - Create a file with install sctp /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist sctp in the /etc/modprobe.d/ directory
 - Unload sctp from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist sctp in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"sctp\" # set module name
   l_mtype=\"net\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"sctp\" # set module name
   l_mtype=\"net\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"\\n- Audit Result:\\n  ** PASS **\\n$l_output\\n\"
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n - Reason(s) for audit failure:\\n$l_output2\\n\"
      [ -n \"$l_output\" ] && echo -e \"\\n- Correctly set:\\n$l_output\\n\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.1.4 Ensure RDS is disabled"
      info        : "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide low-latency, high-bandwidth communications between cluster nodes. It was developed by the Oracle Corporation.

If the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to disable the rds module:

If the module is available in the running kernel:

 - Create a file with install rds /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist rds in the /etc/modprobe.d/ directory
 - Unload rds from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist rds in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"rds\" # set module name
   l_mtype=\"net\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"rds\" # set module name
   l_mtype=\"net\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2\\n - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3\\n  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output\\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"\\n- Audit Result:\\n  ** PASS **\\n$l_output\\n\"
   else
      echo -e \"\\n- Audit Result:\\n  ** FAIL **\\n - Reason(s) for audit failure:\\n$l_output2\\n\"
      [ -n \"$l_output\" ] && echo -e \"\\n- Correctly set:\\n$l_output\\n\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.1.5 Ensure TIPC is disabled"
      info        : "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communication between cluster nodes.

If the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
      solution    : "Run the following script to disable the tipc module:

If the module is available in the running kernel:

 - Create a file with install tipc /bin/false in the /etc/modprobe.d/ directory
 - Create a file with blacklist tipc in the /etc/modprobe.d/ directory
 - Unload tipc from the kernel

If available in ANY installed kernel:

 - Create a file with blacklist tipc in the /etc/modprobe.d/ directory

If the kernel module is not available on the system or pre-compiled into the kernel:

 - No remediation is necessary

#!/usr/bin/env bash

{
   l_mname=\"tipc\" # set module name
   l_mtype=\"net\" # set module type
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_fix()
   {
      # If the module is currently loadable, add \"install {MODULE_NAME} /bin/false\" to a file in \"/etc/modprobe.d\"
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\h*install|\b$l_mname)\b\" <<< \"$l_loadable\")\"
      if ! grep -Pq -- '^\h*install \/bin\/(true|false)' <<< \"$l_loadable\"; then
         echo -e \"\n - setting module: \\\"$l_mname\\\" to be not loadable\"
         echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   module_loaded_fix()
   {
      # If the module is currently loaded, unload the module
      if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         echo -e \"\n - unloading module \\\"$l_mname\\\"\"
         modprobe -r \"$l_mname\"
      fi
   }
   module_deny_fix()
   {
      # If the module isn't deny listed, denylist the module
      if ! modprobe --showconfig | grep -Pq -- \"^\h*blacklist\h+$l_mpname\b\"; then
         echo -e \"\n - deny listing \\\"$l_mname\\\"\"
         echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mpname\".conf
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         echo -e \"\n - module: \\\"$l_mname\\\" exists in \\\"$l_mdir\\\"\n - checking if disabled...\"
         module_deny_fix
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_fix
            module_loaded_fix
         fi
      else
         echo -e \"\n - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\n\"
      fi
   done
   echo -e \"\n - remediation of module: \\\"$l_mname\\\" complete\n\"
}"
      reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_output3=\"\" l_dl=\"\" # Unset output variables
   l_mname=\"tipc\" # set module name
   l_mtype=\"net\" # set module type
   l_searchloc=\"/lib/modprobe.d/*.conf /usr/local/lib/modprobe.d/*.conf /run/modprobe.d/*.conf /etc/modprobe.d/*.conf\"
   l_mpath=\"/lib/modules/**/kernel/$l_mtype\"
   l_mpname=\"$(tr '-' '_' <<< \"$l_mname\")\"
   l_mndir=\"$(tr '-' '/' <<< \"$l_mname\")\"

   module_loadable_chk()
   {
      # Check if the module is currently loadable
      l_loadable=\"$(modprobe -n -v \"$l_mname\")\"
      [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\"
      if grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loadable: \\\"$l_loadable\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loadable: \\\"$l_loadable\\\"\"
      fi
   }
   module_loaded_chk()
   {
      # Check if the module is currently loaded
      if ! lsmod | grep \"$l_mname\" > /dev/null 2>&1; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is not loaded\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is loaded\"
      fi
   }
   module_deny_chk()
   {
      # Check if the module is deny listed
      l_dl=\"y\"
      if modprobe --showconfig | grep -Pq -- '^\\h*blacklist\\h+'\"$l_mpname\"'\\b'; then
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" is deny listed in: \\\"$(grep -Pls -- \"^\\h*blacklist\\h+$l_mname\\b\" $l_searchloc)\\\"\"
      else
         l_output2=\"$l_output2
 - module: \\\"$l_mname\\\" is not deny listed\"
      fi
   }
   # Check if the module exists on the system
   for l_mdir in $l_mpath; do
      if [ -d \"$l_mdir/$l_mndir\" ] && [ -n \"$(ls -A $l_mdir/$l_mndir)\" ]; then
         l_output3=\"$l_output3
  - \\\"$l_mdir\\\"\"
         [ \"$l_dl\" != \"y\" ] && module_deny_chk
         if [ \"$l_mdir\" = \"/lib/modules/$(uname -r)/kernel/$l_mtype\" ]; then
            module_loadable_chk
            module_loaded_chk
         fi
      else
         l_output=\"$l_output
 - module: \\\"$l_mname\\\" doesn't exist in \\\"$l_mdir\\\"\"
      fi
   done
   # Report results. If no failures output in l_output2, we pass
   [ -n \"$l_output3\" ] && echo -e \"

 -- INFO --
 - module: \\\"$l_mname\\\" exists in:$l_output3\"
   if [ -z \"$l_output2\" ]; then
      echo -e \"
- Audit Result:
  ** PASS **
$l_output
\"
   else
      echo -e \"
- Audit Result:
  ** FAIL **
 - Reason(s) for audit failure:
$l_output2
\"
      [ -n \"$l_output\" ] && echo -e \"
- Correctly set:
$l_output
\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : RPM_CHECK
      description : "3.4.1.1 Ensure nftables is installed"
      info        : "nftables provides a new in-kernel packet classification framework that is based on a network-specific Virtual Machine (VM) and a new nft userspace command line tool.

nftables reuses the existing Netfilter subsystems such as the existing hook infrastructure, the connection tracking system, NAT, userspace queuing and logging subsystem.

nftables is a subsystem of the Linux kernel that can protect against threats originating from within a corporate network to include malicious mobile code and poorly configured software on a host."
      solution    : "Run the following command to install nftables

# dnf install nftables

Impact:

Changing firewall settings while connected over the network can result in being locked out of the system."
      reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      rpm         : "nftables-0.0.0-0"
      operator    : "gt"
      required    : YES
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "3.4.1.2 Ensure a single firewall configuration utility is in use"
      info        : "FirewallD - Is a firewall service daemon that provides a dynamic customizable host-based firewall with a D-Bus interface. Being dynamic, it enables creating, changing, and deleting the rules without the necessity to restart the firewall daemon each time the rules are changed

NFTables - Includes the nft utility for configuration of the nftables subsystem of the Linux kernel

Note: firewalld with nftables backend does not support passing custom nftables rules to firewalld, using the --direct option.

In order to configure firewall rules for nftables, a firewall utility needs to be installed and active of the system. The use of more than one firewall utility may produce unexpected results."
      solution    : "Run the following script to ensure that a single firewall utility is in use on the system:

#!/usr/bin/env bash

{
   l_output=\"\" l_output2=\"\" l_fwd_status=\"\" l_nft_status=\"\" l_fwutil_status=\"\"
   # Determine FirewallD utility Status
   rpm -q firewalld > /dev/null 2>&1 && l_fwd_status=\"$(systemctl is-enabled firewalld.service):$(systemctl is-active firewalld.service)\"
   # Determine NFTables utility Status
   rpm -q nftables > /dev/null 2>&1 && l_nft_status=\"$(systemctl is-enabled nftables.service):$(systemctl is-active nftables.service)\"
   l_fwutil_status=\"$l_fwd_status:$l_nft_status\"
   case $l_fwutil_status in
      enabled:active:masked:inactive|enabled:active:disabled:inactive)
         echo -e \"\n - FirewallD utility is in use, enabled and active\n - NFTables utility is correctly disabled or masked and inactive\n - no remediation required\" ;;
      masked:inactive:enabled:active|disabled:inactive:enabled:active)
         echo -e \"\n - NFTables utility is in use, enabled and active\n - FirewallD utility is correctly disabled or masked and inactive\n - no remediation required\" ;;
      enabled:active:enabled:active)
         echo -e \"\n - Both FirewallD and NFTables utilities are enabled and active\n - stopping and masking NFTables utility\"
         systemctl stop nftables && systemctl --now mask nftables ;;
      enabled:*:enabled:*)
         echo -e \"\n - Both FirewallD and NFTables utilities are enabled\n - remediating\"
         if [ \"$(awk -F: '{print $2}' <<< \"$l_fwutil_status\")\" = \"active\" ] && [ \"$(awk -F: '{print $4}' <<< \"$l_fwutil_status\")\" = \"inactive\" ]; then
            echo \" - masking NFTables utility\"
            systemctl stop nftables && systemctl --now mask nftables
         elif [ \"$(awk -F: '{print $4}' <<< \"$l_fwutil_status\")\" = \"active\" ] && [ \"$(awk -F: '{print $2}' <<< \"$l_fwutil_status\")\" = \"inactive\" ]; then
            echo \" - masking FirewallD utility\"
            systemctl stop firewalld && systemctl --now mask firewalld
         fi ;;
      *:active:*:active)
         echo -e \"\n - Both FirewallD and NFTables utilities are active\n - remediating\"
         if [ \"$(awk -F: '{print $1}' <<< \"$l_fwutil_status\")\" = \"enabled\" ] && [ \"$(awk -F: '{print $3}' <<< \"$l_fwutil_status\")\" != \"enabled\" ]; then
            echo \" - stopping and masking NFTables utility\"
            systemctl stop nftables && systemctl --now mask nftables
         elif [ \"$(awk -F: '{print $3}' <<< \"$l_fwutil_status\")\" = \"enabled\" ] && [ \"$(awk -F: '{print $1}' <<< \"$l_fwutil_status\")\" != \"enabled\" ]; then
            echo \" - stopping and masking FirewallD utility\"
            systemctl stop firewalld && systemctl --now mask firewalld
         fi ;;
      :enabled:active)
         echo -e \"\n - NFTables utility is in use, enabled, and active\n - FirewallD package is not installed\n - no remediation required\" ;;
      :)
         echo -e \"\n - Neither FirewallD or NFTables is installed.\n - remediating\n - installing NFTables\"
         dnf -q install nftables ;;
      *:*:)
         echo -e \"\n - NFTables package is not installed on the system\n - remediating\n - installing NFTables\"
         dnf -q install nftables ;;
      *)
         echo -e \"\n - Unable to determine firewall state\" ;;
   esac
}"
      reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSCv8|4.5,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\" l_fwd_status=\"\" l_nft_status=\"\" l_fwutil_status=\"\"
   # Determine FirewallD utility Status
   rpm -q firewalld > /dev/null 2>&1 && l_fwd_status=\"$(systemctl is-enabled firewalld.service):$(systemctl is-active firewalld.service)\"
   # Determine NFTables utility Status
   rpm -q nftables > /dev/null 2>&1 && l_nft_status=\"$(systemctl is-enabled nftables.service):$(systemctl is-active nftables.service)\"
   l_fwutil_status=\"$l_fwd_status:$l_nft_status\"
   case $l_fwutil_status in
      enabled:active:masked:inactive|enabled:active:disabled:inactive)
         l_output=\"\\n - FirewallD utility is in use, enabled and active\\n - NFTables utility is correctly disabled or masked and inactive\" ;;
      masked:inactive:enabled:active|disabled:inactive:enabled:active)
         l_output=\"\\n - NFTables utility is in use, enabled and active\\n - FirewallD utility is correctly disabled or masked and inactive\" ;;
      enabled:active:enabled:active)
         l_output2=\"\\n - Both FirewallD and NFTables utilities are enabled and active\" ;;
      enabled:*:enabled:*)
         l_output2=\"\\n - Both FirewallD and NFTables utilities are enabled\" ;;
      *:active:*:active)
         l_output2=\"\\n - Both FirewallD and NFTables utilities are enabled\" ;;
      :enabled:active)
         l_output=\"\\n - NFTables utility is in use, enabled, and active\\n - FirewallD package is not installed\" ;;
      :)
         l_output2=\"\\n - Neither FirewallD or NFTables is installed.\" ;;
      *:*:)
         l_output2=\"\\n - NFTables package is not installed on the system\" ;;
      *)
         l_output2=\"\\n - Unable to determine firewall state\" ;;
   esac
   if [ -z \"$l_output2\" ]; then
      echo -e \"\\n- Audit Results:\\n ** Pass **\\n$l_output\\n\"
   else
      echo -e \"\\n- Audit Results:\\n ** Fail **\\n$l_output2\\n\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "firewalld check - active"
          cmd         : "/bin/systemctl is-active firewalld"
          expect      : "^active$"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          system      : "Linux"
          type        : CMD_EXEC
          description : "3.4.2.1 Ensure firewalld default zone is set"
          info        : "A firewall zone defines the trust level for a connection, interface or source address binding. This is a one to many relation, which means that a connection, interface or source can only be part of one zone, but a zone can be used for many network connections, interfaces and sources.

 - The default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone.
 - If no zone assigned to a connection, interface or source, only the default zone is used.
 - The default zone is not always listed as being used for an interface or source as it will be used for it either way. This depends on the manager of the interfaces.

Connections handled by NetworkManager are listed as NetworkManager requests to add the zone binding for the interface used by the connection. Also interfaces under control of the network service are listed also because the service requests it.

Note:

 - A firewalld zone configuration file contains the information for a zone.
 - These are the zone description, services, ports, protocols, icmp-blocks, masquerade, forward-ports and rich language rules in an XML file format.
 - The file name has to be zone_name.xml where length of zone_name is currently limited to 17 chars.

 - NetworkManager binds interfaces to zones automatically

Because the default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone, if FirewallD is being used, it is important for the default zone to set"
          solution    : "Run the following script to set the default zone:

!/usr/bin/env bash

{
   l_zname=\"public\" # <- Update to local site zone name if desired
   l_zone=\"\"
   if systemctl is-enabled firewalld.service | grep -q 'enabled'; then
      l_zone=\"$(firewall-cmd --get-default-zone)\"
      if [ \"$l_zone\" = \"$l_zname\" ]; then
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - No remediation required\"
      elif [ -n \"$l_zone\" ]; then
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - Updating default zone to: \\\"l_zname\\\"\"
         firewall-cmd --set-default-zone=\"$l_zname\"
      else
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - Updating default zone to: \\\"l_zname\\\"\"
         firewall-cmd --set-default-zone=\"$l_zname\"
      fi
   else
      echo -e \"\n - FirewallD is not in use on the system\n - No remediation required\"
   fi
}"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          cmd         : "/bin/firewall-cmd --get-default-zone"
          expect      : "^@FIREWALLD_DEFAULT_ZONE@$"
        </custom_item>
      </then>

      <else>
        <report type:"PASSED">
          description : "3.4.2.1 Ensure firewalld default zone is set"
          info        : "A firewall zone defines the trust level for a connection, interface or source address binding. This is a one to many relation, which means that a connection, interface or source can only be part of one zone, but a zone can be used for many network connections, interfaces and sources.

 - The default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone.
 - If no zone assigned to a connection, interface or source, only the default zone is used.
 - The default zone is not always listed as being used for an interface or source as it will be used for it either way. This depends on the manager of the interfaces.

Connections handled by NetworkManager are listed as NetworkManager requests to add the zone binding for the interface used by the connection. Also interfaces under control of the network service are listed also because the service requests it.

Note:

 - A firewalld zone configuration file contains the information for a zone.
 - These are the zone description, services, ports, protocols, icmp-blocks, masquerade, forward-ports and rich language rules in an XML file format.
 - The file name has to be zone_name.xml where length of zone_name is currently limited to 17 chars.

 - NetworkManager binds interfaces to zones automatically

Because the default zone is the zone that is used for everything that is not explicitly bound/assigned to another zone, if FirewallD is being used, it is important for the default zone to set

NOTE: The identified firewall 'firewalld' was not found to be active and this check does not apply."
          solution    : "Run the following script to set the default zone:

!/usr/bin/env bash

{
   l_zname=\"public\" # <- Update to local site zone name if desired
   l_zone=\"\"
   if systemctl is-enabled firewalld.service | grep -q 'enabled'; then
      l_zone=\"$(firewall-cmd --get-default-zone)\"
      if [ \"$l_zone\" = \"$l_zname\" ]; then
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - No remediation required\"
      elif [ -n \"$l_zone\" ]; then
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - Updating default zone to: \\\"l_zname\\\"\"
         firewall-cmd --set-default-zone=\"$l_zname\"
      else
         echo -e \"\n - The default zone is set to: \\\"$l_zone\\\"\n - Updating default zone to: \\\"l_zname\\\"\"
         firewall-cmd --set-default-zone=\"$l_zname\"
      fi
   else
      echo -e \"\n - FirewallD is not in use on the system\n - No remediation required\"
   fi
}"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "3.4.2.2 Ensure at least one nftables table exists"
      info        : "Tables hold chains. Each table only has one address family and only applies to packets of this family. Tables can have one of five families.

Without a table, nftables will not filter network traffic."
      solution    : "Run the following command to create a table in nftables

# nft create table inet <table name>

Example if FirewallD is not in use on the system:

# nft create table inet filter

Note: FirewallD uses the table inet firewalld NFTables table that is created when FirewallD is installed.

Impact:

Adding or modifying firewall rules can cause loss of connectivity to the system"
      reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/sbin/nft list tables | /bin/awk '{print} END { if(NR!=0) print \"pass\" ; else print \"fail\"}'"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "hook output"
          cmd         : "/sbin/nft -n list ruleset | /bin/grep 'hook output'"
          expect      : "type[\\s]+filter[\\s]+hook[\\s]+output[\\s]*"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "hook input"
          cmd         : "/sbin/nft -n list ruleset | /bin/grep 'hook input'"
          expect      : "type[\\s]+filter[\\s]+hook[\\s]+input[\\s]*"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "hook forward"
          cmd         : "/sbin/nft -n list ruleset | /bin/grep 'hook forward'"
          expect      : "type[\\s]+filter[\\s]+hook[\\s]+forward[\\s]*"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "3.4.2.3 Ensure nftables base chains exist"
          info        : "Chains are containers for rules. They exist in two kinds, base chains and regular chains. A base chain is an entry point for packets from the networking stack, a regular chain may be used as jump target and is used for better rule organization.

If a base chain doesn't exist with a hook for input, forward, and delete, packets that would flow through those chains will not be touched by nftables."
          solution    : "Run the following command to create the base chains:

# nft create chain inet <table name> <base chain name> { type filter hook <(input|forward|output)> priority 0 \; }

Example:

# nft create chain inet filter input { type filter hook input priority 0 \; }
# nft create chain inet filter forward { type filter hook forward priority 0 \; }
# nft create chain inet filter output { type filter hook output priority 0 \; }

Impact:

If configuring over ssh, creating a base chain with a policy of drop will cause loss of connectivity.

Ensure that a rule allowing ssh has been added to the base chain prior to setting the base chain's policy to drop"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "3.4.2.4 Ensure host based firewall loopback traffic is configured"
      info        : "Configure the loopback interface to accept traffic. Configure all other interfaces to deny traffic to the loopback network

Loopback traffic is generated between processes on machine and is typically critical to operation of the system. The loopback interface is the only place that loopback network traffic should be seen, all other interfaces should ignore traffic on this network as an anti-spoofing measure."
      solution    : "Run the following script to implement the loopback rules:

#!/usr/bin/env bash

{
   l_hbfw=\"\"
   if systemctl is-enabled firewalld.service | grep -q 'enabled' && systemctl is-enabled nftables.service | grep -q 'enabled'; then
      echo -e \"\n - Error - Both FirewallD and NFTables are enabled\n - Please follow recommendation: \\\"Ensure a single firewall configuration utility is in use\\\"\"
   elif ! systemctl is-enabled firewalld.service | grep -q 'enabled' && ! systemctl is-enabled nftables.service | grep -q 'enabled'; then
      echo -e \"\n - Error - Neither FirewallD or NFTables is enabled\n - Please follow recommendation: \\\"Ensure a single firewall configuration utility is in use\\\"\"
   else
      if systemctl is-enabled firewalld.service | grep -q 'enabled' && ! systemctl is-enabled nftables.service | grep -q 'enabled'; then
         echo -e \"\n - FirewallD is in use on the system\" && l_hbfw=\"fwd\"
      elif ! systemctl is-enabled firewalld.service | grep -q 'enabled' && systemctl is-enabled nftables.service | grep -q 'enabled'; then
         echo -e \"\n - NFTables is in use on the system\" && l_hbfw=\"nft\"
      fi
      l_ipsaddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- 'ip\h+saddr')\"
      if ! nft list ruleset | awk '/hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -Pq -- '\H+\h+\"lo\"\h+accept'; then
         echo -e \"\n - Enabling input to accept for loopback address\"
         if [ \"$l_hbfw\" = \"fwd\" ]; then
            firewall-cmd --permanent --zone=trusted --add-interface=lo
            firewall-cmd --reload
         elif [ \"$l_hbfw\" = \"nft\" ]; then
            nft add rule inet filter input iif lo accept
         fi
      fi
      if ! grep -Pq -- 'ip\h+saddr\h+127\.0\.0\.0\/8\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< \"$l_ipsaddr\" && ! grep -Pq -- 'ip\h+daddr\h+\!\=\h+127\.0\.0\.1\h+ip\h+saddr\h+127\.0\.0\.1\h+drop' <<< \"$l_ipsaddr\"; then
         echo -e \"\n - Setting IPv4 network traffic from loopback address to drop\"
         if [ \"$l_hbfw\" = \"fwd\" ]; then
            firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=\"127.0.0.1\" destination not address=\"127.0.0.1\" drop'
            firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv4 source address=\"127.0.0.1\" destination not address=\"127.0.0.1\" drop'
            firewall-cmd --reload
         elif [ \"$l_hbfw\" = \"nft\" ]; then
            nft create rule inet filter input ip saddr 127.0.0.0/8 counter drop
         fi
      fi
      if grep -Pq -- '^\h*0\h*$' /sys/module/ipv6/parameters/disable; then
         l_ip6saddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')\"
         if ! grep -Pq 'ip6\h+saddr\h+::1\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< \"$l_ip6saddr\" && ! grep -Pq -- 'ip6\h+daddr\h+\!=\h+::1\h+ip6\h+saddr\h+::1\h+drop' <<< \"$l_ip6saddr\"; then
            echo -e \"\n - Setting IPv6 network traffic from loopback address to drop\"
            if [ \"$l_hbfw\" = \"fwd\" ]; then
               firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address=\"::1\" destination not address=\"::1\" drop'
               firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv6 source address=\"::1\" destination not address=\"::1\" drop'
               firewall-cmd --reload
            elif [ \"$l_hbfw\" = \"nft\" ]; then
               nft add rule inet filter input ip6 saddr ::1 counter drop
            fi
         fi
      fi
   fi
}"
      reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "#!/bin/bash

{
   l_output=\"\" l_output2=\"\"
   if nft list ruleset | awk '/hook\\s+input\\s+/,/\\}\\s*(#.*)?$/' | grep -Pq -- '\\H+\\h+\"lo\"\\h+accept'; then
      l_output=\"$l_output
 - Network traffic to the loopback address is correctly set to accept\"
   else
      l_output2=\"$l_output2
 - Network traffic to the loopback address is not set to accept\"
   fi
   l_ipsaddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook\\s+input\\s+/,/\\}\\s*(#.*)?$/' | grep -P -- 'ip\\h+saddr')\"
   if grep -Pq -- 'ip\\h+saddr\\h+127\\.0\\.0\\.0\\/8\\h+(counter\\h+packets\\h+\\d+\\h+bytes\\h+\\d+\\h+)?drop' <<< \"$l_ipsaddr\" || grep -Pq -- 'ip\\h+daddr\\h+\\!\\=\\h+127\\.0\\.0\\.1\\h+ip\\h+saddr\\h+127\\.0\\.0\\.1\\h+drop' <<< \"$l_ipsaddr\"; then
      l_output=\"$l_output
 - IPv4 network traffic from loopback address correctly set to drop\"
   else
      l_output2=\"$l_output2
 - IPv4 network traffic from loopback address not set to drop\"
   fi
   if grep -Pq -- '^\\h*0\\h*$' /sys/module/ipv6/parameters/disable; then
      l_ip6saddr=\"$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')\"
      if grep -Pq 'ip6\\h+saddr\\h+::1\\h+(counter\\h+packets\\h+\\d+\\h+bytes\\h+\\d+\\h+)?drop' <<< \"$l_ip6saddr\" || grep -Pq -- 'ip6\\h+daddr\\h+\\!=\\h+::1\\h+ip6\\h+saddr\\h+::1\\h+drop' <<< \"$l_ip6saddr\"; then
         l_output=\"$l_output
 - IPv6 network traffic from loopback address correctly set to drop\"
      else
         l_output2=\"$l_output2
 - IPv6 network traffic from loopback address not set to drop\"
      fi
   fi
   if [ -z \"$l_output2\" ]; then
      echo -e \"
- Audit Result:
  *** PASS ***
$l_output\"
   else
      echo -e \"
- Audit Result:
  *** FAIL ***
$l_output2

  - Correctly set:
$l_output\"
   fi
}"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "firewalld check - active"
          cmd         : "/bin/systemctl is-active firewalld"
          expect      : "^active$"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          type        : CMD_EXEC
          description : "3.4.2.5 Ensure firewalld drops unnecessary services and ports"
          info        : "Services and ports can be accepted or explicitly rejected or dropped by a zone.

For every zone, you can set a default behavior that handles incoming traffic that is not further specified. Such behavior is defined by setting the target of the zone. There are three options - default, ACCEPT, REJECT, and DROP.

 - ACCEPT - you accept all incoming packets except those disabled by a specific rule.
 - REJECT - you disable all incoming packets except those that you have allowed in specific rules and the source machine is informed about the rejection.
 - DROP - you disable all incoming packets except those that you have allowed in specific rules and no information sent to the source machine.

To reduce the attack surface of a system, all services and ports should be blocked unless required

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
          solution    : "If Firewalld is in use on the system:

Run the following command to remove an unnecessary service:

# firewall-cmd --remove-service=<service>

Example:

# firewall-cmd --remove-service=cockpit

Run the following command to remove an unnecessary port:

# firewall-cmd --remove-port=<port-number>/<port-type>

Example:

# firewall-cmd --remove-port=25/tcp

Run the following command to make new settings persistent:

# firewall-cmd --runtime-to-permanent"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          cmd         : "/bin/firewall-cmd --list-all --zone=\"$(/bin/firewall-cmd --list-all | /bin/awk '/\\(active\\)/ { print $1 }')\" | /bin/grep -P -- '^\\h*(services:|ports:)'"
          expect      : "^Manual Review Required$"
          severity    : MEDIUM
        </custom_item>
      </then>

      <else>
        <report type:"PASSED">
          description : "3.4.2.5 Ensure firewalld drops unnecessary services and ports"
          info        : "Services and ports can be accepted or explicitly rejected or dropped by a zone.

For every zone, you can set a default behavior that handles incoming traffic that is not further specified. Such behavior is defined by setting the target of the zone. There are three options - default, ACCEPT, REJECT, and DROP.

 - ACCEPT - you accept all incoming packets except those disabled by a specific rule.
 - REJECT - you disable all incoming packets except those that you have allowed in specific rules and the source machine is informed about the rejection.
 - DROP - you disable all incoming packets except those that you have allowed in specific rules and no information sent to the source machine.

To reduce the attack surface of a system, all services and ports should be blocked unless required

NOTE: The identified firewall 'firewalld' was not found to be active and this check does not apply."
          solution    : "If Firewalld is in use on the system:

Run the following command to remove an unnecessary service:

# firewall-cmd --remove-service=<service>

Example:

# firewall-cmd --remove-service=cockpit

Run the following command to remove an unnecessary port:

# firewall-cmd --remove-port=<port-number>/<port-type>

Example:

# firewall-cmd --remove-port=25/tcp

Run the following command to make new settings persistent:

# firewall-cmd --runtime-to-permanent"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "check if nftables.service is active"
          cmd         : "/bin/systemctl is-active nftables.service"
          expect      : "^active$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "nft list ruleset hook input icmp ct state"
              cmd         : "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'"
              expect      : "^[\\s]*ip[\\s]+protocol[\\s]+icmp[\\s]+ct[\\s]+state[\\s]+established[\\s]+accept[\\s]*$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "nft list ruleset hook input tcp ct state"
              cmd         : "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'"
              expect      : "^[\\s]*ip[\\s]+protocol[\\s]+tcp[\\s]+ct[\\s]+state[\\s]+established[\\s]+accept[\\s]*$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "nft list ruleset hook input udp ct state"
              cmd         : "/sbin/nft list ruleset | /bin/awk '/hook input/,/}/' | grep 'ct state'"
              expect      : "^[\\s]*ip[\\s]+protocol[\\s]+udp[\\s]+ct[\\s]+state[\\s]+established[\\s]+accept[\\s]*$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "3.4.2.6 Ensure nftables established connections are configured"
              info        : "Configure the firewall rules for new outbound and established connections

If rules are not in place for established connections, all packets will be dropped by the default policy preventing network usage."
              solution    : "If NFTables utility is in use on your system:

Configure nftables in accordance with site policy. The following commands will implement a policy to allow all established connections:

# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol tcp ct state established accept
# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol udp ct state established accept
# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol icmp ct state established accept"
              reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <report type:"PASSED">
          description : "3.4.2.6 Ensure nftables established connections are configured"
          info        : "Configure the firewall rules for new outbound and established connections

If rules are not in place for established connections, all packets will be dropped by the default policy preventing network usage.

NOTE: The identified firewall 'nftables' was not found to be active and this check does not apply."
          solution    : "If NFTables utility is in use on your system:

Configure nftables in accordance with site policy. The following commands will implement a policy to allow all established connections:

# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol tcp ct state established accept
# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol udp ct state established accept
# systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule inet filter input ip protocol icmp ct state established accept"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2M,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "check if nftables.service is active"
          cmd         : "/bin/systemctl is-active nftables.service"
          expect      : "^active$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "nft list ruleset hook forward drop"
              cmd         : "/sbin/nft list ruleset | /bin/grep 'hook forward'"
              expect      : "policy[\\s]*drop"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "nft list ruleset hook input drop"
              cmd         : "/sbin/nft list ruleset | /bin/grep 'hook input'"
              expect      : "policy[\\s]*drop"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "3.4.2.7 Ensure nftables default deny firewall policy"
              info        : "Base chain policy is the default verdict that will be applied to packets reaching the end of the chain.

There are two policies: accept (Default) and drop. If the policy is set to accept the firewall will accept any packet that is not configured to be denied and the packet will continue traversing the network stack.

It is easier to explicitly permit acceptable usage than to deny unacceptable usage.

Note: Changing firewall settings while connected over the network can result in being locked out of the system."
              solution    : "If NFTables utility is in use on your system:

Run the following command for the base chains with the input, forward, and output hooks to implement a default DROP policy:

# nft chain <table family> <table name> <chain name> { policy drop \; }

Example:

# nft chain inet filter input { policy drop \; }
# nft chain inet filter forward { policy drop \; }

Impact:

If configuring nftables over ssh, creating a base chain with a policy of drop will cause loss of connectivity.

Ensure that a rule allowing ssh has been added to the base chain prior to setting the base chain's policy to drop"
              reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <report type:"PASSED">
          description : "3.4.2.7 Ensure nftables default deny firewall policy"
          info        : "Base chain policy is the default verdict that will be applied to packets reaching the end of the chain.

There are two policies: accept (Default) and drop. If the policy is set to accept the firewall will accept any packet that is not configured to be denied and the packet will continue traversing the network stack.

It is easier to explicitly permit acceptable usage than to deny unacceptable usage.

Note: Changing firewall settings while connected over the network can result in being locked out of the system.

NOTE: The identified firewall 'nftables' was not found to be active and this check does not apply."
          solution    : "If NFTables utility is in use on your system:

Run the following command for the base chains with the input, forward, and output hooks to implement a default DROP policy:

# nft chain <table family> <table name> <chain name> { policy drop \; }

Example:

# nft chain inet filter input { policy drop \; }
# nft chain inet filter forward { policy drop \; }

Impact:

If configuring nftables over ssh, creating a base chain with a policy of drop will cause loss of connectivity.

Ensure that a rule allowing ssh has been added to the base chain prior to setting the base chain's policy to drop"
          reference   : "800-171|3.13.1,800-171|3.13.5,800-171|3.13.6,800-53|CA-9,800-53|SC-7,800-53|SC-7(5),800-53r5|CA-9,800-53r5|SC-7,800-53r5|SC-7(5),CN-L3|7.1.2.2(c),CN-L3|8.1.10.6(j),CSCv7|9.4,CSCv8|4.4,CSF|DE.CM-1,CSF|ID.AM-3,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,CSF2.0|DE.CM-01,CSF2.0|ID.AM-03,CSF2.0|PR.DS-01,CSF2.0|PR.DS-02,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,GDPR|32.1.d,GDPR|32.2,HIPAA|164.306(a)(1),ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,ITSG-33|SC-7(5),LEVEL|2A,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,NIAv2|GS7b,NIAv2|NS25,PCI-DSSv3.2.1|1.1,PCI-DSSv3.2.1|1.2,PCI-DSSv3.2.1|1.2.1,PCI-DSSv3.2.1|1.3,PCI-DSSv4.0|1.2.1,PCI-DSSv4.0|1.4.1,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,QCSC-v1|5.2.3,QCSC-v1|6.2,QCSC-v1|8.2.1,SWIFT-CSCv1|2.1,TBA-FIISB|43.1"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : RPM_CHECK
          description : "openssh-server is installed"
          rpm         : "openssh-server-0.0.0-0"
          operator    : "gt"
          required    : YES
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : FILE_CONTENT_CHECK_NOT
              description : "sshd -T - X11Forwarding"
              file        : "/etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf"
              regex       : "^[\\s]*(?i)X11Forwarding(?-i)[\\s]"
              expect      : "^[\\s]*(?i)X11Forwarding(?-i)[\\s]+\"?yes\"?[\\s]*$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "sshd -T - x11forwarding"
              cmd         : "#!/bin/bash
  {
  ports=$(/bin/grep -s -P \"^(Port|Match)\" /etc/ssh/sshd_config /etc/sshd_config.d/*.conf | /bin/grep -P -o \"(Port|LocalPort)[\\s]+[\\d]+\" | /bin/awk '{print $2}; END {if (NR == 0) print \"22\"}' | /bin/uniq); for port in ${ports[@]}; do /sbin/sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(/bin/grep $(hostname) /etc/hosts | /bin/awk '{print $1}')\" -C lport=$port | echo \"port $port: $(/bin/grep -i ^x11forwarding)\"; done | /bin/awk 'BEGIN {f=0} /x11forwarding/i { if ($NF == \"yes\") f++; print $0} END {if (NR == 0) print \"Fail: no results returned\"; else if (f > 0) print \"Fail\"; else print \"Pass\" }'
  }"
              expect      : "^Pass$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "4.2.12 Ensure SSH X11 forwarding is disabled"
              info        : "The X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections.

Disable X11 forwarding unless there is an operational requirement to use X11 applications directly. There is a small risk that the remote X11 servers of users who are logged in via SSH with X11 forwarding could be compromised by other users on the X11 server. Note that even if X11 forwarding is disabled, users can always install their own forwarders."
              solution    : "Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the X11Forwarding parameter as follows:

X11Forwarding no

Run the following command to comment out any X11Forwarding parameter entries in files ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file that include any setting other than no

# grep -Pi '^\h*X11Forwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri \"/^\s*X11Forwarding\s+/s/^/# /\" \"$(awk -F: '{print $1}' <<< $l_out)\";done"
              reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <report type:"PASSED">
          description : "4.2.12 Ensure SSH X11 forwarding is disabled"
          info        : "The X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections.

Disable X11 forwarding unless there is an operational requirement to use X11 applications directly. There is a small risk that the remote X11 servers of users who are logged in via SSH with X11 forwarding could be compromised by other users on the X11 server. Note that even if X11 forwarding is disabled, users can always install their own forwarders."
          solution    : "Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the X11Forwarding parameter as follows:

X11Forwarding no

Run the following command to comment out any X11Forwarding parameter entries in files ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file that include any setting other than no

# grep -Pi '^\h*X11Forwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri \"/^\s*X11Forwarding\s+/s/^/# /\" \"$(awk -F: '{print $1}' <<< $l_out)\";done"
          reference   : "800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-53|CM-6,800-53|CM-7,800-53r5|CM-6,800-53r5|CM-7,CSCv7|9.2,CSCv8|4.8,CSF|PR.IP-1,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|PR.PS-01,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-6,ITSG-33|CM-7,LEVEL|2A,NIAv2|SS15a,PCI-DSSv3.2.1|2.2.2,SWIFT-CSCv1|2.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : RPM_CHECK
          description : "openssh-server is installed"
          rpm         : "openssh-server-0.0.0-0"
          operator    : "gt"
          required    : YES
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : FILE_CONTENT_CHECK_NOT
              description : "ssh config files - AllowTcpForwarding"
              file        : "/etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf"
              regex       : "^[\\s]*(?i)AllowTcpForwarding(?-i)[\\s]"
              expect      : "^[\\s]*(?i)AllowTcpForwarding(?-i)[\\s]+\"?yes\"?[\\s]*$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "sshd -T - AllowTcpForwarding"
              cmd         : "#!/bin/bash
  {
  ports=$(/bin/grep -s -P \"^(Port|Match)\" /etc/ssh/sshd_config /etc/sshd_config.d/*.conf | /bin/grep -P -o \"(Port|LocalPort)[\\s]+[\\d]+\" | /bin/awk '{print $2}; END {if (NR == 0) print \"22\"}' | /bin/uniq); for port in ${ports[@]}; do /sbin/sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(/bin/grep $(hostname) /etc/hosts | /bin/awk '{print $1}')\" -C lport=$port | echo \"port $port: $(/bin/grep -i ^allowtcpforwarding)\"; done | /bin/awk 'BEGIN {f=0} /allowtcpforwarding/i { if ($NF == \"yes\") f++; print $0} END {if (NR == 0) print \"Fail: no results returned\"; else if (f > 0) print \"Fail\"; else print \"Pass\" }'
  }"
              expect      : "^Pass$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "4.2.13 Ensure SSH AllowTcpForwarding is disabled"
              info        : "SSH port forwarding is a mechanism in SSH for tunneling application ports from the client to the server, or servers to clients. It can be used for adding encryption to legacy applications, going through firewalls, and some system administrators and IT professionals use it for opening backdoors into the internal network from their home machines

Leaving port forwarding enabled can expose the organization to security risks and back-doors.

SSH connections are protected with strong encryption. This makes their contents invisible to most deployed network monitoring and traffic filtering solutions. This invisibility carries considerable risk potential if it is used for malicious purposes such as data exfiltration. Cybercriminals or malware could exploit SSH to hide their unauthorized communications, or to exfiltrate stolen data from the target network"
              solution    : "Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the AllowTcpForwarding parameter as follows:

AllowTcpForwarding no

Run the following command to comment out any AllowTcpForwarding parameter entries in files ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file that include any setting other than no :

# grep -Pi '^\h*AllowTcpForwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri \"/^\s*AllowTcpForwarding\s+/s/^/# /\" \"$(awk -F: '{print $1}' <<< $l_out)\";done

Impact:

SSH tunnels are widely used in many corporate environments that employ mainframe systems as their application backends. In those environments the applications themselves may have very limited native support for security. By utilizing tunneling, compliance with SOX, HIPAA, PCI-DSS, and other standards can be achieved without having to modify the applications."
              reference   : "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|9.2,CSCv8|4.1,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|ID.AM-08,CSF2.0|ID.IM-01,CSF2.0|ID.IM-02,CSF2.0|ID.IM-03,CSF2.0|ID.RA-09,CSF2.0|PR.DS-10,CSF2.0|PR.IR-03,CSF2.0|PR.PS-01,CSF2.0|PR.PS-06,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|2A,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <report type:"PASSED">
          description : "4.2.13 Ensure SSH AllowTcpForwarding is disabled"
          info        : "SSH port forwarding is a mechanism in SSH for tunneling application ports from the client to the server, or servers to clients. It can be used for adding encryption to legacy applications, going through firewalls, and some system administrators and IT professionals use it for opening backdoors into the internal network from their home machines

Leaving port forwarding enabled can expose the organization to security risks and back-doors.

SSH connections are protected with strong encryption. This makes their contents invisible to most deployed network monitoring and traffic filtering solutions. This invisibility carries considerable risk potential if it is used for malicious purposes such as data exfiltration. Cybercriminals or malware could exploit SSH to hide their unauthorized communications, or to exfiltrate stolen data from the target network"
          solution    : "Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the AllowTcpForwarding parameter as follows:

AllowTcpForwarding no

Run the following command to comment out any AllowTcpForwarding parameter entries in files ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file that include any setting other than no :

# grep -Pi '^\h*AllowTcpForwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri \"/^\s*AllowTcpForwarding\s+/s/^/# /\" \"$(awk -F: '{print $1}' <<< $l_out)\";done

Impact:

SSH tunnels are widely used in many corporate environments that employ mainframe systems as their application backends. In those environments the applications themselves may have very limited native support for security. By utilizing tunneling, compliance with SOX, HIPAA, PCI-DSS, and other standards can be achieved without having to modify the applications."
          reference   : "800-171|3.4.1,800-171|3.4.2,800-171|3.4.6,800-171|3.4.7,800-171|3.13.1,800-171|3.13.2,800-53|CM-2,800-53|CM-6,800-53|CM-7,800-53|CM-7(1),800-53|CM-9,800-53|SA-3,800-53|SA-8,800-53|SA-10,800-53r5|CM-1,800-53r5|CM-2,800-53r5|CM-6,800-53r5|CM-7,800-53r5|CM-7(1),800-53r5|CM-9,800-53r5|SA-3,800-53r5|SA-8,800-53r5|SA-10,CSCv7|9.2,CSCv8|4.1,CSF|DE.AE-1,CSF|PR.DS-7,CSF|PR.IP-1,CSF|PR.IP-2,CSF|PR.IP-3,CSF|PR.PT-3,CSF2.0|DE.CM-09,CSF2.0|ID.AM-08,CSF2.0|ID.IM-01,CSF2.0|ID.IM-02,CSF2.0|ID.IM-03,CSF2.0|ID.RA-09,CSF2.0|PR.DS-10,CSF2.0|PR.IR-03,CSF2.0|PR.PS-01,CSF2.0|PR.PS-06,GDPR|32.1.b,HIPAA|164.306(a)(1),ITSG-33|CM-2,ITSG-33|CM-6,ITSG-33|CM-7,ITSG-33|CM-7(1),ITSG-33|CM-9,ITSG-33|SA-3,ITSG-33|SA-8,ITSG-33|SA-8a.,ITSG-33|SA-10,LEVEL|2A,NESA|T1.2.1,NESA|T1.2.2,NESA|T3.2.5,NESA|T3.4.1,NESA|T4.5.3,NESA|T4.5.4,NESA|T7.2.1,NESA|T7.5.1,NESA|T7.5.3,NESA|T7.6.1,NESA|T7.6.2,NESA|T7.6.3,NESA|T7.6.5,NIAv2|SS3,NIAv2|SS15a,NIAv2|SS16,NIAv2|VL2,PCI-DSSv3.2.1|2.2.2,QCSC-v1|3.2,QCSC-v1|4.2,QCSC-v1|5.2.1,QCSC-v1|5.2.2,SWIFT-CSCv1|2.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
        </report>
      </else>
    </if>

    <custom_item>
      type        : RPM_CHECK
      description : "5.2.1.1 Ensure auditd is installed"
      info        : "auditd is the userspace component to the Linux Auditing System. It's responsible for writing audit records to the disk

The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
      solution    : "Run the following command to Install auditd

# dnf install audit"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(a),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      rpm         : "audit-0.0.0-0"
      operator    : "gt"
      required    : YES
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.1.2 Ensure auditing for processes that start prior to auditd is enabled"
      info        : "Configure grub2 so that processes that are capable of being audited can be audited even if they start up prior to auditd startup.

Audit events need to be captured on processes that start up prior to auditd so that potential malicious activity cannot go undetected."
      solution    : "Run the following command to update the grub2 configuration with audit=1 :

# grubby --update-kernel ALL --args 'audit=1'"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/sbin/grubby --info=ALL | /bin/grep -Po '\\baudit=1\\b' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.1.3 Ensure audit_backlog_limit is sufficient"
      info        : "The backlog limit has a default setting of 64

During boot if audit=1 then the backlog will hold 64 records. If more that 64 records are created during boot, auditd records will be lost and potential malicious activity could go undetected."
      solution    : "Run the following command to add audit_backlog_limit=<BACKLOG SIZE> to GRUB_CMDLINE_LINUX:

# grubby --update-kernel ALL --args 'audit_backlog_limit=<BACKLOG SIZE>'

Example:

# grubby --update-kernel ALL --args 'audit_backlog_limit=8192'"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/sbin/grubby --info=ALL | /bin/grep -Po '\\baudit_backlog_limit=@BACKLOG_SIZE@\\b' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.1.4 Ensure auditd service is enabled"
      info        : "Turn on the auditd daemon to record system events.

The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
      solution    : "Run the following command to enable auditd :

# systemctl --now enable auditd"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv7|6.3,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/systemctl is-enabled auditd | /bin/awk '{print} END {if(NR==0) print \"disabled\" }'"
      expect      : "^enabled$"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "5.2.2.1 Ensure audit log storage size is configured"
      info        : "Configure the maximum size of the audit log file. Once the log reaches the maximum size, it will be rotated and a new log file will be started.

It is important that an appropriate size is determined for log files so that they do not impact the system and audit data is not lost."
      solution    : "Set the following parameter in /etc/audit/auditd.conf in accordance with site policy:

max_log_file = <MB>"
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      file        : "/etc/audit/auditd.conf"
      regex       : "^[\\s]*max_log_file[\\s]*="
      expect      : "^[\\s]*max_log_file[\\s]*=[\\s]*@MAX_AUDIT_LOG_FILE_SIZE@[\\s]*$"
    </custom_item>

    <custom_item>
      type        : FILE_CONTENT_CHECK
      description : "5.2.2.2 Ensure audit logs are not automatically deleted"
      info        : "The max_log_file_action setting determines how to handle the audit log file reaching the max file size. A value of keep_logs will rotate the logs but never delete old logs.

In high security contexts, the benefits of maintaining a long audit history exceed the cost of storing the audit history."
      solution    : "Set the following parameter in /etc/audit/auditd.conf:

max_log_file_action = keep_logs"
      reference   : "800-53|AU-4,800-53r5|AU-4,CSCv7|6.4,CSCv8|8.3,CSF|PR.DS-4,CSF|PR.PT-1,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-4,LEVEL|2A,NESA|T3.3.1,NESA|T3.6.2,QCSC-v1|8.2.1,QCSC-v1|13.2"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      file        : "/etc/audit/auditd.conf"
      regex       : "^[\\s]*max_log_file_action[\\s]*="
      expect      : "^[\\s]*max_log_file_action[\\s]*=[\\s]*(?i)keep_logs(?-i)[\\s]*$"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "auditd.conf - space_left_action"
          file        : "/etc/audit/auditd.conf"
          regex       : "^[\\s]*(?i)space_left_action(?-i)[\\s]*=[\\s]*"
          expect      : "^[\\s]*(?i)space_left_action(?-i)[\\s]*=[\\s]*(?i)email(?-i)[\\s]*$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "auditd.conf - action_mail_acct"
          file        : "/etc/audit/auditd.conf"
          regex       : "^[\\s]*(?i)action_mail_acct(?-i)[\\s]*="
          expect      : "^[\\s]*(?i)action_mail_acct(?-i)[\\s]*=[\\s]*(?i)root(?-i)[\\s]*$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "auditd.conf - admin_space_left_action"
          file        : "/etc/audit/auditd.conf"
          regex       : "^[\\s]*admin_space_left_action[\\s]*="
          expect      : "^[\\s]*admin_space_left_action[\\s]*=[\\s]*(?i)(halt|single)(?-i)[\\s]*$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.2.3 Ensure system is disabled when audit logs are full"
          info        : "The auditd daemon can be configured to halt the system when the audit logs are full.

The admin_space_left_action parameter tells the system what action to take when the system has detected that it is low on disk space. Valid values are ignore, syslog, suspend, single, and halt.

 - ignore the audit daemon does nothing
 - Syslog the audit daemon will issue a warning to syslog
 - Suspend the audit daemon will stop writing records to the disk
 - single the audit daemon will put the computer system in single user mode
 - halt the audit daemon will shut down the system

In high security contexts, the risk of detecting unauthorized access or nonrepudiation exceeds the benefit of the system's availability."
          solution    : "Set the following parameters in /etc/audit/auditd.conf:

space_left_action = email
action_mail_acct = root

set admin_space_left_action to either halt or single in /etc/audit/auditd.conf

Example:

admin_space_left_action = halt

Impact:

If the admin_space_left_action parameter is set to halt the audit daemon will shutdown the system when the disk partition containing the audit logs becomes full."
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-4,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-4,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv8|8.2,CSCv8|8.3,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.DS-4,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-4,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NESA|T3.3.1,NESA|T3.6.2,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/sudoers"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/sudoers.d"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sudoers\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/sudoers"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sudoers/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/sudoers.d"
          cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sudoers\\.d/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.1 Ensure changes to system administration scope (sudoers) is collected"
          info        : "Monitor scope changes for system administrators. If the system has been properly configured to force system administrators to log in as themselves first and then use the sudo command to execute privileged commands, it is possible to monitor changes in scope. The file /etc/sudoers or files in /etc/sudoers.d will be written to when the file(s) or related attributes have changed. The audit records will be tagged with the identifier \"scope\".

Changes in the /etc/sudoers and /etc/sudoers.d files can indicate that an unauthorized change has been made to the scope of system administrator activity."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor scope changes for system administrators.

Example:

# printf \"
-w /etc/sudoers -p wa -k scope
-w /etc/sudoers.d -p wa -k scope
\" >> /etc/audit/rules.d/50-scope.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.8,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.10 Ensure successful file system mounts are collected"
              info        : "Monitor the use of the mount system call. The mount (and umount ) system call controls the mounting and unmounting of file systems. The parameters below configure the system to create an audit record when the mount system call is used by a non-privileged user

It is highly unusual for a non privileged user to mount file systems to the system. While tracking mount commands gives the system administrator evidence that external media may have been mounted (based on a review of the source of the mount and confirming it's an external media type), it does not conclusively indicate that data was exported to the media. System administrators who wish to determine if data were exported, would also have to track successful open creat and truncate system calls requiring write access to a file under the mount point of the external media file system. This could give a fair indication that a write occurred. The only way to truly prove it, would be to track successful writes to the external media. Tracking write system calls could quickly fill up the audit log and is not recommended. Recommendations on configuration options to track data export to media is beyond the scope of this document."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful file system mounts.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=unset -k mounts
-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=unset -k mounts
\" >> /etc/audit/rules.d/50-mounts.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -S/ &&/mount/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.10 Ensure successful file system mounts are collected"
              info        : "Monitor the use of the mount system call. The mount (and umount ) system call controls the mounting and unmounting of file systems. The parameters below configure the system to create an audit record when the mount system call is used by a non-privileged user

It is highly unusual for a non privileged user to mount file systems to the system. While tracking mount commands gives the system administrator evidence that external media may have been mounted (based on a review of the source of the mount and confirming it's an external media type), it does not conclusively indicate that data was exported to the media. System administrators who wish to determine if data were exported, would also have to track successful open creat and truncate system calls requiring write access to a file under the mount point of the external media file system. This could give a fair indication that a write occurred. The only way to truly prove it, would be to track successful writes to the external media. Tracking write system calls could quickly fill up the audit log and is not recommended. Recommendations on configuration options to track data export to media is beyond the scope of this document."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful file system mounts.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=unset -k mounts
-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=unset -k mounts
\" >> /etc/audit/rules.d/50-mounts.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl utmp"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/run\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "utmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/run\\/utmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl wtmp"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/log\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "btmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/log\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl btmp"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/  &&/\\/var\\/log\\/btmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "wtmp"
          cmd         : "/bin/awk '/^ *-w/  &&/\\/var\\/log\\/wtmp/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "pass"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.11 Ensure session initiation information is collected"
          info        : "Monitor session initiation events. The parameters in this section track changes to the files associated with session events.

 - /var/run/utmp - tracks all currently logged in users.
 - /var/log/wtmp - file tracks logins, logouts, shutdown, and reboot events.
 - /var/log/btmp - keeps track of failed login attempts and can be read by entering the command /usr/bin/last -f /var/log/btmp

All audit records will be tagged with the identifier \"session.\"

Monitoring these files for changes could alert a system administrator to logins occurring at unusual hours, which could indicate intruder activity (i.e. a user logging in at a time when they do not normally log in)."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor session initiation information.

Example:

# printf \"
-w /var/run/utmp -p wa -k session
-w /var/log/wtmp -p wa -k session
-w /var/log/btmp -p wa -k session
\" >> /etc/audit/rules.d/50-session.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv7|16.13,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl faillock"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ && /\\/var\\/run\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "faillock"
          cmd         : "/bin/awk '/^ *-w/ && /\\/var\\/run\\/faillock/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "lastlog"
          cmd         : "/bin/awk '/^ *-w/ && /\\/var\\/log\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl lastlog"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ && /\\/var\\/log\\/lastlog/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' "
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.12 Ensure login and logout events are collected"
          info        : "Monitor login and logout events. The parameters below track changes to files associated with login/logout events.

 - /var/log/lastlog - maintain records of the last time a user successfully logged in.
 - /var/run/faillock - directory maintains records of login failures via the pam_faillock module.

Monitoring login/logout events could provide a system administrator with information associated with brute force attacks against user logins."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor login and logout events.

Example:

# printf \"
-w /var/log/lastlog -p wa -k logins
-w /var/run/faillock -p wa -k logins
\" >> /etc/audit/rules.d/50-login.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv7|16.11,CSCv7|16.13,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b64/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.13 Ensure file deletion events by users are collected"
              info        : "Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for:

 - unlink - remove a file
 - unlinkat - remove a file attribute
 - rename - rename a file
 - renameat rename a file attributesystem calls and tags them with the identifier \"delete\".

Monitoring these calls from non-privileged users could provide a system administrator with evidence that inappropriate removal of files and file attributes associated with protected files is occurring. While this audit option will look at all events, system administrators will want to look for specific privileged files that are being deleted or altered."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor file deletion events by users.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
-a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
\" >> /etc/audit/rules.d/50-delete.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules  | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 unlink"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/)  &&/ -F *arch=b32/  &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/)  &&/ -F *auid>=${UID_MIN}/  &&/ -S/  &&(/unlink/||/rename/||/unlinkat/||/renameat/)  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.13 Ensure file deletion events by users are collected"
              info        : "Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for:

 - unlink - remove a file
 - unlinkat - remove a file attribute
 - rename - rename a file
 - renameat rename a file attributesystem calls and tags them with the identifier \"delete\".

Monitoring these calls from non-privileged users could provide a system administrator with evidence that inappropriate removal of files and file attributes associated with protected files is occurring. While this audit option will look at all events, system administrators will want to look for specific privileged files that are being deleted or altered."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor file deletion events by users.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
-a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete
\" >> /etc/audit/rules.d/50-delete.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "*.rules /etc/selinux"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "*.rules /usr/share/selinux"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/usr\\/share\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/selinux"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /usr/share/selinux"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/usr\\/share\\/selinux/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.14 Ensure events that modify the system's Mandatory Access Controls are collected"
          info        : "Monitor SELinux, an implementation of mandatory access controls. The parameters below monitor any write access (potential additional, deletion or modification of files in the directory) or attribute changes to the /etc/selinux/ and /usr/share/selinux/ directories.

Note: If a different Mandatory Access Control method is used, changes to the corresponding directories should be audited.

Changes to files in the /etc/selinux/ and /usr/share/selinux/ directories could indicate that an unauthorized user is attempting to modify access controls and change security contexts, leading to a compromise of the system."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the system's Mandatory Access Controls.

Example:

# printf \"
-w /etc/selinux -p wa -k MAC-policy
-w /usr/share/selinux -p wa -k MAC-policy
\" >> /etc/audit/rules.d/50-MAC-policy.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chcon/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.15 Ensure successful and unsuccessful attempts to use the chcon command are recorded"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the chcon command.

Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the chcon command.

64 Bit systems

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/setfacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.16 Ensure successful and unsuccessful attempts to use the setfacl command are recorded"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the setfacl command

Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the setfacl command.

64 Bit systems

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/bin\\/chacl/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.17 Ensure successful and unsuccessful attempts to use the chacl command are recorded"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the chacl command

Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the chacl command.

64 Bit systems

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d/*.rules"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/sbin\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk  \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *perm=x/ &&/ -F *path=\\/usr\\/sbin\\/usermod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/) \" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf  \"ERROR: Variable 'UID_MIN' is unset. \\n \""
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.18 Ensure successful and unsuccessful attempts to use the usermod command are recorded"
          info        : "The operating system must generate audit records for successful/unsuccessful uses of the usermod command.

Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.

Audit records can be generated from various components within the information system (e.g., module or policy filter)."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor successful and unsuccessful attempts to use the usermod command.

64 Bit systems

Example:

# {
 UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k usermod
\" >> /etc/audit/rules.d/50-usermod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-2,800-53|AU-7,800-53|AU-12,800-53r5|AU-2,800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(c),CN-L3|8.1.4.3(a),CSCv7|6.2,CSCv8|8.2,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-2,ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|M1.2.2,NESA|M5.5.1,NIAv2|AM7,NIAv2|AM11a,NIAv2|AM11b,NIAv2|AM11c,NIAv2|AM11d,NIAv2|AM11e,NIAv2|SS30,NIAv2|VL8,PCI-DSSv3.2.1|10.1,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl create_module"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/create_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "pass"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/usr/bin/kmod"
          cmd         : "{
 UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) \\
 &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\
 &&/ -F *auid>=${UID_MIN}/ \\
 &&/ -F *perm=x/ \\
 &&/ -F *path=\\/usr\\/bin\\/kmod/ \\
 &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\
 || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"
} | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl delete_module"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/delete_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "on disk init_module"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/init_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl query_module"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/query_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "on disk finit_module"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/finit_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "on disk query_module"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/query_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "on disk create_module"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/create_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "kmod symlinks"
          cmd         : "#!/bin/bash
      {
        S_LINKS=$(ls -l /usr/sbin/lsmod /usr/sbin/rmmod /usr/sbin/insmod /usr/sbin/modinfo /usr/sbin/modprobe /usr/sbin/depmod | grep -vE \" -> (\\.\\.)?/bin/kmod\" || true) && if [[ \"${S_LINKS}\" != \"\" ]]; then printf \"Issue with symlinks: ${S_LINKS}\\n\"; else printf \"OK\\n\"; fi
      }"
          expect      : "^OK$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /usr/bin/kmod"
          cmd         : "{
UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)
 [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) \\
 &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\
 &&/ -F *auid>=${UID_MIN}/ \\
 &&/ -F *perm=x/ \\
 &&/ -F *path=\\/usr\\/bin\\/kmod/ \\
 &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\
 || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"
} | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl init_module"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/init_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "on disk delete_module"
          cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/delete_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl finit_module"
          cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b(32|64)/ &&/ -S/ &&/finit_module/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.19 Ensure kernel module loading unloading and modification is collected"
          info        : "Monitor the loading and unloading of kernel modules. All the loading / listing / dependency checking of modules is done by kmod via symbolic links.

The following system calls control loading and unloading of modules:

 - init_module - load a module
 - finit_module - load a module (used when the overhead of using cryptographically signed modules to determine the authenticity of a module can be avoided)
 - delete_module - delete a module
 - create_module - create a loadable module entry
 - query_module - query the kernel for various bits pertaining to modules

Any execution of the loading and unloading module programs and system calls will trigger an audit record with an identifier of modules

Monitoring the use of all the various ways to manipulate kernel modules could provide system administrators with evidence that an unauthorized change was made to a kernel module, possibly compromising the security of the system."
          solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor kernel module modification.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules
-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules
\" >> /etc/audit/rules.d/50-kernel_modules.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.2 Ensure actions as another user are always logged"
              info        : "sudo provides users with temporary elevated privileges to perform operations, either as the superuser or another user.

Creating an audit log of users with temporary elevated privileges and the operation(s) they performed is essential to reporting. Administrators will want to correlate the events written to the audit trail with the records written to sudo 's logfile to verify if unauthorized commands have been executed."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor elevated privileges.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
\" >> /etc/audit/rules.d/50-user_emulation.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "/etc/audit/rules.d/*.rules b32"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&(/ -C *euid!=uid/||/ -C *uid!=euid/) &&/ -S *execve/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.2 Ensure actions as another user are always logged"
              info        : "sudo provides users with temporary elevated privileges to perform operations, either as the superuser or another user.

Creating an audit log of users with temporary elevated privileges and the operation(s) they performed is essential to reporting. Administrators will want to correlate the events written to the audit trail with the records written to sudo 's logfile to verify if unauthorized commands have been executed."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor elevated privileges.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
\" >> /etc/audit/rules.d/50-user_emulation.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.3.20 Ensure the audit configuration is immutable"
      info        : "Set system audit so that audit rules cannot be modified with auditctl Setting the flag \"-e 2\" forces audit to be put in immutable mode. Audit changes can only be made on system reboot.

Note: This setting will require the system to be rebooted to update the active auditd configuration settings.

In immutable mode, unauthorized users cannot execute changes to the audit system to potentially hide malicious activity and then put the audit rules back. Users would most likely notice a system reboot and that could alert administrators of an attempt to make unauthorized audit changes."
      solution    : "Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line -e 2 at the end of the file:

Example:

# printf -- \"-e 2\" >> /etc/audit/rules.d/99-finalize.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,800-53r5|MP-2,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.3(b),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|6.2,CSCv7|6.3,CSCv8|3.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-1,CSF|PR.PT-2,CSF|PR.PT-3,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),HIPAA|164.312(b),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T3.6.2,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,SWIFT-CSCv1|6.4,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/grep -Ph -- '^\\h*-e\\h+2\\b' /etc/audit/rules.d/*.rules | tail -1"
      expect      : "^[\\s]*-e[\\s]+2[\\s]*$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.3.21 Ensure the running and on disk configuration is the same"
      info        : "The Audit system have both on disk and running configuration. It is possible for these configuration settings to differ.

Note: Due to the limitations of augenrules and auditctl it is not absolutely guaranteed that loading the rule sets via augenrules --load will result in all rules being loaded or even that the user will be informed if there was a problem loading the rules.

Configuration differences between what is currently running and what is on disk could cause unexpected problems or may give a false impression of compliance requirements."
      solution    : "If the rules are not aligned across all three () areas, run the following command to merge and load all rules:

# augenrules --load

Check if reboot is required.

if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then echo \"Reboot required to load rules\"; fi"
      reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.3,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2M,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/sbin/augenrules --check"
      expect      : "^[\\s]*/sbin/augenrules:[\\s]*No change[\\s]*$"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "sudo log"
          cmd         : "SUDO_LOG_FILE_ESCAPED=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g'); [ -n \"${SUDO_LOG_FILE_ESCAPED}\" ] && awk \"/^ *-w/ &&/\"${SUDO_LOG_FILE_ESCAPED}\"/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl sudo log"
          cmd         : "SUDO_LOG_FILE_ESCAPED=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g'); [ -n \"${SUDO_LOG_FILE_ESCAPED}\" ] && auditctl -l | /bin/awk \"/^ *-w/ &&/\"${SUDO_LOG_FILE_ESCAPED}\"/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.3 Ensure events that modify the sudo log file are collected"
          info        : "Monitor the sudo log file. If the system has been properly configured to disable the use of the su command and force all administrators to have to log in first and then use sudo to execute privileged commands, then all administrator commands will be logged to /var/log/sudo.log Any time a command is executed, an audit event will be triggered as the /var/log/sudo.log file will be opened for write and the executed administration command will be written to the log.

Changes in /var/log/sudo.log indicate that an administrator has executed a command or the log file itself has been tampered with. Administrators will want to correlate the events written to the audit trail with the records written to /var/log/sudo.log to verify if unauthorized commands have been executed."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the sudo log file.

Example:

# {
SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g')
[ -n \"${SUDO_LOG_FILE}\" ] && printf \"
-w ${SUDO_LOG_FILE} -p wa -k sudo_log_file
\" >> /etc/audit/rules.d/50-sudo.rules || printf \"ERROR: Variable 'SUDO_LOG_FILE_ESCAPED' is unset.\n\"
}

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/localtime"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/localtime"
              cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex x64"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex x64"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.4 Ensure events that modify date and time information are collected"
              info        : "Capture events where the system date and/or time has been modified. The parameters in this section are set to determine if the;

 - adjtimex - tune kernel clock
 - settimeofday - set time using timeval and timezone structures
 - stime - using seconds since 1/1/1970
 - clock_settime - allows for the setting of several internal clocks and timers

system calls have been executed. Further, ensure to write an audit record to the configured audit log file upon exit, tagging the records with a unique identifier such as \"time-change\".

Unexpected changes in system date and/or time could be a sign of malicious activity on the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify date and time information.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
-a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime -k time-change
-w /etc/localtime -p wa -k time-change
\" >> /etc/audit/rules.d/50-time-change.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64 In addition, add stime to the system call audit. Example:

-a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl clock_settime x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "adjtimex x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "settimeofday x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl settimeofday x32"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/settimeofday/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/localtime"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "clock_settime x64"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/clock_settime/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/localtime"
              cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/localtime/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl adjtimex x64"
              cmd         : "auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/adjtimex/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.4 Ensure events that modify date and time information are collected"
              info        : "Capture events where the system date and/or time has been modified. The parameters in this section are set to determine if the;

 - adjtimex - tune kernel clock
 - settimeofday - set time using timeval and timezone structures
 - stime - using seconds since 1/1/1970
 - clock_settime - allows for the setting of several internal clocks and timers

system calls have been executed. Further, ensure to write an audit record to the configured audit log file upon exit, tagging the records with a unique identifier such as \"time-change\".

Unexpected changes in system date and/or time could be a sign of malicious activity on the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify date and time information.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
-a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime -k time-change
-w /etc/localtime -p wa -k time-change
\" >> /etc/audit/rules.d/50-time-change.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64 In addition, add stime to the system call audit. Example:

-a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/issue"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/issue.net"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 sethostname"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/issue"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 sethostname"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/sysconfig/network-scripts"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/issue.net"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/sysconfig/network-scripts"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/sysconfig/network"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 sethostname"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/hosts"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 sethostname"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/sysconfig/network"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/hosts"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.5 Ensure events that modify the system's network environment are collected"
              info        : "Record changes to network environment files or system calls. The below parameters monitors the following system calls, and write an audit event on system call exit:

 - sethostname - set the systems host name
 - setdomainname - set the systems domain name

The files being monitored are:

 - /etc/issue and /etc/issue.net - messages displayed pre-login
 - /etc/hosts - file containing host names and associated IP addresses
 - /etc/sysconfig/network - additional information that is valid to all network interfaces
 - /etc/sysconfig/network-scripts/ - directory containing network interface scripts and configurations files

Monitoring sethostname and setdomainname will identify potential unauthorized changes to host and domain name of a system. The changing of these names could potentially break security parameters that are set based on those names. The /etc/hosts file is monitored for changes that can indicate an unauthorized intruder is trying to change machine associations with IP addresses and trick users and processes into connecting to unintended machines. Monitoring /etc/issue and /etc/issue.net is important, as intruders could put disinformation into those files and trick users into providing information to the intruder. Monitoring /etc/sysconfig/network is important as it can show if network interfaces or scripts are being modified in a way that can lead to the machine becoming unavailable or compromised. All audit records should have a relevant tag associated with them."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the system's network environment.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
-a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
-w /etc/issue -p wa -k system-locale
-w /etc/issue.net -p wa -k system-locale
-w /etc/hosts -p wa -k system-locale
-w /etc/sysconfig/network -p wa -k system-locale
-w /etc/sysconfig/network-scripts/ -p wa -k system-locale
\" >> /etc/audit/rules.d/50-system_local.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/issue"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/issue.net"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/issue"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/issue/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 sethostname"
              cmd         : "/sbin/auditctl -l | /bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/sysconfig/network-scripts"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/issue.net"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/issue.net/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/sysconfig/network-scripts"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network-scripts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/sysconfig/network"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 sethostname"
              cmd         : "/bin/awk '(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&/ -S/ &&/sethostname/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/hosts"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl /etc/sysconfig/network"
              cmd         : "/sbin/auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/sysconfig\\/network/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "/etc/hosts"
              cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/hosts/ &&/ +-p *wa/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.5 Ensure events that modify the system's network environment are collected"
              info        : "Record changes to network environment files or system calls. The below parameters monitors the following system calls, and write an audit event on system call exit:

 - sethostname - set the systems host name
 - setdomainname - set the systems domain name

The files being monitored are:

 - /etc/issue and /etc/issue.net - messages displayed pre-login
 - /etc/hosts - file containing host names and associated IP addresses
 - /etc/sysconfig/network - additional information that is valid to all network interfaces
 - /etc/sysconfig/network-scripts/ - directory containing network interface scripts and configurations files

Monitoring sethostname and setdomainname will identify potential unauthorized changes to host and domain name of a system. The changing of these names could potentially break security parameters that are set based on those names. The /etc/hosts file is monitored for changes that can indicate an unauthorized intruder is trying to change machine associations with IP addresses and trick users and processes into connecting to unintended machines. Monitoring /etc/issue and /etc/issue.net is important, as intruders could put disinformation into those files and trick users into providing information to the intruder. Monitoring /etc/sysconfig/network is important as it can show if network interfaces or scripts are being modified in a way that can lead to the machine becoming unavailable or compromised. All audit records should have a relevant tag associated with them."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify the system's network environment.

64 Bit systems

Example:

# printf \"
-a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
-a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
-w /etc/issue -p wa -k system-locale
-w /etc/issue.net -p wa -k system-locale
-w /etc/hosts -p wa -k system-locale
-w /etc/sysconfig/network -p wa -k system-locale
-w /etc/sysconfig/network-scripts/ -p wa -k system-locale
\" >> /etc/audit/rules.d/50-system_local.rules

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "auditctl"
          cmd         : "RUNNING=$(/sbin/auditctl -l); [ -n \"${RUNNING}\" ] && for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do printf -- \"${RUNNING}\" | /bin/grep -q \"${PRIVILEGED}\" && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in running configuration.\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'"
          expect      : "^Pass - No warning entries found$"
          timeout     : "@FIND_TIMEOUT@"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/audit/rules.d"
          cmd         : "for PARTITION in $(/bin/findmnt -n -l -k -it $(/bin/awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | /bin/grep -Pv \"noexec|nosuid\" | /bin/awk '{print $1}'); do for PRIVILEGED in $(/bin/find \"${PARTITION}\" -xdev -perm /6000 -type f); do /bin/grep -qr \"${PRIVILEGED}\" /etc/audit/rules.d && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in on disk configuration.\\n\"; done; done | /bin/awk '{print} END { if ($1 ~ \"Warning\") print \"Fail - Warnings found\"; else print \"Pass - No warning entries found\" }'"
          expect      : "^Pass - No warning entries found$"
          timeout     : "@FIND_TIMEOUT@"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.6 Ensure use of privileged commands are collected"
          info        : "Monitor privileged programs, those that have the setuid and/or setgid bit set on execution, to determine if unprivileged users are running these commands.

Execution of privileged commands by non-privileged users could be an indication of someone trying to gain unauthorized access to the system."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor the use of privileged commands.

Example:

# {
  UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
  AUDIT_RULE_FILE=\"/etc/audit/rules.d/50-privileged.rules\"
  NEW_DATA=()
  for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\" | awk '{print $1}'); do
    readarray -t DATA < <(find \"${PARTITION}\" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print \"-a always,exit -F path=\" $1 \" -F perm=x -F auid>=\"UID_MIN\" -F auid!=unset -k privileged\" }')
      for ENTRY in \"${DATA[@]}\"; do
        NEW_DATA+=(\"${ENTRY}\")
      done
  done
  readarray &> /dev/null -t OLD_DATA < \"${AUDIT_RULE_FILE}\"
  COMBINED_DATA=( \"${OLD_DATA[@]}\" \"${NEW_DATA[@]}\" )
  printf '%s\n' \"${COMBINED_DATA[@]}\" | sort -u > \"${AUDIT_RULE_FILE}\"
}

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

Special mount points

If there are any special mount points that are not visible by default from just scanning / change the PARTITION variable to the appropriate partition and re-run the remediation.

Impact:

Both the audit and remediation section of this recommendation will traverse all mounted file systems that is not mounted with either noexec or nosuid mount options. If there are large file systems without these mount options, such traversal will be significantly detrimental to the performance of the system.

Before running either the audit or remediation section, inspect the output of the following command to determine exactly which file systems will be traversed:

# findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\"

To exclude a particular file system due to adverse performance impacts, update the audit and remediation sections by adding a sufficiently unique string to the grep statement. The above command can be used to test the modified exclusions."
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|6.2,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.7 Ensure unsuccessful file access attempts are collected"
              info        : "Monitor for unsuccessful attempts to access files. The following parameters are associated with system calls that control files:

 - creation - creat
 - opening - open openat
 - truncation - truncate ftruncate

An audit log record will only be written if all of the following criteria is met for the user when trying to access a file:

 - a non-privileged user (auid>=UID_MIN)
 - is not a Daemon event (auid=4294967295/unset/-1)
 - if the system call returned EACCES (permission denied) or EPERM (some other permanent error associated with the specific system call)

Failed attempts to open, create or truncate files could be an indication that an individual or process is trying to gain unauthorized access to the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor unsuccessful file access attempts.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
\" >> /etc/audit/rules.d/50-access.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EACCES"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EACCES/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 EPERM"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -F *auid>=${UID_MIN}/ &&/ -F *exit=-EPERM/ &&/ -S/ &&/creat/ &&/open/ &&/truncate/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.7 Ensure unsuccessful file access attempts are collected"
              info        : "Monitor for unsuccessful attempts to access files. The following parameters are associated with system calls that control files:

 - creation - creat
 - opening - open openat
 - truncation - truncate ftruncate

An audit log record will only be written if all of the following criteria is met for the user when trying to access a file:

 - a non-privileged user (auid>=UID_MIN)
 - is not a Daemon event (auid=4294967295/unset/-1)
 - if the system call returned EACCES (permission denied) or EPERM (some other permanent error associated with the specific system call)

Failed attempts to open, create or truncate files could be an indication that an individual or process is trying to gain unauthorized access to the system."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor unsuccessful file access attempts.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
\" >> /etc/audit/rules.d/50-access.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|14.9,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "/etc/shadow"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/gshadow"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/group"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/passwd"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/security/opasswd"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/security\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/group"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/group/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/shadow"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/shadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/passwd"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/passwd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "/etc/security/opasswd"
          cmd         : "/bin/awk '/^ *-w/ &&/\\/etc\\/security\\/opasswd/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>

        <custom_item>
          type        : CMD_EXEC
          description : "auditctl /etc/gshadow"
          cmd         : "auditctl -l | /bin/awk '/^ *-w/ &&/\\/etc\\/gshadow/ &&/ +-p *wa/  &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}'"
          expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.3.8 Ensure events that modify user/group information are collected"
          info        : "Record events affecting the modification of user or group information, including that of passwords and old passwords if in use.

 - /etc/group - system groups
 - /etc/passwd - system users
 - /etc/gshadow - encrypted password for each group
 - /etc/shadow - system user passwords
 - /etc/security/opasswd - storage of old passwords if the relevant PAM module is in use

The parameters in this section will watch the files to see if they have been opened for write or have had attribute changes (e.g. permissions) and tag them with the identifier \"identity\" in the audit log file.

Unexpected changes to these files could be an indication that the system has been compromised and that an unauthorized user is attempting to hide their activities or compromise additional accounts."
          solution    : "Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor events that modify user/group information.

Example:

# printf \"
-w /etc/group -p wa -k identity
-w /etc/passwd -p wa -k identity
-w /etc/gshadow -p wa -k identity
-w /etc/shadow -p wa -k identity
-w /etc/security/opasswd -p wa -k identity
\" >> /etc/audit/rules.d/50-identity.rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi"
          reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|4.8,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <if>
      <condition type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "OS 64bit check"
          cmd         : "/bin/uname -a | /bin/grep x86_64 | /bin/awk '{print} END {if (NR > 0) print \"found\"}'"
          expect      : "^found$"
        </custom_item>
      </condition>

      <then>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b64 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b64 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b64/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.9 Ensure discretionary access control permission modification events are collected"
              info        : "Monitor changes to file permissions, attributes, ownership and group. The parameters in this section track changes for system calls that affect file permissions and attributes. The following commands and system calls effect the permissions, ownership and various attributes of files.

 - chmod
 - fchmod
 - fchmodat
 - chown
 - fchown
 - fchownat
 - lchown
 - setxattr
 - lsetxattr
 - fsetxattr
 - removexattr
 - lremovexattr
 - fremovexattr

In all cases, an audit record will only be written for non-system user ids and will ignore Daemon events. All audit records will be tagged with the identifier \"perm_mod.\"

Monitoring for changes in file attributes could alert a system administrator to activity that could indicate intruder activity or policy violation."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor discretionary access control permission modification events.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
\" >> /etc/audit/rules.d/50-perm_mod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </then>

      <else>
        <if>
          <condition auto:"FAILED" type:"AND">
            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchmodat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchmodat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 setxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/setxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 removexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/removexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 chmod"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/chmod/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lchown"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lchown/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "b32 fchownat"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fchownat/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lremovexattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lremovexattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 fsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/fsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>

            <custom_item>
              type        : CMD_EXEC
              description : "auditctl b32 lsetxattr"
              cmd         : "UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs); [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"(/^ *-a *always,exit/||/^ *-a *exit,always/) &&/ -F *arch=b32/ &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) &&/ -S/ &&/ -F *auid>=${UID_MIN}/ &&/lsetxattr/ &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" | /bin/awk '{print} END {if (NR != 0) print \"pass\" ; else print \"fail\"}' || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\""
              expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
            </custom_item>
          </condition>

          <then>
            <report type:"PASSED">
              description : "5.2.3.9 Ensure discretionary access control permission modification events are collected"
              info        : "Monitor changes to file permissions, attributes, ownership and group. The parameters in this section track changes for system calls that affect file permissions and attributes. The following commands and system calls effect the permissions, ownership and various attributes of files.

 - chmod
 - fchmod
 - fchmodat
 - chown
 - fchown
 - fchownat
 - lchown
 - setxattr
 - lsetxattr
 - fsetxattr
 - removexattr
 - lremovexattr
 - fremovexattr

In all cases, an audit record will only be written for non-system user ids and will ignore Daemon events. All audit records will be tagged with the identifier \"perm_mod.\"

Monitoring for changes in file attributes could alert a system administrator to activity that could indicate intruder activity or policy violation."
              solution    : "Create audit rules

Edit or create a file in the /etc/audit/rules.d/ directory, ending inrules extension, with the relevant rules to monitor discretionary access control permission modification events.

64 Bit systems

Example:

# {
UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
[ -n \"${UID_MIN}\" ] && printf \"
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
\" >> /etc/audit/rules.d/50-perm_mod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\n\"
}

Load audit rules

Merge and load the rules into active configuration:

# augenrules --load

Check if reboot is required.

# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\n\"; fi

32 Bit systems

Follow the same procedures as for 64 bit systems and ignore any entries with b64"
              reference   : "800-171|3.3.1,800-171|3.3.2,800-171|3.3.6,800-53|AU-3,800-53|AU-3(1),800-53|AU-7,800-53|AU-12,800-53r5|AU-3,800-53r5|AU-3(1),800-53r5|AU-7,800-53r5|AU-12,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.2.3(c),CN-L3|7.1.3.3(a),CN-L3|7.1.3.3(b),CN-L3|8.1.4.3(b),CSCv7|5.5,CSCv8|8.5,CSF|DE.CM-1,CSF|DE.CM-3,CSF|DE.CM-7,CSF|PR.PT-1,CSF|RS.AN-3,CSF2.0|DE.CM-01,CSF2.0|DE.CM-03,CSF2.0|DE.CM-09,CSF2.0|PR.PS-04,CSF2.0|RS.AN-03,CSF2.0|RS.AN-06,CSF2.0|RS.AN-07,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(b),ITSG-33|AU-3,ITSG-33|AU-3(1),ITSG-33|AU-7,ITSG-33|AU-12,LEVEL|2A,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,PCI-DSSv3.2.1|10.1,PCI-DSSv3.2.1|10.3,PCI-DSSv3.2.1|10.3.1,PCI-DSSv3.2.1|10.3.2,PCI-DSSv3.2.1|10.3.3,PCI-DSSv3.2.1|10.3.4,PCI-DSSv3.2.1|10.3.5,PCI-DSSv3.2.1|10.3.6,PCI-DSSv4.0|10.2.2,QCSC-v1|3.2,QCSC-v1|6.2,QCSC-v1|8.2.1,QCSC-v1|10.2.1,QCSC-v1|11.2,QCSC-v1|13.2,SWIFT-CSCv1|6.4"
              see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
              show_output : YES
            </report>
          </then>
        </if>
      </else>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.1 Ensure audit log files are mode 0640 or less permissive"
      info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
      solution    : "Run the following command to remove more permissive mode than 0640 from audit log files:

# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f \( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \) -exec chmod u-x,g-wx,o-rwx {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "[ -f /etc/audit/auditd.conf ] && /bin/find \"$(dirname $(awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | /bin/xargs))\" -type f \\( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \\) -exec /bin/stat -Lc \"%n %#a\" {} + | /bin/awk '{print} END { if(NR==0) print \"pass\"; else print \"fail\"}'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "5.2.4.10 Ensure audit tools belong to group root"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to remove more permissive mode from the audit tools:

# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules

Run the following command to change owner and group of the audit tools to root user and group:

# chown root:root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      owner       : "root"
      mask        : "022"
      group       : "root"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.2 Ensure only authorized users own audit log files"
      info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
      solution    : "Run the following command to configure the audit log files to be owned by the root user:

# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f ! -user root -exec chown root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "[ -f /etc/audit/auditd.conf ] && /bin/find \"$(dirname $(/bin/awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | /bin/xargs))\" -type f ! -user root -exec stat -Lc \"%n %U\" {} + | /bin/awk '{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <if>
      <condition auto:"FAILED" type:"AND">
        <custom_item>
          type        : CMD_EXEC
          description : "Verify if the audit log files are owned by the root or adm group"
          cmd         : "/bin/stat -c \"%n %G\" \"$(dirname $(/bin/awk -F\"=\" '/^[\\s]*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\"/* | /bin/grep -Pv '^\\h*\\H+\\h+(adm|root)\\b' | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
          expect      : "^pass$"
        </custom_item>

        <custom_item>
          type        : FILE_CONTENT_CHECK
          description : "auditd.conf matches log_group = adm or log_group = root"
          file        : "/etc/audit/auditd.conf"
          regex       : "(?i)^[\\s]*log_group[\\s]*="
          expect      : "(?i)^[\\s]*log_group[\\s]*=[\\s]*(adm|root)[\\s]*$"
        </custom_item>
      </condition>

      <then>
        <report type:"PASSED">
          description : "5.2.4.3 Ensure only authorized groups are assigned ownership of audit log files"
          info        : "Audit log files contain information about the system and system activity.

Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
          solution    : "Run the following command to configure the audit log files to be owned by adm group:

# find $(dirname $(awk -F\"=\" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +

Run the following command to configure the audit log files to be owned by the adm group:

# chgrp adm /var/log/audit/

Run the following command to set the log_group parameter in the audit configuration file to log_group = adm :

# sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/' /etc/audit/auditd.conf

Run the following command to restart the audit daemon to reload the configuration file:

# systemctl restart auditd"
          reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
          see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
          show_output : YES
        </report>
      </then>
    </if>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.4 Ensure the audit log directory is 0750 or more restrictive"
      info        : "The audit log directory contains audit log files.

Audit information includes all information including: audit records, audit settings and audit reports. This information is needed to successfully audit system activity. This information must be protected from unauthorized modification or deletion. If this information were to be compromised, forensic analysis and discovery of the true source of potentially malicious system activity is impossible to achieve."
      solution    : "Run the following command to configure the audit log directory to have a mode of \"0750\" or less permissive:

# chmod g-w,o-rwx \"$(dirname $( awk -F\"=\" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf))\""
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/stat -Lc \"%n %a\" \"$(dirname $( /bin/awk -F\"=\" '/^\\s*log_file\\s*=\\s*/ {print $2}' /etc/audit/auditd.conf))\" | /bin/grep -Pv -- '^\\h*\\H+\\h+([0-7][0,1,4,5]0)' | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "(?i)^[\\s]*\\**[\\s]*pass:?[\\s]*\\**$"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.5 Ensure audit configuration files are 640 or more restrictive"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to remove more permissive mode than 0640 from the audit configuration files:

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) -exec /bin/stat -Lc \"%n %a\" {} + | /bin/grep -Pv -- '^\\h*\\H+\\h*([0,2,4,6][0,4]0)\\h*$' | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.6 Ensure audit configuration files are owned by root"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to change ownership to root user:

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -user root | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "5.2.4.7 Ensure audit configuration files belong to group root"
      info        : "Audit configuration files control auditd and what events are audited.

Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events.

Misconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
      solution    : "Run the following command to change group to root :

# find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -group root | /bin/awk \'{print} END { if(NR==0) print \"pass\" ; else print \"fail\"}\'"
      expect      : "^pass$"
      timeout     : "@FIND_TIMEOUT@"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "5.2.4.8 Ensure audit tools are 755 or more restrictive"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to remove more permissive mode from the audit tools:

# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      owner       : "root"
      mask        : "022"
      group       : "root"
    </custom_item>

    <custom_item>
      type        : FILE_CHECK
      description : "5.2.4.9 Ensure audit tools are owned by root"
      info        : "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators.

Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
      solution    : "Run the following command to change the owner of the audit tools to the root user:

# chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2A,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      file        : "/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
      owner       : "root"
      mask        : "022"
      group       : "root"
    </custom_item>

    <custom_item>
      type        : CMD_EXEC
      description : "6.1.10 Audit system file permissions"
      info        : "The RPM package manager has a number of useful options. One of these, the -V for RPM option, can be used to verify that system packages are correctly installed. The -V option can be used to verify a particular package or to verify all system packages. If no output is returned, the package is installed correctly. The following table describes the meaning of output from the verify option:

Code Meaning
S File size differs.
M File mode differs (includes permissions and file type).
5 The MD5 checksum differs.
D The major and minor version numbers differ on a device file.
L A mismatch occurs in a link.
U The file ownership differs.
G The file group owner differs.
T The file time (mtime) differs.

The rpm -qf command can be used to determine which package a particular file belongs to. For example, the following commands determines which package the /bin/bash file belongs to:

# rpm -qf /bin/bash
bash-4.1.2-29.el6.x86_64
# rpm -S /bin/bash
bash: /bin/bash

To verify the settings for the package that controls the /bin/bash file, run the following:

# rpm -V bash-4.1.2-29.el6.x86_64
.M....... /bin/bash
# rpm --verify bash
??5?????? c /etc/bash.bashrc

Note that you can feed the output of the rpm -qf command to the rpm -V command:

# rpm -V `rpm -qf /etc/passwd`
.M...... c /etc/passwd
S.5....T c /etc/printcap

It is important to confirm that packaged system files and directories are maintained with the permissions they were intended to have from the OS vendor."
      solution    : "Correct any discrepancies found and rerun the audit until output is clean or risk is mitigated or accepted."
      reference   : "800-171|3.1.1,800-171|3.1.4,800-171|3.1.5,800-171|3.8.1,800-171|3.8.2,800-171|3.8.3,800-53|AC-3,800-53|AC-5,800-53|AC-6,800-53|MP-2,800-53r5|AC-3,800-53r5|AC-5,800-53r5|AC-6,800-53r5|MP-2,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.4.2(d),CN-L3|8.1.4.2(f),CN-L3|8.1.4.11(b),CN-L3|8.1.10.2(c),CN-L3|8.1.10.6(a),CN-L3|8.5.3.1,CN-L3|8.5.4.1(a),CSCv7|14.6,CSCv8|3.3,CSF|PR.AC-4,CSF|PR.DS-5,CSF|PR.PT-2,CSF|PR.PT-3,CSF2.0|PR.AA-05,CSF2.0|PR.DS-10,CSF2.0|PR.IR-01,GDPR|32.1.b,HIPAA|164.306(a)(1),HIPAA|164.312(a)(1),ISO/IEC-27001|A.6.1.2,ISO/IEC-27001|A.9.4.1,ISO/IEC-27001|A.9.4.5,ITSG-33|AC-3,ITSG-33|AC-5,ITSG-33|AC-6,ITSG-33|MP-2,ITSG-33|MP-2a.,LEVEL|2M,NESA|T1.3.2,NESA|T1.3.3,NESA|T1.4.1,NESA|T4.2.1,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.2,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM3,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,NIAv2|SS29,PCI-DSSv3.2.1|7.1.2,PCI-DSSv4.0|7.2.1,PCI-DSSv4.0|7.2.2,QCSC-v1|3.2,QCSC-v1|5.2.2,QCSC-v1|6.2,QCSC-v1|13.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
      cmd         : "/bin/rpm -Va --nomtime --nosize --nomd5 --nolinkto | /bin/awk '{ print } END { if (NR==0) print \"none\" }'"
      expect      : "^none$"
    </custom_item>
  </then>

  <else>
    <report type:"WARNING">
      description : "CIS_Amazon_Linux_2023_v1.0.0_L2_Server.audit from CIS Amazon Linux 2023 Benchmark v1.0.0"
      info        : "NOTE: Nessus has not identified that the chosen audit applies to the target device."
      see_also    : "https://workbench.cisecurity.org/benchmarks/12705"
    </report>
  </else>
</if>

</check_type>
